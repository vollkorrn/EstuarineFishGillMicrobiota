---
title: "EstuarineFishGillMicrobiota_part5_21.07.24"
output: html_document
date: "2024-07-21"
---

We construct here a abundance correlation based network via WGCNA on CLR transformed 16S data and visualize different aspects in integrated heatmaps and direct correlation to environmental and physiological parameters. 
The Output is directly handed over to Cytoscape which are # here to allow for knitting
Picurst was run on an HPC but seems not informative with many undescribed or lowly described bacterial taxa in this estuarine fish gill dataset. 

# 1 Global Setup 

## 1.1 Path

before you start: 
.rs.restartR()

```{r,  message=FALSE, warning=FALSE, include=FALSE}
GitClonePath <- "/Users/admin/Desktop/EstuarineFishGillMicrobiota"
setwd(GitClonePath)

path_Input_16S <- paste(GitClonePath, "Fish_Input_16S", sep="/")

#Output of the individual Pipeline parts including .rds and .csv
path_Output_16S <- paste(GitClonePath, "Fish_Output_16S", sep="/")

#Output of all plots, the markdowns include only selections
pathPlots          <- paste(GitClonePath, "Fish_Plots", sep="/")

#Create Folder if not existing
ifelse(!dir.exists(file.path(GitClonePath, "Fish_Output_16S")), dir.create(file.path(GitClonePath, "Fish_Output_16S")), FALSE)
ifelse(!dir.exists(file.path(GitClonePath, "Fish_Plots")), dir.create(file.path(GitClonePath, "Fish_Plots")), FALSE)

```

## 1.2 Packages

```{r,  message=FALSE, warning=FALSE, include=FALSE}
# R package management tools such as packrat or renv. These tools allow you to create isolated environments with specific versions of R and installed packages, ensuring reproducibility and avoiding conflicts with other packages installed in your system.
#install.packages("packrat")
#packrat::init()
#packrat::snapshot()
#packrat::restore()

# if (!require("BiocManager", quietly = TRUE))
#     install.packages("BiocManager")
# BiocManager::install(c(
#   "DESeq2",
#   "ComplexHeatmap",
#   "Biostrings",
#   "BiocParallel",
#   "BiocNeighbors",
#   "BiocFileCache",
#   "BiocBaseUtils",
#   "ShortRead",
#   "SummarizedExperiment",
#   "TreeSummarizedExperiment",
#   "phyloseq",
#   "tidyverse",
#   "plyr",
#   "dplyr",
#   "cowplot",
#   "ggrepel",
#   "PCAtools",
#   "ComplexHeatmap",
#   "WGCNA",
#   "dada2",
#   "ShortRead",
#   "phyloseq",
#   "factoextra",
#   "microbiome", #clr transformation
#   "mia",
#   ), force =T)

#install.packages("remotes")
#remotes::install_github("jfq3/ggordiplots")
#install.packages("devtools")
#install.packages("ggordiplots")
#install.packages("RcmdrMisc")
#install.packages("adespatial")
#install.packages("ggVennDiagram")
#install.packages("ggpicrust2")
```

## 1.2 Functions

```{r,  message=FALSE, warning=FALSE, include=FALSE}
#Source the Fish_Functions_19.07.24_Paper.Rmd placed in the working directory
#noamross/source_rmd.R
#https://gist.github.com/noamross/a549ee50e8a4fd68b8b1
source_rmd = function(file, skip_plots = TRUE) {
  temp = tempfile(fileext=".R")
  knitr::purl(file, output=temp)

  if(skip_plots) {
    old_dev = getOption('device')
    options(device = function(...) {
      .Call("R_GD_nullDevice", PACKAGE = "grDevices")
    })
  }
  source(temp)
  if(skip_plots) {
    options(device = old_dev)
  }
}
#source_rmd("Fish_Functions_19.07.24_Paper.Rmd")
source_rmd("/Users/admin/Desktop/EstuarineFishGillMicrobiota/Fish_Functions_19.07.24_Paper.Rmd")
```



## 1.4 Input Files

```{r,  message=FALSE, warning=FALSE, include=FALSE}
#Sequencing was performed in 3 runs and 2 batches, Batch1 was sequenced twice to increase sequencing depth
#all runs were individually processed in the Dada2 pipeline and merged at the seqtab step
#########################
#Read DADA2 Output files#

taxa  <-readRDS(file.path(path_Input_16S, "Fish_17.09.23_mergemerge-Taxa_Species.rds"))
seqtab.nochim <-  readRDS(file.path(path_Input_16S, "Fish_17.09.23_mergeseqtab.nochim.rds"))
ReadNum1 <-  read.csv2(file.path(path_Input_16S, "Fish_Batch1-31.07.23_470_Track_reads_through_pipeline.csv"))
ReadNum2 <-  read.csv2(file.path(path_Input_16S, "Fish_Batch1-Reseq-31.07.23_470_Track_reads_through_pipeline.csv"))
ReadNum3 <-  read.csv2(file.path(path_Input_16S, "Fish_Batch2-26.07.23_470_Track_reads_through_pipeline.csv"))

########################################################################
#Import samplefile and filter for samples with successful 16S sequencing
library(readxl)
SAMDF16S<- as.data.frame(read_excel(file.path(path_Input_16S, "Fish_samplefile_24.03.2024.xlsx")))[,-1]
write.table(SAMDF16S, file=file.path(path_Input_16S, "Fish_samplefile_24.03.2024.csv"), sep=";",dec = ".")

SAMDF16S <-read.table(file=file.path(path_Input_16S, "Fish_samplefile_24.03.2024.csv"), sep=";",dec = ".")
rownames(SAMDF16S) <- SAMDF16S$SampleID

```


## 1.5 Tutorials

```{r, message=FALSE, warning=FALSE,  include=FALSE}
#https://userweb.eng.gla.ac.uk/umer.ijaz/projects/microbiomeSeq_Tutorial.html#co-occur

#NEW Works on summarized Expderiments
#https://microbiome.github.io/OMA/differential-abundance.html#differential-abundance-analysis

#Bioconductor by Callahan
#https://bioconductor.org/help/course-materials/2017/BioC2017/Day1/Workshops/Microbiome/MicrobiomeWorkflowII.html#hierarchical_multiple_testing

#Microbiome seq
#https://userweb.eng.gla.ac.uk/umer.ijaz/projects/microbiomeSeq_Tutorial.html
#https://userweb.eng.gla.ac.uk/umer.ijaz/bioinformatics/ecological.html

#Olberding
#https://www.nicholas-ollberding.com/post/introduction-to-the-statistical-analysis-of-microbiome-data-in-r/

#Nice DESEQ2
#https://astrobiomike.github.io/amplicon/dada2_workflow_ex

#CAP Plot
#https://deneflab.github.io/MicrobeMiseq/demos/mothur_2_phyloseq.html
```


## 1.6 Setup Analysis

```{r,  message=FALSE, warning=FALSE, include=FALSE}
#Date of the Analysis for save-names#
Date <- "19.07.2024"
set.seed(123)
Species    <- "OE_GC"
Kind       <- "Fish"
Tissue     <- "Gill"
Year       <- "2021_2022"
Season     <- "SU_AU_WI_SP"
Type       <- "16S"
alpha      <- 0.05
OperatingSystem <- "Windows"
prefix <- "SSU-"
#Differential Abundance Testing
OutlineColor <- "grey20"

#####################
variable = Comparisons = "Replicates2"
#####################
LocOrder=c("Medem Grund", "Brunsbuettel", "Schwarztonnen Sand", "Twielenfleth","Muehlenberger Loch")
SeasonOrder <-c("Summer_21", "Autumn_21", "Winter_22", "Spring_22")
CruiseOrder<-c("Elbe_Summer_21", "Elbe_Autumn_21", "Elbe_Winter_22","Elbe_Spring_22")

VariableOrder<-c(
  "GCSU21BB", "GCSU21SS", "GCSU21TW", "GCSU21ML", 
  "GCAU21BB", "GCAU21SS", "GCAU21TW", "GCAU21ML", 
  "GCWI22BB", "GCWI22SS",             "GCWI22ML", 
  "GCSP22BB", "GCSP22SS", "GCSP22TW", "GCSP22ML", 
  
  "OESU21MG", "OESU21BB", "OESU21SS", "OESU21TW", "OESU21ML", 
  "OEAU21MG", "OEAU21BB", "OEAU21SS", "OEAU21TW", "OEAU21ML",
  "OEWI22MG", "OEWI22BB", "OEWI22SS", "OEWI22TW", "OEWI22ML",
  "OESP22MG", "OESP22BB", "OESP22SS", "OESP22TW", "OESP22ML",
  
  "WF")


LocOrder=c("Medem Grund", "Brunsbuettel", "Schwarztonnen Sand","Twielenfleth", "Muehlenberger Loch")
LOCOrder=c("MG-713", "BB-692", "SS-665","TF-651", "ML-633")
save_name <- paste(Species,Year,Season,sep = "_")
#Check your Output: 
paste0(file.path(path_Output_16S, "DAT_"), save_name, ".RData")

SAMDF16S$LOC<-ifelse(SAMDF16S$Loc == "Medem Grund", "MG-713",
                      ifelse(SAMDF16S$Loc == "Brunsbuettel", "BB-692",
                          ifelse(SAMDF16S$Loc == "Schwarztonnen Sand", "SS-665",
                                  ifelse(SAMDF16S$Loc == "Twielenfleth", "TF-651",
                                        ifelse(SAMDF16S$Loc == "Muehlenberger Loch", "ML-633", NA)))))

SAMDF16S$"geographic.location..latitude."<-ifelse(SAMDF16S$Loc == "Medem Grund", "53.8363",
                      ifelse(SAMDF16S$Loc == "Brunsbuettel", "53.8874",
                          ifelse(SAMDF16S$Loc == "Schwarztonnen Sand", "53.71442",
                                  ifelse(SAMDF16S$Loc == "Twielenfleth", "53.60921",
                                        ifelse(SAMDF16S$Loc == "Muehlenberger Loch", "53.54907", NA)))))
SAMDF16S$"geographic.location..longitude."<-ifelse(SAMDF16S$Loc == "Medem Grund", "8.88777",
                      ifelse(SAMDF16S$Loc == "Brunsbuettel", "9.19429",
                          ifelse(SAMDF16S$Loc == "Schwarztonnen Sand", "9.46976",
                                  ifelse(SAMDF16S$Loc == "Twielenfleth", "9.56536",
                                        ifelse(SAMDF16S$Loc == "Muehlenberger Loch", "9.82338", NA)))))

SAMDF16S$Reps <- sub("^.{2}", "", SAMDF16S$Replicates2)
SAMDF16S$Reps<- ifelse(SAMDF16S$Reps == "SU21MG", "SU 713",
                            ifelse(SAMDF16S$Reps == "SU21BB", "SU 692",
                            ifelse(SAMDF16S$Reps == "SU21SS", "SU 665",
                            ifelse(SAMDF16S$Reps == "SU21TW", "SU 651",
                            ifelse(SAMDF16S$Reps == "SU21ML", "SU 633", 
                                   
                            ifelse(SAMDF16S$Reps == "AU21MG", "AU 713",
                            ifelse(SAMDF16S$Reps == "AU21BB", "AU 692",
                            ifelse(SAMDF16S$Reps == "AU21SS", "AU 665",
                            ifelse(SAMDF16S$Reps == "AU21TW", "AU 651",
                            ifelse(SAMDF16S$Reps == "AU21ML", "AU 633", 
                            
                            ifelse(SAMDF16S$Reps == "WI22MG", "WI 713",
                            ifelse(SAMDF16S$Reps == "WI22BB", "WI 692",
                            ifelse(SAMDF16S$Reps == "WI22SS", "WI 665",
                            ifelse(SAMDF16S$Reps == "WI22TW", "WI 651",
                            ifelse(SAMDF16S$Reps == "WI22ML", "WI 633", 
                                   
                            ifelse(SAMDF16S$Reps == "SP22MG", "SP 713",
                            ifelse(SAMDF16S$Reps == "SP22BB", "SP 692",
                            ifelse(SAMDF16S$Reps == "SP22SS", "SP 665",
                            ifelse(SAMDF16S$Reps == "SP22TW", "SP 651",
                            ifelse(SAMDF16S$Reps == "SP22ML", "SP 633", 
                                   "WF")))))
                            )))))))))))))))

     RepOrder <-c(
    "SU 713", "SU 692","SU 665","SU 651","SU 633", 
    "AU 713","AU 692","AU 665","AU 651","AU 633", 
    "WI 713","WI 692","WI 665","WI 651","WI 633", 
    "SP 713","SP 692","SP 665","SP 651","SP 633")
     

SAMDF16S$RepsSpecs <- paste(SAMDF16S$Species, SAMDF16S$Reps, sep=" ")
SAMDF16S$RepsSpecs[SAMDF16S$RepsSpecs == "WF"] <- "WF"

SAMDF16S$HSI     <- SAMDF16S$LiverWeight/SAMDF16S$Weight*100
SAMDF16S$SSI     <- SAMDF16S$SpleenWeight/SAMDF16S$Weight*100
SAMDF16S$GSI     <- SAMDF16S$GonadWeight/SAMDF16S$Weight*100
SAMDF16S$FCF <-  (100*SAMDF16S$Weight/(SAMDF16S$Length/10)^3)
SAMDF16S$FI  <- SAMDF16S$StomachContent/SAMDF16S$Weight*100
 
SAMDF16S <- SAMDF16S %>% mutate(Maturity = case_when(
                    (Species== "GC" & Length >= 10.5) ~ "Adult", 
                    (Species== "GC" & Length < 10.5) ~ "Juvenile", 
                    (Species== "OE" & Length >= 10) ~ "Adult", Length < 10 ~ "Juvenile"))

SAMDF16S <- SAMDF16S %>% 
  mutate(Age = case_when(
    Species != "OE" ~ as.character(Age),  
    (Species == "OE" & Length < 90) ~ "0", 
    (Species == "OE" & Length <= 130) ~ "1", 
    (Species == "OE" & Length <= 180) ~ "2", 
    (Species == "OE" & Length <= 220) ~ "3", 
    (Species == "OE" & Length > 220) ~ "4"
  ))
SAMDF16S$Age <- as.numeric(SAMDF16S$Age)

SAMDF16S$fSeason <- factor(SAMDF16S$Season, level = SeasonOrder)
SAMDF16S$fLOC <- factor(SAMDF16S$LOC, level = LOCOrder)
SAMDF16S$Species <- substr(SAMDF16S$SampleID, 1, nchar(SAMDF16S$SampleID) - 9)
SAMDF16S$fReplicates <- factor(SAMDF16S$Replicates, levels = VariableOrder[VariableOrder %in%                                                                               SAMDF16S$Replicates])

SAMDF16S$fCruise <- factor(SAMDF16S$Cruise, level = CruiseOrder)

#Adding in Elbe Estuary Public Monitoring Data from https://www.fgg-elbe.de/fachinformationssystem.html
Mean_AbioticsFGG <- readRDS(file.path(path_Input_16S, "Mean_AbioticsFGG_16.02.24.rds"))
names(Mean_AbioticsFGG)[names(Mean_AbioticsFGG) == "Season"] <- "Cruise"
names(SAMDF16S)[names(SAMDF16S) == "O2"] <- "O2_catch"
names(SAMDF16S)[names(SAMDF16S) == "O2Sat"] <- "O2Sat_catch"
names(SAMDF16S)[names(SAMDF16S) == "pH"] <- "pH_catch"

colnames(Mean_AbioticsFGG) <- sub("_mean", "",colnames(Mean_AbioticsFGG))
SAMDF16S <- dplyr::left_join(SAMDF16S, Mean_AbioticsFGG)

SSU_Samples <-c(
#Ruffe
#Summer21
"GCSU21BBEB1", "GCSU21BBEB2", "GCSU21BBEB4", "GCSU21BBEB5",                              "GCSU21BBFL3",
"GCSU21SSEB1", "GCSU21SSEB2", "GCSU21SSEB3", "GCSU21SSEB4", "GCSU21SSEB8","GCSU21SSFL1", "GCSU21SSFL3",
"GCSU21TWEB1", "GCSU21TWEB2", "GCSU21TWEB3", "GCSU21TWEB4", "GCSU21TWFL1", "GCSU21TWFL2", "GCSU21TWFL3",
"GCSU21MLEB1", "GCSU21MLEB2", "GCSU21MLEB3", "GCSU21MLEB5", "GCSU21MLEB6", "GCSU21MLFL1", "GCSU21MLFL2", "GCSU21MLFL3", "GCSU21MLFL6",

#"GCSU21BBEB6" missing physiology
#"GCSU21BBFL2" equal to water samples 

#Autumn21
"GCAU21BBEB1", "GCAU21BBEB2", "GCAU21BBEB3", "GCAU21BBFL1", "GCAU21BBFL2", "GCAU21BBFL3", "GCAU21BBFL4",
"GCAU21SSEB1", "GCAU21SSEB3", "GCAU21SSEB5", "GCAU21SSEB7", "GCAU21SSFL1", "GCAU21SSFL3", "GCAU21SSFL5",
"GCAU21TWEB1", "GCAU21TWFL1", "GCAU21TWFL2",
"GCAU21MLEB1", "GCAU21MLEB2", "GCAU21MLEB3", "GCAU21MLFL1", "GCAU21MLFL3", "GCAU21MLFL5", "GCAU21MLFL7", 
#Winter21
"GCWI22BBEB1", "GCWI22BBFL1", "GCWI22BBFL2",
"GCWI22SSEB1", "GCWI22SSEB2", "GCWI22SSEB3", "GCWI22SSFL1", "GCWI22SSFL2", 
"GCWI22MLEB1", "GCWI22MLFL1", "GCWI22MLFL2",
#Spring21
"GCSP22BBEB1", "GCSP22BBEB3", "GCSP22BBEB5", "GCSP22BBEB7", "GCSP22BBEB9", "GCSP22BBFL1", "GCSP22BBFL2",
"GCSP22SSEB1", "GCSP22SSEB3", "GCSP22SSEB5", "GCSP22SSEB7", "GCSP22SSFL1", "GCSP22SSFL3", "GCSP22SSFL5",
"GCSP22TWEB1", "GCSP22TWFL1", "GCSP22TWFL2", "GCSP22TWFL3",   
"GCSP22MLEB1", "GCSP22MLEB3", "GCSP22MLEB5", "GCSP22MLEB7", "GCSP22MLFL1", "GCSP22MLFL3", "GCSP22MLFL5",
#Summer22 ML
#"GCSU22MLEB1", "GCSU22MLEB2", "GCSU22MLEB3", "GCSU22MLEB4", "GCSU22MLEB5", "GCSU22MLEB6", "GCSU22MLEB7",  

#Smelt
"OESU21MGEB1", "OESU21MGEB4", "OESU21MGEB6", "OESU21MGEB8", "OESU21MGEB9", "OESU21MGFL2", "OESU21MGFL6",
"OESU21BBEB5", "OESU21BBEB6", "OESU21BBEB7", "OESU21BBEB8", "OESU21BBEB9", "OESU21BBFL1", "OESU21BBFL4",
"OESU21SSEB6", "OESU21SSEB7", "OESU21SSEB8", "OESU21SSEB9", "OESU21SSFL1", "OESU21SSFL2", "OESU21SSFL6",
"OESU21TWEB2", "OESU21TWEB3", "OESU21TWEB4", "OESU21TWFL1", "OESU21TWFL3", "OESU21TWFL5", "OESU21TWFL7",
"OESU21MLEB1", "OESU21MLEB2", "OESU21MLEB3", "OESU21MLFL1", "OESU21MLFL2",

"OEAU21MGEB1", "OEAU21MGEB3", "OEAU21MGEB5", "OEAU21MGEB7", "OEAU21MGFL1", "OEAU21MGFL3", "OEAU21MGFL5",
"OEAU21BBEB1", "OEAU21BBEB3", "OEAU21BBEB6", "OEAU21BBEB7", "OEAU21BBFL2", "OEAU21BBFL4", "OEAU21BBFL6",
"OEAU21SSEB1", "OEAU21SSEB3", "OEAU21SSEB5", "OEAU21SSEB8", "OEAU21SSFL1", "OEAU21SSFL3", "OEAU21SSFL6",
"OEAU21TWEB1", "OEAU21TWEB3", "OEAU21TWEB5", "OEAU21TWEB7", "OEAU21TWFL1", "OEAU21TWFL3", "OEAU21TWFL7",
"OEAU21MLEB1", "OEAU21MLEB3", "OEAU21MLEB5", "OEAU21MLEB7", "OEAU21MLFL1", "OEAU21MLFL3", "OEAU21MLFL7",

"OEWI22BBEB1", "OEWI22BBEB4", "OEWI22BBEB5", "OEWI22BBEB7", "OEWI22BBFL1", "OEWI22BBFL3", "OEWI22BBFL7", 
"OEWI22MGEB1", "OEWI22MGEB3", "OEWI22MGEB5", "OEWI22MGEB9", "OEWI22MGFL1", "OEWI22MGFL3", "OEWI22MGFL7",
"OEWI22SSEB1", "OEWI22SSEB5", "OEWI22SSEB7", "OEWI22SSEB9", "OEWI22SSFL1", "OEWI22SSFL5", "OEWI22SSFL8",  
"OEWI22TWEB1", "OEWI22TWEB2", "OEWI22TWEB3", "OEWI22TWEB4", "OEWI22TWEB5", "OEWI22TWEB7", "OEWI22TWEB9",
"OEWI22MLEB1", "OEWI22MLEB3", "OEWI22MLEB7", "OEWI22MLEB9", "OEWI22MLFL1", "OEWI22MLFL5", "OEWI22MLFL7", 

"OESP22MGEB1", "OESP22MGEB3", "OESP22MGEB5", "OESP22MGEB7", "OESP22MGFL1", "OESP22MGFL3", "OESP22MGFL5",
"OESP22BBEB1", "OESP22BBEB3", "OESP22BBEB7", "OESP22BBEB8", "OESP22BBFL2", "OESP22BBFL3", "OESP22BBFL5",
"OESP22SSEB1", "OESP22SSEB2", "OESP22SSEB3", "OESP22SSEB4", "OESP22SSFL1", "OESP22SSFL3", "OESP22SSFL5",
"OESP22TWEB1", "OESP22TWEB2", "OESP22TWEB5", "OESP22TWFL1", "OESP22TWFL3", "OESP22TWFL5", "OESP22TWFL7",
"OESP22MLEB1", "OESP22MLEB2", "OESP22MLEB3", "OESP22MLFL1", "OESP22MLFL2", "OESP22MLFL3", "OESP22MLFL4",

#"OESU22MLEB1", "OESU22MLEB2", "OESU22MLEB3", "OESU22MLEB4", 

"WFSU21MGEB",
"WFSU21BBEB",
"WFSU21SSFL",
"WFSU21MLFL", 

"WFAU21TWEB",

"WFWI22MGEB", "WFWI22MGFL",
"WFWI22BBEB", "WFWI22BBFL",
"WFWI22MLFL", "WFWI22SSFL", 

"WFSP22MGEB", "WFSP22MGFL",
"WFSP22BBEB", "WFSP22BBFL", 
"WFSP22SSEB", "WFSP22SSFL",
"WFSP22MLEB", "WFSP22MLFL"

#"WFSU22MLEB"
)
      
SAMDF16S$Species[SAMDF16S$Species == "W"] <- "WF"
SAMDF16S$fSpecies <- factor(SAMDF16S$Species, levels=c("WF", "OE", "GC"))


###########################################################################################################
#For ENA_Sample Submission! Open in Numbers or Libre office, stupid Excel will destroy geo and other data!#
###########################################################################################################
  write.table(SAMDF16S, paste0(file.path(path_Output_16S, paste(paste(save_name,
            paste("SAMDF16S", sep=""),sep="_"),".txt", sep=""))), dec = ".", sep = "\t")

pslistraw <- readRDS(file.path(path_Output_16S, paste(paste(save_name,"ps_16S_merge_pslistraw", Date, sep="_"), ".rds", sep="")))

pslist <- readRDS(file.path(path_Output_16S,paste(paste(save_name, "ps_16S_merge_Filter_ASV_besttax", Date, sep="_"), ".rds", sep="")))
```

#-

# 9  Overall Network

Some seasonal networks as conststuced here: 

https://journals.asm.org/doi/full/10.1128/spectrum.02943-23

Finally, three metrics have been extracted from the networks with the function “Network Analyzer” in Cytoscape: degree (DG), neighborhood connectivity (NC), and closeness centrality (CC). Those network topological parameters allow a better understanding of the dynamics in different networks. DG is the number of edges connected from one node to another (184). The more a node has edges, the more it is locally connected, indicating its relevance in the network (185). CC is a qualitative measure that indicates if a node is close to the other nodes in the network (186). The shortest path length to spread information from one node to another is represented, and it indicates if the node has an important influence in the network and how it can interact with other nodes (184). Finally, NC is a quantitative measure that calculates the average connectivity of a node to the other nodes in the network. It indicates how the node impacts in the network dynamics (187).

works, just un-# the whole chunk

```{r, message=FALSE, warning=FALSE, include=FALSE}
# TaxLevel <- "Genus"
# for (Dataset in names(pslist)[!grepl("WF", names(pslist))][grepl("ps_SSU", names(pslist)[!grepl("WF", names(pslist))])]) {
# 
#   print("
#   1. We create a rarefied dataset selecting only samples with at least 5000 reads
#   2. We create a spearman correlation matrix adjusted by Holm methods for all ASVs per Season pased on a rarefied dataset
#   3.  we create a SSU_dataset with mean ASV values for all samples and by seasonal groups and use them as attributed for Cytoscape
#   4. Then we export all data for import to Cytoscape")
#   
#   require(WGCNA)
#   require(plyr)
#   require(dplyr)
#   require(ggrepel) 
#   require(cowplot)
#   require(phyloseq)
#   require(Hmisc)
#   
#   Datasetname <- sub("ps_", "", Dataset)
#   ps          <- merge_phyloseq(pslist$ps_OE, pslist$ps_GC, pslist$ps_WF)
# 
#   
#   #########################
#   #Filtering and Rarefying#
#   if (Datasetname %in% c("SSU")) {
#       print(paste("Samples removed for low frequency below 5000 seqs in;", Dataset, sep = ""))
#       print(which(rowSums(otu_table(ps)) < 5000))
#       ps_Filter <- subset_samples(ps, sample_sums(ps) > 5000)
#     } 
#     
#   print("rarefy to depth")
#   ps_rare <- phyloseq::rarefy_even_depth(ps_Filter , rngseed = 123, replace = FALSE)
#   print(unique(rowSums(otu_table(ps_rare))))
#   
#     
#   ps_rare <- ps_rare %>%
#     tax_glom(taxrank =  TaxLevel)   #%>%  
#     #transform_sample_counts(function(x) {x/sum(x)*100}) %>% # Transform to rel. abundance
#     #psmelt() %>%                                         # Melt to long format
#     #filter(Abundance > 1) %>%                       # Filter out low abundance taxa
#     #arrange(Genus)        #%>%                                # Sort data frame alphabetically by phylum
#     #dplyr::arrange(desc(Abundance))
#     
#   ############################################################################
#   #Create WGCNA Dataframe: Species, ModuleMembership, Correlation to Abiotics#
#   ############################################################################
# 
#   TAX <- as.data.frame(tax_table(ps_rare))
#   OTU <- as.data.frame(t(phyloseq::otu_table(ps_rare)))
# 
#   #################################
#   #Creating AverageSums per Season#
#   #################################
#   SpeciesSums <- ps_rare %>%
#     transform_sample_counts(function(x) {x/sum(x)*100}) %>%
#     phyloseq::otu_table() %>%
#     as.data.frame() %>%
#     rownames_to_column(var = "SampleID") %>%
#     dplyr::left_join(SAMDF16S, by = c("SampleID" = "SampleID")) %>%
#     dplyr::group_by(Species) %>%
#     dplyr::summarise(dplyr::across(rownames(tax_table(ps_rare)), mean, na.rm = TRUE)) %>% 
#     t() %>%
#     as.data.frame() %>%
#     `colnames<-`(.[1, ]) %>%
#     .[-1, ] %>%
#     setNames(paste0("avg_", colnames(.))) %>%
#     mutate_all(as.numeric) %>%
#     rownames_to_column(var="ASV")
# 
#     SSU_Data  <- TAX %>%  
#      rownames_to_column(var = "ASV") %>% 
#        left_join( #Add relative ASVmeans 
#        data.frame(t(phyloseq::otu_table(ps_rare %>%
#         transform_sample_counts(function(x) {x/sum(x)*100})))) %>%
#           dplyr::mutate(ASVmeans = rowMeans(.)) %>%
#           dplyr::mutate(ASV = rownames(.)) %>% 
#           dplyr::select(ASV, ASVmeans)
#        ) %>%
#       left_join( #Add Sums by Season
#         SpeciesSums
#        ) 
#   
#    rownames(SSU_Data) <- SSU_Data$ASV
#    
#    #for (Season in unique(SAMDF16S$Season)) {
#      
#     ps_sub <- ps_rare #prune_samples(sample_data(ps_rare)$Season == Season, ps_rare)
#     
#     otu.table.filter <- data.frame(otu_table(ps_sub)[ ,colSums(otu_table(ps_sub)) >= 10])
#     names(otu.table.filter) <- sub("\\..*", "", names(otu.table.filter))
#     
#     tax <- as.data.frame(tax_table(ps_sub))
#     rownames(tax) <- sub(":.*", "",  rownames(tax))
#     
#     #otu.cor <- Hmisc::rcorr(as.matrix(otu.table.filter), type="spearman")
#     #We use the Holm-corrected rcorr function here and modifyed it to return numeric values
#     
#     ASV.cor_adjust <- rcorr.adjust_RK(as.matrix(otu.table.filter), type="spearman")
#     
#     ASV.pval <- Matrix::forceSymmetric(ASV.cor_adjust$P) # Self-correlation as NA
#     sel.tax <- tax[rownames(ASV.pval),,drop=FALSE]
#     all.equal(rownames(sel.tax), rownames(ASV.pval))
# 
#     p.yes <- ASV.pval < 0.05
#     r.val = ASV.cor_adjust$R$r # select all the correlation values 
#     p.yes.r <- r.val*p.yes # only select correlation values based on p-value criterion 
#     p.yes.r <- abs(p.yes.r) > 0.5 # output is logical vector
#     p.yes.rr <- p.yes.r*r.val # use logical vector for subscripting.
#     adjm <- as.matrix(p.yes.rr)
#     print(min(na.omit(p.yes.rr@x)))
#     
#     #From Sylvain 2023
#     ASVs <- colnames(ASV.cor_adjust$P.unadj)
#     Sample.comparison <- paste(ASVs[row(ASV.cor_adjust$P.unadj)], ASVs[col(ASV.cor_adjust$P.unadj)],
#                                sep="_")
#     i <- lower.tri(ASV.cor_adjust$P.unadj)
#     Dat <- data.frame(Sample.comparison[i], p.value=ASV.cor_adjust$P.unadj[i])
#     Dat$BH <- p.adjust(Dat$p.value, method="BH")
#     ASVs <- colnames(ASV.cor_adjust$R$r)
#     Sample.comparison <- paste(ASVs[row(ASV.cor_adjust$R$r)], ASVs[col(ASV.cor_adjust$R$r)], sep="_")
#     i <- lower.tri(ASV.cor_adjust$R$r)
#     Correlation <- data.frame(Sample.comparison[i], correlation.spearman=ASV.cor_adjust$R$r[i], Dat$BH)
#     Correlation_BH <- subset(Correlation, Dat.BH < 0.05)
#     head(Correlation_BH)
#     
#     ############################
#     #Short Igraph visualization#
#     # net.grph=igraph::graph.adjacency(adjm,mode="undirected",weighted=TRUE,diag=FALSE)
#     # edgew<-igraph::E(net.grph)$weight
#     # bad.vs<-igraph::V(net.grph)[igraph::degree(net.grph) == 0] 
#     # net.grph <-igraph::delete.vertices(net.grph, bad.vs)
#     # plot(net.grph,
#     #   vertex.size=8,
#     #   vertex.frame.color="black",
#     #   edge.curved=F,
#     #   edge.width=1.5,
#     #   #layout=layout.fruchterman.reingold,
#     #   edge.color=ifelse(edgew < 0,"red","blue"),
#     #   #vertex.label=NA,
#     #   vertex.label.color="black",
#     #   vertex.label.family="Times New Roman",
#     #   vertex.label.font=2)
#     ###############################
#       
#     #Selecting a taxonomic rank, not necessary for Cytoscape as we export attributes
#     #colnames(adjm) <- as.vector(sel.tax$Class)
#     #rownames(adjm) <- as.vector(sel.tax$Class)
#   
#     #dimnames(adjm)[[1]] <-   sub("\\..*", "", dimnames(adjm)[[1]])
#     #dimnames(adjm)[[2]] <-   sub("\\..*", "", dimnames(adjm)[[2]])
#     
#     rownames(SSU_Data) <- sub(":.*", "", SSU_Data$ASV)
#     SSU_Data_sub <- SSU_Data[rownames(SSU_Data) %in% dimnames(adjm)[[1]], ]
#     
#     #####################################################################
#     #Just to be shure the order is same and get proper names back to adjm
#     indices <- match(dimnames(adjm)[[1]], rownames(SSU_Data_sub))
#     SSU_Data_sub <- SSU_Data_sub[indices, ]
#     dimnames(adjm) = list(SSU_Data_sub$ASV, SSU_Data_sub$ASV)
#     rownames(SSU_Data_sub) <- SSU_Data_sub$ASV
#     
#     ##################################
#     #Select only top 50 Abundant ASVs#
#     top_ASVs <- head(SSU_Data_sub[order(SSU_Data_sub$ASVmeans, decreasing = TRUE), ], 200)$ASV
#     
#     adjm_top <- adjm[top_ASVs, top_ASVs]
#     SSU_Data_sub <- SSU_Data_sub[SSU_Data_sub$ASV %in% top_ASVs,]
#     
#     SSU_Data_sub$ASVname <- gsub("^ASV\\d+:", "", SSU_Data_sub$ASV)
#     
#     ####################
#     #Export to cytoscape#
#     cyt = exportNetworkToCytoscape(adjm_top,
#       edgeFile =     paste(paste(file.path(path_Output_16S,"Spearman_CytoscapeInput_ASV_edges"), 
#                                paste(Datasetname, sep="_"), sep="_"), "txt", sep ="."),
#       nodeFile =  paste(paste(file.path(path_Output_16S,"Spearman_CytoscapeInput_ASV_nodes"), 
#                             paste(Datasetname, sep="_"), sep="_"), "txt", sep ="."),
#       weighted = TRUE,
#       #threshold = 0.1, 
#       nodeNames = SSU_Data_sub$ASV,
#       altNodeNames = SSU_Data_sub$ASVname ,
#       nodeAttr = SSU_Data_sub)
# 
# }
# 
# 
# ##############################
# #Import Networks to Cytoscape#
# ##############################
# library("RCy3")
# cytoscapePing () # make sure cytoscape is open
# cytoscapeVersionInfo ()
# for (Dataset in names(pslist)[!grepl("WF", names(pslist))][grepl("ps_SSU", names(pslist)[!grepl("WF", names(pslist))])]) {
# 
#   require(WGCNA)
#   require(plyr)
#   require(dplyr)
#   require(ggrepel) 
#   require(cowplot)
#   require(phyloseq)
#   require(Hmisc)
#   
#   Datasetname <- sub("ps_", "", Dataset)
#    tryCatch({
# 
#     edge <- read.delim(paste(paste(file.path(path_Output_16S,"Spearman_CytoscapeInput_ASV_edges"), 
#                                paste(Datasetname, sep="_"), sep="_"), "txt", sep ="."))
#     
#     node <- read.delim(paste(paste(file.path(path_Output_16S,"Spearman_CytoscapeInput_ASV_nodes"), 
#                                paste(Datasetname,  sep="_"), sep="_"), "txt", sep ="."))
# 
#     node <- node %>% 
#       dplyr::mutate(id = nodeName) %>%
#       dplyr::select(id, everything())
#     
#     edge <- edge %>%
#       rename("fromNode"     = "source") %>%
#       rename("toNode"     =  "target") %>%
#       rename("direction"     = "interaction") 
# 
#     createNetworkFromDataFrames(node, edge, title= paste(Datasetname, sep="_"),
#                               collection=paste("DataFrame", Datasetname, sep="_"))
#   
#     ###########################
#     #Set some style parameters#
#     ###########################
#     #getVisualPropertyNames()
#     setVisualStyle('Sample1')
#     # set up my own style
#     style.name = paste("Style", Datasetname, sep="_")
#     defaults <- list( #NODE_SHAPE="diamond",
#                     NODE_SIZE=10,
#                     NODE_FILL_COLOR ="black",
#                     EDGE_TRANSPARENCY=120
#                     #NODE_LABEL_POSITION="W,E,c,0.00,0.00"
#                     )
#     nodeLabels <- mapVisualProperty('node label','id','p')
#     arrowShapes <- mapVisualProperty('Edge Target Arrow     Shape','interaction','d',c("activates","inhibits","interacts"),c("Arrow","T","None"))
#   
#   edgeWidth <- mapVisualProperty('edge width','weight','p')
#   
#     nodeFills <- mapVisualProperty('node fill color','Phylum','d',names(phylum_colors_Cytoscape), as.character(phylum_colors_Cytoscape))
# 
#   #nodeSize<- mapVisualProperty('NODE_SIZE','avg_Spring_22','c',c(0, 100),c(10, 1000))
#   
#   nodeSize <- mapVisualProperty('NODE_SIZE',paste0("ASVmeans"), 'c', c(0, 100), c(10, 1000))
#   
#   nodeLabelSize <- mapVisualProperty('NODE_LABEL_FONT_SIZE', paste0("ASVmeans"), 'c', c(0, 100), c(20, 100))
# 
#   nodeLabel<-mapVisualProperty('node label','ASVname','p')
#     
#    createVisualStyle(style.name, defaults, list(nodeLabels,arrowShapes,nodeFills, nodeLabel, nodeSize, edgeWidth, nodeLabelSize))
#    
#   setVisualStyle(style.name)
# 
#    }, error=function(e){cat("ERROR :",conditionMessage(e), "\n")})
#   }
# 
# 
# 
# # Summer_2021 # Number of edges: 851 
# # Summary Statistics  
# # Number of nodes: 339  
# # Number of edges: 851  
# # Avg. number of neighbors:    7,410  
# # Network diameter: 11  
# # Network radius: 6  
# # Characteristic path length:    4,581  
# # Clustering coefficient:    0,392  
# # Network density:    0,041  
# # Network heterogeneity:    0,902  
# # Network centralization:    0,120  
# # Connected components: 41  
# # Analysis time (sec):    0,113   
# 
# #Autumn_2021 # Number of edges: 721 
# # Summary Statistics  
# # Number of nodes: 360  
# # Number of edges: 721  
# # Avg. number of neighbors:    3,461  
# # Network diameter: 15  
# # Network radius: 8  
# # Characteristic path length:    4,803  
# # Clustering coefficient:    0,183  
# # Network density:    0,030  
# # Network heterogeneity:    0,880  
# # Network centralization:    0,112  
# # Connected components: 61  
# # Analysis time (sec):    0,023  
# 
# #Winter_2022
# # Summary Statistics  
# # Number of nodes: 218  
# # Number of edges: 587  
# # Avg. number of neighbors:    4,566  
# # Network diameter:   7  
# # Network radius:   4  
# # Characteristic path length:    3,068  
# # Clustering coefficient:    0,328  
# # Network density:    0,088  
# # Network heterogeneity:    0,927  
# # Network centralization:    0,268  
# # Connected components:  29  
# # Analysis time (sec):    0,011 
# 
# #Spring_2022
# # Summary Statistics  
# # Number of nodes: 364  
# # Number of edges: 1570  
# # Avg. number of neighbors:    4,466  
# # Network diameter:   8  
# # Network radius:   4  
# # Characteristic path length:    3,279  
# # Clustering coefficient:    0,272  
# # Network density:    0,044  
# # Network heterogeneity:    1,073  
# # Network centralization:    0,245  
# # Connected components:  27  
# # Analysis time (sec):    0,026  
# 
# #DG is the number of edges connected from one node to another (184). The more a node has edges, the more it is locally connected, indicating its relevance in the network (185)
# # Summer_2021 # Number of edges: 851 
# # Autumn_2021 # Number of edges: 721 
# # Winter_2022 # Number of edges: 587  
# # Spring_2022 # Number of edges: 1570  
# 

```

closeness centrality (CC).
CC is a qualitative measure that indicates if a node is close to the other nodes in the network (186). The shortest path length to spread information from one node to another is represented, and it indicates if the node has an important influence in the network and how it can interact with other nodes (184).

Finally, NC is a quantitative measure that calculates the average connectivity of a node to the other nodes in the network. It indicates how the node impacts in the network dynamics (187).



## 9.2 WGCNA

### 9.2.1 Setup

```{r}
WGCNA_list <- list()
for (Dataset in c(names(pslist)[!grepl("WF", names(pslist))][grepl("ps_GC|ps_OE", names(pslist)[!grepl("WF", names(pslist))])], "ps_WF")) {
  
  require(WGCNA)
  require(plyr)
  require(dplyr)
  require(ggrepel) 
  require(cowplot)
  require(phyloseq)
  
  Datasetname <- sub("ps_", "", Dataset)
  
  ps <- pslist[[Dataset]]
  psraw <-pslistraw[[Dataset]]
  
  WGCNA_list_length <- length(WGCNA_list)
  
  Analysis   <- "WGCNA"
  prefix <- "SSU-"

  if (Datasetname %in% c("OE", "GC")) {
  
    traitData <- c(
  "HSI", "SSI", "GSI", "FCF", "FillLevel", "Age", "Length", 
  "NH4", "NO2", "NO3", "O2", "PO4", "TOC", "Temp",  "SPM", "Salinity"
  
  ) } else if (Datasetname  %in% c("WF")) {
  
    traitData <- c(
  "NH4", "NO2", "NO3", "O2", "PO4", "TOC", "Temp",  "SPM", "Salinity"
  ) }
  
  omics_data0 <- as.data.frame(otu_table( microbiome::transform(ps, "clr"))) #%>% t()
  
  WGCNA_list[[Datasetname]]                  <- list()
  WGCNA_list[[Datasetname]][["plots"]]       <- list()
  WGCNA_list[[Datasetname]][["ps"]]          <- pslist[[Dataset]]
  WGCNA_list[[Datasetname]][["psraw"]]       <- pslistraw[[Dataset]]
  WGCNA_list[[Datasetname]][["omics_data0"]] <- omics_data0
  WGCNA_list[[Datasetname]][["traitData"]]   <- traitData 
}

```

### 9.2.2  Pre-filtering & Transormation

Some comments on normalization: 
- Normalization: 
Strand et al., 2021
4.2.1. Data preprocessing
Transcript expression counts were summed for each gene.
Expression values were normalized across samples using the
Trimmed mean of M values (TMM)-method [33], and log2-
transformed. Genes with expression levels below 1.0 in all samples
and/or with a standard deviation less than 0.15 were removed
before network inference. This reduced the number of genes from
48,057 to 37,408.
We retained OTUs that contribute at least 0.005% of the total
microbial abundance. This reduced the number of OTUs from
1152 to 296 and the number of zeros in the abundance table by
50%. OTU abundances was normalized using the Cumulative Sum
Scaling (CSS) method from the Bioconductor package metagenome-
Seq, which by default log2-transforms the data.

Swift et al. 2021: 
Cumulative-Sum Score (CSS) uses robust statistics to provide an alternative to TSS that is less influenced by preferentially
sampled taxa. Its normalization scaling factor is defined as the cumulative sum of the observed counts up to a
threshold which is determined using a heuristic that minimizes the influence of the preferentially sampled taxa. The
idea is that CSS scales each sample using only the part of the counts distribution that is relatively invariant (H. Lin &Peddada, 2020a; Weiss et al., 2017). However, the determination of the thresholds could fail due to high count variability (J. Chen et al., 2018). CSS or TSS do not account for sparsity or address compositionality.

The DESeq scaling factor of the observed abundances for each sample is computed as the median of all the
ratios between counts of the sample and the reference. Assuming most taxa are not differentially abundant, the median
of these ratios would provide an estimate of a correction factor for all the read counts. Like most normalizations, TMM
and DESeq rely on the strong assumptions that most taxa are not differentially abundant, and of those differentially
abundant, there is an approximate balanced amount of over-abundance and under-abundance (Calza & Pawitan, 2010;
Dillies et al., 2012; Gloor et al., 2017; Weiss et al., 2017). These may be reasonable assumptions for gene expression data
but may not be valid for microbiome data which tends to be diverse. Also, while TMM and DESEq normalization are
designed for compositional data, they do not address sparsity. In fact, large fractions of zeros and relatively low
sequencing depths can be problematic for both methods and can lead to serious biases (Kumar et al., 2018). As stated
previously, adding pseudo-counts to the original count data will not rectify the problem.

Large scale tool benchmarking by Thorsen et al. has revealed
that most of the commonly used differential (relative) abundance testing methods including edgeR and DESeq are
sensitive to sparsity (Thorsen et al., 2016) and consequently exhibit unacceptably high false positive rates
(Hawinkel et al., 2019). Also, recent investigations by H. Lin and Peddada (2020a, 2020b) indicate poor performance
of these methods for microbiome data. However, based on simulations and analytical derivations, they attribute
the poor performance to the violation of the assumption that most taxa do not change. As a result, the false
discovery rate is inflated, and it increases as the sample size increases. Similar behavior of these methods was also
seen by Weiss et al. (2017). Thus, H. Lin and Peddada (2020a) do not advocate the use of edgeR and DESeq for the
analysis of microbiome data.

following http://mixomics.org/mixmc/mixmc-preprocessing/
Arumugam et al., (2011)

```{r,  message=FALSE,warning=FALSE}
for (Datasetname  in names(WGCNA_list)) {
  
  psraw <- WGCNA_list[[Datasetname]]$psraw
  
  library(phyloseq)
  library(tidyverse)
  require(DESeq2)
  require(SummarizedExperiment)

  low.count.removal <- function(
                        data, # OTU count df of size n (sample) x p (OTU)
                        percent=0.005 # cutoff chosen
                        ) {
    keep.otu = which(colSums(data)*100/(sum(colSums(data))) > percent)
    data.filter = data[,keep.otu]
    return(list(data.filter = data.filter, keep.otu = keep.otu))}

  #######################################################
  #Plot consequence of filtering from Strand et al, 2021#
  #######################################################
  frac_zero <- c()
  all_sum   <- c()
  num_otu   <- c()
  seqp <- seq(0,0.1,0.0001)
  for(i in seqp){
  result.filter = low.count.removal(otu_table(psraw), percent=i)
  length(result.filter$keep.otu)
  otu.f = result.filter$data.filter
  frac_zero <- c(frac_zero, sum(otu.f == 00)/ (ncol(otu.f)*nrow(otu.f)))
  all_sum <- c(all_sum, sum(otu.f))
  num_otu <- c(num_otu, ncol(otu.f))
  }
  names(frac_zero) <- seqp
  names(all_sum) <- seqp

  applied_filter <- 0.005
  # Get all_sum and num_otu to a fraction of the total
  mas <- max(all_sum)
  mno <- max(num_otu)

  all_sum %>% (function(x){x/max(x)}) -> all_sum
  num_otu %>% (function(x){x/max(x)}) -> num_otu
  data.frame(filter = seqp, 
           Percent.zeros   = frac_zero*100, 
           Total.abundance = all_sum*100, 
           Number.of.OTUs  = num_otu*100) %>% 
  tidyr::gather(key = "Type", value = "percent.of.total", -filter) %>%
  ggplot() + 
  geom_line(mapping = aes(x = filter, y = percent.of.total, col = Type)) +
  geom_vline(xintercept = applied_filter, alpha = 0.5, color = "red", linetype="dashed")+
  ylab("Percent of total") +
  xlab(paste("Filter at", applied_filter)) +
  theme(legend.title = element_blank()) -> FilterZerosPlot

  WGCNA_list[[Datasetname]][["plots"]][["FilterZerosPlot"]] <- FilterZerosPlot
  
  plot(FilterZerosPlot)


  ##############
  #Plot clr PCR#
  ##############
  TSE <-mia::makeTreeSummarizedExperimentFromPhyloseq(microbiome::transform(WGCNA_list[[Datasetname]]$ps, "clr"))
  
  tryCatch({
  SSUclrPCAPlot<-pcaplotRK3(TSE,intgroup = c("Reps"), pcX = 1, pcY = 2, title="",ellipse = TRUE,     ellipse.prob = 0.5) + 
  scale_fill_manual(values=col.Palette$col.Palette.Reps) + #col.Palette.SeqCenter #col.Palette.Cruises
  scale_color_manual(values=col.Palette$col.Palette.Reps) + atheme +
  theme_minimal() + atheme + theme(axis.title.x = element_blank()) +
  theme(
        panel.grid.major = element_line(colour = "grey50"), 
        panel.grid.minor = element_line(colour = "grey50"))
  prow <- cowplot::plot_grid(SSUclrPCAPlot, labels = c(""), ncol = 1)
  title <- ggdraw() + draw_label_themeRKwhite(paste(Datasetname), element = "plot.title",x = 0.05, hjust = 0,    vjust = 1)
  subtitle <- ggdraw() + draw_label_themeRKwhite(paste("clr-PCA", "with", 
  length(rownames(TSE)),"bacterial species",sep = " "), element = "plot.subtitle",x = 0.05, hjust = 0,   
  vjust = 1)
  SSUclrPCAPlot<- plot_grid(title, subtitle, prow, ncol = 1, rel_heights = c(0, 0.05, 0.989))
  ggsave(SSUclrPCAPlot, filename = paste(paste(save_name, "SSU", "Filter-clrPCA", Datasetname, sep="_"),".png", sep=""), path = pathPlots , device='png', dpi=300, width = 7,
  height = 7)

  plot(SSUclrPCAPlot)
  
  }, error=function(e){cat("ERROR :",conditionMessage(e), "\n")})
  
  WGCNA_list[[Datasetname]][["plots"]][["SSUclrPCAPlot"]] <- SSUclrPCAPlot
  
}

```

#### 9.2.1 Data Input 

```{r,  message=FALSE,warning=FALSE, fig.width=12, fig.height=10}

for (Datasetname  in names(WGCNA_list)) {
  
  omics_data0 <- WGCNA_list[[Datasetname]]$omics_data0
  ps <- WGCNA_list[[Datasetname]]$ps
  traitData  <- WGCNA_list[[Datasetname]][["traitData"]]  
  
  #Import Data
  library(WGCNA)
  # The following setting is important, do not omit.
  options(stringsAsFactors = FALSE);

  dim(omics_data0 %>% paste(c("Samples", "OTUs")))
  gsg = goodSamplesGenes(omics_data0, verbose = 3);
  gsg$allOK

  #Check Data Quality
  if (!gsg$allOK)
  {
  # Optionally, print the gene and sample names that were removed:
  if (sum(!gsg$goodGenes)>0) 
     printFlush(paste("Removing genes:", paste(names(omics_data0)[!gsg$goodGenes], collapse = ", ")));
  if (sum(!gsg$goodSamples)>0) 
     printFlush(paste("Removing samples:", paste(rownames(omics_data0)[!gsg$goodSamples], collapse = ", ")));
  # Remove the offending genes and samples from the data:
  omics_data0 = omics_data0[gsg$goodSamples, gsg$goodGenes]
  }

  #Plot Euclidean Sample Distance
  sampleTree = hclust(dist(omics_data0), method = "average");
  # Plot the sample tree: Open a graphic output window of size 12 by 9 inches
  # The user should change the dimensions if the window is too large or too small.
  #pdf(file = "Plots/sampleClustering.pdf", width = 12, height = 9);
  par(cex = 0.6);
  par(mar = c(0,4,2,0))
  plot(sampleTree, main = "Sample clustering to detect outliers", sub="", xlab="", cex.lab = 1.5, 
     cex.axis = 1.5, cex.main = 2) 


  # Plot a line to show the cut
  abline(h = 100, col = "red");
  # Determine cluster under the line
  clust = cutreeStatic(sampleTree, cutHeight = 100, minSize = 10)
  table(clust)
  # clust 1 contains the samples we want to keep.

  #in Case we would exclude outliers from the tree: 
  #keepSamples = (clust==1)
  #omics_data = omics_data0[keepSamples, ]

  recordPlot() -> SampleClusteringTreePlot
  WGCNA_list[[Datasetname]][["plots"]][["SampleClusteringTreePlot"]] <- SampleClusteringTreePlot
  
  
  
  ###############################
  #Subset samples when excluding#
  ###############################
  
  #Keep all samples
  omics_data <- omics_data0
  nGenes = ncol(omics_data)
  nSamples = nrow(omics_data)

  #Clean TraitData
  datTraits <-SAMDF16S %>% 
    filter(SampleID %in% rownames(omics_data))
  rownames(datTraits) <- datTraits$SampleID
    
  datTraits<- datTraits[,traitData]
  print("NAs in TraitData")
  
  print(table(is.na(datTraits)))
  
  print((datTraits[!complete.cases(datTraits), ]))
  
  datTraits  <- datTraits[complete.cases(datTraits), ]

  dim(datTraits)

  omics_data <- omics_data[rownames(omics_data) %in% rownames(datTraits),]
  dim(omics_data)

  ps <- prune_samples(sample_names(ps)[sample_names(ps) %in% rownames(omics_data)], ps) 
  
  print(Datasetname)
  print(ps)
  
  collectGarbage()

  
  # Re-cluster samples
  sampleTree2 = hclust(dist(omics_data), method = "average")
  # Convert traits to a color representation: white means low, red means high, grey means missing entry
  traitColors = numbers2colors(datTraits, signed = FALSE)
  # Plot the sample dendrogram and the colors underneath.
  plotDendroAndColors(sampleTree2, traitColors,
                    groupLabels = names(datTraits), 
                    main = "Sample dendrogram and trait heatmap")
  recordPlot() -> SampleClusteringTreeTraitsPlot
  WGCNA_list[[Datasetname]][["plots"]][["SampleClusteringTreeTraitsPlot"]] <- SampleClusteringTreeTraitsPlot

  WGCNA_list[[Datasetname]][["omics_data"]] <- omics_data
  WGCNA_list[[Datasetname]][["datTraits"]] <- datTraits
  WGCNA_list[[Datasetname]]$ps <-  ps

}


saveRDS(WGCNA_list, file = paste0(file.path(path_Output_16S, paste(paste(save_name, "WGCNA_list",  Date, sep="_"), ".rds", sep=""))))


##############
#Summary Plot#
##############
for (Datasetname  in names(WGCNA_list)) {
  plots <- WGCNA_list[[Datasetname]][["plots"]]
  
  cowplot::plot_grid(plots$FilterZerosPlot , plots$SSUclrPCAPlot, labels = c("A", "B"), ncol = 2, 
                     rel_heights = c(1,1)) -> part_1
  cowplot::plot_grid(part_1 , plots$SampleClusteringTreeTraitsPlot, labels = c("", "C"), ncol = 1) -> part_2
  ggsave(part_2, filename = paste(paste(save_name, "SSU_DataInputPlot", Datasetname, Date, sep="_"),".png", sep=""), path = pathPlots , device='png', dpi=300, width = 10,
  height = 12)
}

```

#### 9.2.2 Network construction

Rosales et al., 2023
Network analysis
To identify ASVs that co-associate in AH, DU, and DL samples, CLR-transformed counts were used for weighted correlation network analysis (WGCNA) with the WGCNA 1.70-3R package [76]. The network was constructed 
unsigned with the following parameters: 
power = 3, 
minimum module size = 12, 
deep split = 2, and 
merged cut height = 0.25. The eigenvalues were correlated to AH, DU, and DL using Pearson correlation with the R function cor. The highest correlation in each disease state was then selected for network construction using the R package SpiecEasi 1.0.5 [77]. The network was then constructed as previously reported [11]. Briefly, the Stability Approach to Regularization Selection (StARS) [77] model was chosen along with the method Meinshausen–Bühlmann’s neighborhood selection [78]. For StARS, 100 subsamples were used with a variability threshold of 10−3. The centrality (node importance) was evaluated [79] using the functions centrality_degree (neighbors = the number of adjacent edges or neighbors) and centrality_edge_betweenness (centrality = the number of shortest paths going through an edge) [80]. The package influenceR 0.1.0. [81] selected important ASVs in each network and assigned the top “key players” [38], which were labeled with their respective orders.

Jameson et al., 2023
Co-occurrence patterns between taxa with putative roles in N2O production and the rest of the microbial community ASVs were explored using proportionality analysis within the propr package52. ASV tables were trimmed to select taxa that occurred ≥10 times in at least 10% of samples prior to network-level analyses to improve interpretability and minimize the risk of spurious correlations. Pairwise interactions between individual taxa with rho values greater than 0.60 were plotted using Cytoscape v3.9.0 and network topological indices were calculated using the NetworkAnalyzer tool114. Relationships between microbial community structure and rate processes were then assessed using weighted gene correlational network analysis (WGCNA) performed with the WGCNA package115. 
The signed adjacency measure was first calculated for each pair of features (ASVs) by raising the absolute value of their pairwise correlation coefficients to a soft-thresholding power of 8 to maximize the scale-free topology fit. Hierarchical clustering of taxa into discrete subnetworks was completed using a 
minimum module size threshold of 20 and a 
dissimilarity threshold of 0.3. 
Pearson correlation coefficients and corresponding p-values are reported for correlations between sample traits, subnetwork eigengenes, and individual ASVs (Supplementary Data 1). Subnetwork membership and intranetwork connectivity measures are also reported for each ASV and were used in further analyses to assess broad relationships between ASV connectivity and importance with respect to N2O production rates.

Mach et al., 2021
To confirm the results of the DE analysis, the weighted gene co-expression network analysis (WGCNA) method was also run on the “E1” matrix using the WGCNA R package (version 1.69) (Langfelder and Horvath, 2008). The parameters for the analysis were set as follows: 
“corFnc” = bicor, 
“type” = signed hybrid, 
“beta” = 10, 
“deepSplit” = 4, 
“minClusterSize” = 30, 
“cutHeight” = 0.1.
The eigengenes corresponding to each identified module were correlated individually to all the 1H NMR and biochemical assay metabolites, i.e., a set of 56 different molecules (see next paragraphs). A module was then considered positively or negatively associated to this set of molecules if the Pearson r correlation values were ≥ |0.65| for at least 5 molecules and if all the corresponding p-values were ≤ 1e−05. The positively and the negatively correlated modules defined in this way were merged to obtain a single gene list, which was subsequently compared to the differentially expressed genes (DEGs) list using a Venn diagram.

Strand et al, 2021
4.2.2. Network inference
For network inference, we used the Weighted Gene Co-expression Network Analysis (WGCNA) R package [24] and the function 
blockwiseModules with the bicor correlation measure and parameters 
maxBlockSize = 10000, 
networkType = “signed”, 
TOMType = “signed”, 
corType = “bicor”, 
maxPOutliers = 0.05, 
replaceMissingAdjacencies = TRUE, 
pamStage = F, 
deepSplit = 4, 
minModuleSize = 2, 
minKMEtoStay = 0.5, 
minCoreKME = 0.5, 
minCoreKMESize = 2, 
reassignThreshold = 0 
mergeCutHeight = 0.4/0.5 (for microbiota/host respectively).

Our analysis relies heavily on network modules, and hence the parameters related to module detection and trimming influence the results. Briefly, deepSplit controls the sensitivity of the module detection approach by hierarchical clustering, with a value of 1 being the least sensitive and 4 being the most sensitive. minModuleSize controls the minimum size of modules in the clustering step. Nodes with a correlation to the module eigennode (KME) lower than minKMEtoStay are trimmed from the module, and the module is deleted if it does not have a core of at least minCoreKMESize nodes (with core nodes being defined as having a KME greater than minCoreKME). Finally, different modules with eigennodes that correlate above the 1 – mergeCutHeight threshold are merged. Note that the final modules can be smaller than minModuleSize due to trimming (but not smaller than minCoreKMESize), and that they can include nodes with a KME lower than minKMEtoStay due to module merging. Our parameters were set to detect highly correlated and potentially small modules initially, thus not missing interesting profiles displayed by few genes/OTUs, and then to apply an aggressive merging threshold to avoid dealing with highly redundant modules in downstream analysis.

##### 9.2.2.1 Pick Soft Threshold

```{r,  message=FALSE,warning=FALSE, fig.width=12, fig.height=10}
for (Datasetname  in names(WGCNA_list)) {
  
  library(WGCNA)
  # The following setting is important, do not omit.
  options(stringsAsFactors = FALSE)
  
  omics_data <- WGCNA_list[[Datasetname]]$omics_data
  datTraits  <- WGCNA_list[[Datasetname]]$datTraits
  #Import Data

  # Choose a set of soft-thresholding powers
  powers = c(c(1:10), seq(from = 12, to=20, by=2))
  # Call the network topology analysis function
  allowWGCNAThreads() #needed otherwise would not work! https://www.biostars.org/p/122349/
  sft = pickSoftThreshold(omics_data, powerVector = powers, verbose = 5)
  # Plot the results:
  # Find the soft thresholding power beta to which co-expression similarity is raised to calculate adjacency.
  # based on the criterion of approximate scale-free topology.
  idx <- min(which((-sign(sft$fitIndices[,3])*sft$fitIndices[,2]) > 0.90))
  if(is.infinite(idx)){
    idx <- min(which((-sign(sft$fitIndices[,3])*sft$fitIndices[,2]) > 0.80))
    if(!is.infinite(idx)){
      st <- sft$fitIndices[idx,1]
    } else{
      idx <- which.max(-sign(sft$fitIndices[,3])*sft$fitIndices[,2])
      st <- sft$fitIndices[idx,1]
    }
  } else{st <- sft$fitIndices[idx,1]}
  # Plot Scale independence measure and Mean connectivity measure

  # Scale-free topology fit index as a function of the soft-thresholding power
  data.frame(Indices = sft$fitIndices[,1],
           sfApprox = -sign(sft$fitIndices[,3])*sft$fitIndices[,2]) %>% 
  ggplot() + 
    geom_hline(yintercept = 0.9, color = "red", alpha = 0.6) + # corresponds to R^2 cut-off of 0.9
    geom_hline(yintercept = 0.8, color = "red", alpha = 0.2) + # corresponds to R^2 cut-off of 0.8
    geom_line(aes(x = Indices, y = sfApprox), color = "red", alpha = 0.1, size = 2.5) +
    geom_text(mapping = aes(x = Indices, y = sfApprox, label = Indices), color = "red", size = 4) +
    ggtitle("Scale independence") +
    xlab("Soft Threshold (power)") +
    ylab("SF Model Fit,signed R^2") +
    xlim(1,20) +
    ylim(-1,1) +
    geom_segment(aes(x = st, y = 0.25, xend = st, yend = sfApprox[idx]-0.05), 
               arrow = arrow(length = unit(0.2,"cm")), 
               size = 0.5)-> scale_independence_plot 
  
  
  WGCNA_list[[Datasetname]][["plots"]][["scale_independence_plot"]] <-scale_independence_plot 
  
  # Mean connectivity as a function of the soft-thresholding power

  data.frame(Indices = sft$fitIndices[,1],
           meanApprox = sft$fitIndices[,5]) %>% 
    ggplot() + 
    geom_line(aes(x = Indices, y = meanApprox), color = "red", alpha = 0.1, size = 2.5) +
    geom_text(mapping = aes(x = Indices, y = meanApprox, label = Indices), color = "red", size = 4) +
    xlab("Soft Threshold (power)") +
    ylab("Mean Connectivity") +
    geom_segment(aes(x = st-0.4, 
                   y = sft$fitIndices$mean.k.[idx], 
                   xend = 0, 
                   yend = sft$fitIndices$mean.k.[idx]),
               arrow = arrow(length = unit(0.2,"cm")), 
               size = 0.4) +
    ggtitle(paste0("Mean connectivity: ", 
                 round(sft$fitIndices$mean.k.[idx],2))) -> mean_connectivity_plot

  cowplot::plot_grid(scale_independence_plot, mean_connectivity_plot, ncol = 2, align = "h", 
                     labels = c("A", "B")) -> si_mc_plot
  WGCNA_list[[Datasetname]][["plots"]][["si_mc_plot"]] <- si_mc_plot

  ggsave(si_mc_plot, filename = paste(paste(save_name, "soft_thresholding_power" , Datasetname,
        sep="_"),".png", sep=""), path = pathPlots, device='png', dpi=300, width = 8, height = 6)
  si_mc_plot

  softPower = st; print(paste("SoftPower chosen to", softPower))
  
  WGCNA_list[[Datasetname]][["softPower"]] <- softPower
}
  
```

##### 9.2.2.2 blockwiseModules

deepSplit integer value between 0 and 4. Provides a simplified control over how sensitive
module detection should be to module splitting, with 0 least and 4 most sensitive.
See cutreeDynamic for more details.

https://support.bioconductor.org/p/104602/
mergeCutHeight
I am not aware of a principle from which one could derive an "appropriate" value, but in practice, on data sets with 50-100 samples, using 0.15 to 0.2 has worked fairly well. For fewer samples a larger value (0.25 to 0.3) may be warranted. If you want larger modules, increase the value; if you want smaller modules at the risk of having redundant modules (modules with very similar functional annotation and very similar fuzzy module membership), you can decrease the value to say 0.10, maybe even lower if you have lots of samples (hundreds or more).
https://support.bioconductor.org/p/101579/
reassignThreshold
First things first: grey is not really a module, it is a label for unassigned genes, and the eigengene and kME for the grey "module" are more or less meaningless. In other words, ignore the eigengene and kME values for the grey "module".

WGCNA assigns module labels using dynamic tree cut (look up dynmaicTreeCut) of hierarchical clustering tree that is based on the Toplogical Overlap Measure (TOM). TOM results in similar but not quite the same similarity as correlation, hence for some genes the assigned module may differ from the module with highest kME. Module merging can also play a part here.

Practically speaking, genes will have a high kME to their assigned module. When assigned module and module of highest kME differ, the gene probably has high kME to both and can be considered intermediate between the two modules.

I don't really recommend this, but if you absolutely want all genes to be assigned to the module of highest kME, try using argument reassignThreshold=1 to blockwiseModules. This will re-assign all genes to the module of their highest kME after the initial modules have been identified. Note though that the reassignment is not iterated with module eigengene re-calculation.

In all, I don't worry about the module assignment vs. max. kME differences in my own analyses, and I recommend not worrying it about it to others as well.

https://cran.r-project.org/web/packages/WGCNA/WGCNA.pdf
maxPOutliers
maxPOutliers specifies the maximum percentile of data that can be considered outliers on
either side of the median separately. For each side of the median, if higher
percentile than maxPOutliers is considered an outlier by the weight function
based on 9*mad(x), the width of the weight function is increased such that the
percentile of outliers on that side of the median equals maxPOutliers. Using
maxPOutliers=1 will effectively disable all weight function broadening; using
maxPOutliers=0 will give results that are quite similar (but not equal to) Pearson correlation.

minCoreKMESize
a number between 0 and 1. If a detected module does not have at least minModuleKMESize genes with eigengene connectivity at least minCoreKME, the module is disbanded (its genes are unlabeled and returned to the pool of genes waiting for mofule detection).

minKMEtoStay	
genes whose eigengene connectivity to their module eigengene is lower than minKMEtoStay are removed from the module.

```{r,  message=FALSE,warning=FALSE}

for (Datasetname  in names(WGCNA_list)) {
  
  library(WGCNA)
  # The following setting is important, do not omit.
  options(stringsAsFactors = FALSE)
  
  omics_data <- WGCNA_list[[Datasetname]]$omics_data
  datTraits  <- WGCNA_list[[Datasetname]]$datTraits
  softPower  <- WGCNA_list[[Datasetname]]$softPower
  
  ##################
  #blockwiseModules#
  ##################
  print(Datasetname)
  print(paste("SoftPower chosen to", softPower))
  
  if (Datasetname %in% c("OE", "GC")) {
  maxPOutliers_value    <- 0.05
  mergeCutHeight_value  <- 0.15
  deepSplit_value       <- 3
  } else if (Datasetname  %in% c("WF")) {
  maxPOutliers_value    <- 0.1
  mergeCutHeight_value  <- 0.3
  deepSplit_value       <- 2
  }
  
  network = blockwiseModules(omics_data, 
                       power = st,
                       networkType = "signed", 
                       TOMType = "signed",
                       corType = "bicor",
                       maxPOutliers = maxPOutliers_value,
                       minModuleSize = 3, 
                       #reassignThreshold = 0, 
                       minCoreKME = 0.5,      # Default 0.5
                       #minCoreKMESize = 3,   # Default minModuleSize/3,
                       minKMEtoStay = 0.5,    # Default 0.3 High intramodular correlation
                       deepSplit = deepSplit_value,
                       mergeCutHeight = mergeCutHeight_value,
                       numericLabels = TRUE, 
                       pamRespectsDendro = FALSE,
                       saveTOMs = TRUE,
                       saveTOMFileBase = paste(Species,Tissue,Type,Season,Datasetname, "TOM", sep="_"), 
                       verbose = 3)
  
  
  

#Strand et., 2021
# network <- blockwiseModules(omics_data,
#                           power = st,
#                           networkType = "signed",
#                           TOMType = "signed",
#                           corType = "bicor",
#                           maxPOutliers = 0.05,
#                           deepSplit = 4, # Default 2
#                           minModuleSize = 2, # 30
#                           minCoreKME = 0.5,      # Default 0.5
#                           minCoreKMESize = 2,    # Default minModuleSize/3,
#                           minKMEtoStay = 0.5,    # Default 0.3
#                           reassignThreshold = 0, # Default 1e-6
#                           mergeCutHeight = 0.4,  # Default 0.15
#                           pamStage = FALSE,
#                           pamRespectsDendro = TRUE,
#                           replaceMissingAdjacencies = TRUE,
#                           numericLabels = TRUE,
#                           saveTOMs = TRUE,
#                           saveTOMFileBase = paste(Species,Tissue,Type,Season, "TOM", sep="_"),
#                           verbose = 3)


  moduleLabels <- network$colors
  moduleColors <- labels2colors(network$colors)
  MEs <- network$MEs
  geneTree <- network$dendrograms[[1]]
  
  WGCNA_list[[Datasetname]][["MEs"]] <- MEs
  WGCNA_list[[Datasetname]][["moduleLabels"]] <- moduleLabels
  WGCNA_list[[Datasetname]][["moduleColors"]] <- moduleColors
  WGCNA_list[[Datasetname]][["geneTree"]] <- geneTree
  WGCNA_list[[Datasetname]][["network"]] <- network #we also save the whole network as its small from 16S

}

```

##### 9.2.2.3 Module & Network Visualization

```{r,  message=FALSE,warning=FALSE, fig.width=15, fig.height=15}
for (Datasetname  in names(WGCNA_list)) {
  
  library(WGCNA)
  # The following setting is important, do not omit.
  options(stringsAsFactors = FALSE)
  
  omics_data    <- WGCNA_list[[Datasetname]]$omics_data
  datTraits     <- WGCNA_list[[Datasetname]]$datTraits
  moduleLabels  <- WGCNA_list[[Datasetname]]$moduleLabels
  moduleColors  <- WGCNA_list[[Datasetname]]$moduleColors
  MEs           <- WGCNA_list[[Datasetname]]$MEs
  network       <- WGCNA_list[[Datasetname]]$network
  ps            <- WGCNA_list[[Datasetname]]$ps
  
  #####################
  #plotDendroAndColors#
  #####################

  ##############################
  #Number of ASV in each module#
  ##############################
  as.data.frame(table(moduleLabels)) %>% 
  dplyr::rename(Module = moduleLabels, Size = Freq) %>%
  dplyr::mutate(Module_color = labels2colors(as.numeric(as.character(Module)))) -> module_size
  
  module_size %>% 
    ggplot(aes(x = Module, y = Size, fill = Module)) +
    geom_col(color =  "#000000") +
    ggtitle("Number of genes in each module") +
    theme(legend.position = "none") + 
    scale_fill_manual(values = setNames(module_size$Module_color,module_size$Module)) +
    geom_text(aes(label = Size),vjust = 0.5, hjust = -0.18, size = 3.5) +
    ylim(0, max(module_size$Size)*1.1) +
    theme(plot.margin = margin(2, 2, 2, 2, "pt")) +
    coord_flip() -> ASVModuleSizePlot
  ASVModuleSizePlot
  
  ggsave(ASVModuleSizePlot, filename = paste(paste(save_name, "ASVModulePlot" , Datasetname, sep="_"),
          ".png", sep=""), path = pathPlots, device='png', dpi=300, width = 8, height = 6)

  WGCNA_list[[Datasetname]][["plots"]][["ASVModuleSizePlot"]] <-ASVModuleSizePlot
  
  
  #######################################
  #Module-Eigenegene-Correlation-Heatmap#
  #######################################
  MEs_R <- bicor(MEs, MEs, maxPOutliers = 0.05)
  idx.r <- which(rownames(MEs_R) == "ME0")
  idx.c <- which(colnames(MEs_R) == "ME0")
  MEs_R_noME0 <- MEs_R[-idx.r, -idx.c]

  MEs_R_noME0[upper.tri(MEs_R_noME0)] %>% 
    as.data.frame() %>% 
    dplyr::rename("correlation" = ".") %>% 
    ggplot(aes(x=correlation)) + 
    geom_histogram(bins = 20) +
    #geom_density() + 
    xlim(-1, 1) +
    ggtitle(paste0(prefix,"ME correlation\n w/o ",prefix ,"ME0")) -> MEs_R_density

  WGCNA_list[[Datasetname]][["plots"]][["MEs_R_density"]] <-MEs_R_density
  

  pheatmap::pheatmap(MEs_R_noME0, color = colorRampPalette(c("Blue", "White", "Red"))(100),
                   silent = T, 
                   breaks = seq(-1,1,length.out = 101),
                   treeheight_row = 5, 
                   treeheight_col = 5,
                   main = paste0(prefix,"ME correlation heatmap w/o ",prefix ,"ME0"),
                   labels_row = paste0(prefix, rownames(MEs_R)),
                   labels_col = paste0(prefix, colnames(MEs_R))) -> MEs_R_Corr

  ggsave(MEs_R_Corr, filename = paste(paste(save_name, "MEs_R_Corr" , Datasetname, sep="_"),".png", sep=""),
         path = pathPlots, device='png', dpi=300, width = 8, height = 6)
  WGCNA_list[[Datasetname]][["plots"]][["MEs_R_Corr"]] <-MEs_R_Corr

  MEs_R_Corr
  
  cowplot::plot_grid(MEs_R_density, MEs_R_Corr$gtable, labels = c("D", "E"), rel_widths = c(0.6, 1)) ->
    density_eigen
  density_eigen


  #######################
  #Network-Visualization#
  #######################
  # 5 Visualization of networks within R
  # 5.a Visualizing the gene network
  # One way to visualize a weighted network is to plot its heatmap, Fig. 1. Each row and column of the heatmap
  # correspond to a single gene. The heatmap can depict adjacencies or topological overlaps, with light colors   denoting
  # low adjacency (overlap) and darker colors higher adjacency (overlap). In addition, the gene dendrograms   and module
  # colors are plotted along the top and left side of the heatmap. The package provides a convenient function to create
  # such network plots; Fig. 1 was created using the following code. This code can be executed only if the network
  # was calculated using a single-block approach (that is, using the 1-step automatic or the step-by-step tutorials). If
  # the networks were calculated using the block-wise approach, the user will need to modify this code to perform the
  # visualization in each block separately. The modi cation is simple and we leave it as an exercise for the interested
  # reader.
  # Calculate topological overlap anew: this could be done more efficiently by saving the TOM
  # calculated during module detection, but let us do it again here.

  # dissTOM = 1-TOMsimilarityFromExpr(omics_data, power = softPower);
  # # Transform dissTOM with a power to make moderately strong connections more visible in the heatmap
  # plotTOM = dissTOM^10;
  # # Set diagonal to NA for a nicer plot
  # diag(plotTOM) = NA;
  # # Call the plot function
  # TOMplot(plotTOM, geneTree, moduleColors, main = "Network heatmap plot, all genes")

  #############################
  # Correlation within modules# from Strand et al, 2021
  #############################
  corr_within_module <- function(omics_data, network, module_x = 1){
  idx.omics_data <- which(network$colors == module_x)
  idx.me <- which(colnames(network$MEs) == paste0("ME",module_x))
  kME_x <- bicor(omics_data[,idx.omics_data], network$MEs[,idx.me], maxPOutliers = 0.05)
  kME_x}
  ggplot.list <- list()
  for(m in colnames(network$MEs)){
    h <- as.numeric(sub("ME","", m))
    data.frame(x = suppressWarnings(corr_within_module(omics_data = omics_data, network = network, 
                                                       module_x = h))) %>% 
    ggplot() + 
    geom_histogram(aes(x), fill = labels2colors(h), color = "black", alpha = 0.5, bins = 20) + 
    xlim(-1, 1) +
    xlab("ASV correlation")+
    ggtitle(paste0(prefix,m)) -> da_plot
  ggplot.list[[m]] <- da_plot}
  ggplot.list <- ggplot.list[ggplot.list %>% names() %>% sub("ME", "", .) %>% as.numeric() %>% order()]

  cowplot::plot_grid(plotlist = ggplot.list, ncol = 3) -> density_all_plot
  density_all_plot

  ggsave(density_all_plot, filename = paste(paste(save_name, "WithinModuleCorrelation" ,Datasetname, sep="_"),".png", sep=""), path = pathPlots, device='png', dpi=300, width = 8, height = 12)

WGCNA_list[[Datasetname]][["plots"]][["density_all_plot"]] <-density_all_plot

}

##############
#Summary Plot#
##############
for (Datasetname  in names(WGCNA_list)) {
  
  plots <- WGCNA_list[[Datasetname]][["plots"]]

  cowplot::plot_grid(plots$si_mc_plot, plots$ASVModuleSizePlot, labels = c("","C"), ncol = 2) -> part_1

  cowplot::plot_grid(part_1, plots$density_eigen, labels = c("", ""), ncol = 1, rel_widths = c(1,0.5)) -> part_2

  cowplot::plot_grid(part_2, plots$density_all_plot, labels = c("", "F"), rel_widths = c(1,0.1), ncol = 1) -> part_3

  ggsave(part_2, filename = paste(paste(save_name, "SSU_Network", Datasetname, Date, sep="_"),".png", sep=""),
         path = pathPlots , device='png', dpi=300, width = 12, height = 10)
  
  plot(part_2)
  
}

```


### 9.2.4 Module-Trait-Correlation Heatmap

```{r,  message=FALSE,warning=FALSE, fig.width=12, fig.height=12}
for (Datasetname  in names(WGCNA_list)) {

  omics_data    <- WGCNA_list[[Datasetname]]$omics_data
  datTraits     <- WGCNA_list[[Datasetname]]$datTraits
  moduleLabels  <- WGCNA_list[[Datasetname]]$moduleLabels
  moduleColors  <- WGCNA_list[[Datasetname]]$moduleColors
  MEs           <- WGCNA_list[[Datasetname]]$MEs
  network       <- WGCNA_list[[Datasetname]]$network
  traitData       <- WGCNA_list[[Datasetname]]$traitData
  
  ###################
  #Self made Heatmap#
  ###################
  #https://bioinformaticsworkbook.org/tutorials/wgcna.html#gsc.tab=0
  # Define numbers of genes and samples
  MEs = orderMEs(MEs)
  names(MEs) = names(MEs) %>% gsub("ME","", .)  %>% paste("SSU",., sep="")
  moduleTraitCor = cor(MEs, datTraits, use = "p");
  moduleTraitPvalue = corPvalueStudent(moduleTraitCor, nSamples);
  textMatrix <- paste(signif(moduleTraitCor, 2), "\n(", signif(moduleTraitPvalue, 1), ")", sep = "")
  dim(textMatrix) <- dim(moduleTraitCor)

  # Add treatment names
  MEs$treatment = row.names(MEs)
  mat <- as.data.frame(t(moduleTraitCor))
  mat$traits <- rownames(mat)
  # tidy & plot data
  module_order = names(MEs) 

  mME = mat %>%
  pivot_longer(-traits) %>%
  mutate(#name = gsub("ME", "", name),
    name = factor(name, levels = module_order))

  textMatrixLong <-  as.data.frame(t(signif(moduleTraitCor, 2)))
  textMatrixLong$traits <- rownames(textMatrixLong)
  textMatrixLong = textMatrixLong %>%
    pivot_longer(-traits) %>%
    mutate(
    #name = gsub("ME", "", name),
    name = factor(name, levels = module_order))
  textMatrixLong <- as.data.frame(textMatrixLong)

  textMatrixLong2 <-  as.data.frame(t(signif(moduleTraitPvalue, 1)))
  textMatrixLong2$traits <- rownames(textMatrixLong2)
  textMatrixLong2 = textMatrixLong2%>%
    pivot_longer(-traits) %>%
    mutate(
    name = gsub("ME", "", name),
    name = factor(name, levels = module_order))
  textMatrixLong2 <- as.data.frame(textMatrixLong2)

  ## add gene counts per module
  genesmod<- as.data.frame(moduleLabels)
  genesmod$genes <- rownames(genesmod)
  genesmod$Modules <- paste("SSU",genesmod$moduleLabels, sep="") #labels2colors(genesmod$moduleLabels)
 
  ModCount <- as.data.frame(genesmod %>% 
    dplyr::group_by(Modules) %>% 
    dplyr::summarise(n = n()) )
  ModCount <- ModCount[order(as.numeric(ModCount$n), decreasing = T),]


  HM <- mME %>% ggplot(., aes(x=traits, y=name, fill=value)) +
    geom_tile() +
    scale_fill_gradient2(
      low = "steelblue1",
      high = "red",
      mid = "white",
      midpoint = 0,
      limit = c(-0.7,0.7)) +
  theme(axis.text.x = element_text(angle=90)) +
  labs(title = paste("Module-trait Relationships", Datasetname, sep = " "), y = "Modules", fill="corr") +
  geom_text(aes(label=textMatrixLong$value), position=position_nudge(y=0.2), 
                      size=2.5, colour="grey20") +
  geom_text(aes(label=paste0("(",textMatrixLong2$value,")")), position=position_nudge(y=-0.2), 
                      colour="grey20", size=2.5) +
   theme_minimal() + atheme + theme(axis.title.x = element_blank()) +
      theme( panel.grid.major = element_blank(),panel.grid.minor = element_blank())
      prow <- cowplot::plot_grid(HM, labels = c(""), ncol = 1)
      
  ModuleHeatmap<- plot_grid(prow, ncol = 1, rel_heights = c(0.02, 0.05, 0.98))
      
  ggsave(ModuleHeatmap, filename = paste(paste(save_name, "ModuleHeatmap", Datasetname, Date, sep="_"), 
          ".png", sep=""), path = pathPlots, device='png', dpi=300, width = 8, height = 6)

  WGCNA_list[[Datasetname]][["plots"]][["ModuleHeatmap"]] <- ModuleHeatmap

  
  
 
  mME<- mME%>% mutate(Category = case_when((traits %in% c(
  "NH4", "NO2", "NO3", "O2", "PO4", "TOC", "Temp",  "SPM", "Salinity"
  )) ~ "Abiotics", 
  (traits %in% c(
  "HSI", "SSI", "GSI", "FCF", "Age", "Length", "FillLevel")) ~ "Physiology"))
  
  Order<- c("Abiotics", "Physiology")
 
  HM <- mME %>% ggplot(., aes(x=name, y=factor(traits, levels=traitData), fill=value)) +
  geom_tile() +
    scale_fill_gradientn(
      colours = c("steelblue1", "white", "red"),
      limit = c(-1,1), 
      values = scales::rescale(c(-1, -0.3, 0, 0.3, 1))) +
  
  scale_x_discrete(limits=ModCount$Modules, labels=paste(ModCount$Modules, ": ", ModCount$n)) +
  facet_grid(factor(mME$Category, levels=Order), scales = "free", space = "free") +
  theme(axis.text.x = element_text(angle=90)) +
  labs(title = paste("Module-trait Relationships", Datasetname, sep = " "), y = "Modules", fill="corr") +
  geom_text(aes(label=textMatrixLong$value), position=position_nudge(y=0.2), 
                      size=2.5, colour="grey20") +
  geom_text(aes(label=paste0("(",textMatrixLong2$value,")")), position=position_nudge(y=-0.2), 
                      colour="grey20", size=2.5) +
   theme_minimal() + atheme + theme(axis.title.x = element_blank()) +
      theme( panel.grid.major = element_blank(),panel.grid.minor = element_blank())
  
  ModuleHeatmap2 <- cowplot::plot_grid(HM, labels = c(""), ncol = 1)
      
  ModuleHeatmap2 <- plot_grid(ModuleHeatmap2, ncol = 1, rel_heights = c(0.02, 0.05, 0.98))
      plot(ModuleHeatmap2)
      
  ggsave(ModuleHeatmap2, filename = paste(paste(save_name, "ModuleHeatmap-2", Datasetname, Date, sep="_"),".png",
          sep=""), path = pathPlots, device='png', dpi=300, width = 9, height = 6) 
    
  WGCNA_list[[Datasetname]][["plots"]][["ModuleHeatmap2"]] <- ModuleHeatmap2
  
  ##################
  #Specific Modules#
  ##################
 #  Module <- "darkturquoise"
 #  HM <- mME[mME$name == Module,] %>% ggplot(., aes(x=name, y=factor(traits, levels=traitData), fill=value)) +
 #  geom_tile() +
 #    scale_fill_gradientn(
 #      colours = c("steelblue1", "white", "red"),
 #      limit = c(-1,1), 
 #      values = scales::rescale(c(-1, -0.3, 0, 0.3, 1))) +
 #  # scale_fill_gradient2(
 #  #   low = "steelblue1",
 #  #   high = "red",
 #  #   mid = "white",
 #  #   midpoint = 0,
 #  #   limit = c(-1,1)) 
 #  #facet_grid(factor(mME$Category, levels=Order), scales = "free", space = "free") +
 #  theme(axis.text.x = element_text(angle=90)) +
 #  labs(title = "", y = "Modules", fill="corr") +
 #  geom_text(aes(label=textMatrixLong[textMatrixLong$name == Module,]$value), position=position_nudge(y=0.2), 
 #                      size=3, colour="grey20") +
 #  geom_text(aes(label=paste0("(",textMatrixLong2[textMatrixLong2$name == Module,]$value,")")), position=position_nudge(y=-0.2), 
 #                      colour="grey20", size=3) +
 #   theme_minimal() + atheme + theme(axis.title.x = element_blank()) +
 #      theme( panel.grid.major = element_blank(),panel.grid.minor = element_blank())
 #      prow <- cowplot::plot_grid(HM, labels = c(""), ncol = 1)
 # A<- plot_grid(prow, ncol = 1, rel_heights = c(0.02, 0.05, 0.98))
 #      plot(A)
 #      ggsave(A, filename = paste("WGCNA-ModuleHeatmap", Module, sep="_"), path = pathPlots, 
 #             device='png', dpi=300, width = 2.8,height = 7)

}

```

### 9.2.6 Taxa Cluster-Heatmap

```{r,  message=FALSE,warning=FALSE, fig.width=10, fig.height=10}

for (Datasetname  in names(WGCNA_list)) {
  
  omics_data    <- WGCNA_list[[Datasetname]]$omics_data
  datTraits     <- WGCNA_list[[Datasetname]]$datTraits
  moduleLabels  <- WGCNA_list[[Datasetname]]$moduleLabels
  moduleColors  <- WGCNA_list[[Datasetname]]$moduleColors
  MEs           <- WGCNA_list[[Datasetname]]$MEs
  network       <- WGCNA_list[[Datasetname]]$network
  ps            <- WGCNA_list[[Datasetname]]$ps
  SSUWGCNAlist  <- WGCNA_list[[Datasetname]]$SSUWGCNAlist

    for (MODULE in names(SSUWGCNAlist)) {
      tryCatch({
        
      genes_of_interest <- names(omics_data[moduleLabels == paste(sub("SSU", "", MODULE))])
      print(MODULE)
      #print(head(names(ExpressionSet[moduleLabels == paste(sub("ME", "", MODULE))])))  
      
      FILENAME    <- paste(paste(save_name, "Heatplot", MODULE, Datasetname, sep="_"),".png", sep="")
      
      TITLE       <- draw_label_themeRKwhite(paste(Datasetname, MODULE),
                                    element = "plot.title", x =  0.05, hjust = 0, vjust = 1)
      #For any unknown reason gene names like trnat-ugu_39 get changes by WGCNA to trnat.ugu_39

      rowclusternum  <- 1
      columnclusternum    <- 1

      require(DESeq2)
      require(tidyverse)
      require(ggplot2)

      BacteriaHeatPlotRKnoClust(clr = omics_data, Species = Datasetname, min_count = 10,
                                        genes_of_interest = genes_of_interest, Samples = sample_names(ps), 
                                        SAMDF = sample_data(ps),  TITLE = TITLE, filename= FILENAME,
                                        OutlineColor = "grey20")

    if (MODULE == "ME5") {
      plot(A)
    } #else {
    #print("Plots are saved to the pathPlots")
    #}
      
      }, error=function(e){cat("ERROR :",conditionMessage(e), "\n")})
    }
}


```

#-

## 9.3 Visualization

### 9.3.1 Modules of Interest

```{r,  message=FALSE,warning=FALSE}
ModsOfInterst_list <- list()
for (Datasetname  in names(WGCNA_list)) {
  
  omics_data    <- WGCNA_list[[Datasetname]]$omics_data
  datTraits     <- WGCNA_list[[Datasetname]]$datTraits
  moduleLabels  <- WGCNA_list[[Datasetname]]$moduleLabels
  moduleColors  <- WGCNA_list[[Datasetname]]$moduleColors
  MEs           <- WGCNA_list[[Datasetname]]$MEs
  network       <- WGCNA_list[[Datasetname]]$network
  ps            <- WGCNA_list[[Datasetname]]$ps
  traitData     <- WGCNA_list[[Datasetname]]$traitData

  ModsOfInterst_list[[ paste("ModsOfInterest", Datasetname, sep="_")]] <- list()
  
  ###############################################################################
  #Create Dataframes of significant correlation between RNAModules and TraitData#
  ###############################################################################
  p.value_matr   <- corr.value_matr <- matrix(ncol = ncol(datTraits), 
                                          nrow = ncol(MEs), 
                                          dimnames = list(colnames(MEs), 
                                                          colnames(datTraits )))
      for(ii in 1:ncol(MEs)){
        for(j in 1:ncol(datTraits)){
          cor.res <- cor.test(MEs[,ii], datTraits[,j])
          p.value_matr[ii, j] <- cor.res$p.value
          corr.value_matr[ii, j] <- cor.res$estimate
        }
      }
    
      # Correct for number of tests
      p.value_matr.adjust <- p.adjust(p.value_matr, method = "fdr")
      dim(p.value_matr.adjust) <- dim(p.value_matr)
      dimnames(p.value_matr.adjust) <- list(colnames(MEs), colnames(datTraits))
      
      # Collect all results into a list.
      Traits_corr <- list(p_value =as.data.frame(p.value_matr), 
                            p_value_adj = as.data.frame(p.value_matr.adjust),
                            correlation = as.data.frame(corr.value_matr))
      ModsOfInterst <- list()
        for (iii in names(Traits_corr$correlation)){
          #aa <- length(ModsOfInterst)
          # if (iii %in% c("NONE")) {
          #   A <- Traits_corr$correlation[iii][Traits_corr$correlation[iii] > abs(0.3), , drop=FALSE] 
          #   B <- Traits_corr$p_value_adj[iii][Traits_corr$p_value_adj[iii] < 0.05, , drop = FALSE]
          #   BB <- B[rownames(B) %in% rownames(A), , drop = FALSE]
          #   BBB <- cbind(A[rownames(A) %in% rownames(BB), , drop = FALSE], BB)
          #   names(BBB) <- c("correlation", "p_value_adj")
          # }
          # else {
            A <- Traits_corr$correlation[iii][abs(Traits_corr$correlation[iii]) > 0.3, , drop=FALSE] 
            B <- Traits_corr$p_value_adj[iii][Traits_corr$p_value_adj[iii] < 0.05, , drop = FALSE]
            BB <- B[rownames(B) %in% rownames(A), , drop = FALSE]
            BBB <- cbind(A[rownames(A) %in% rownames(BB), , drop = FALSE], BB)
            names(BBB) <- c("correlation", "p_value_adj")
          # }
          ModsOfInterst[[iii]] <- BBB

          }
    ModsOfInterst <- Filter(function(df) nrow(df) > 0, ModsOfInterst)
    ModsOfInterst_list[[ paste("ModsOfInterest", Datasetname, sep="_")]] <- ModsOfInterst
    WGCNA_list[[Datasetname]][["ModsOfInterst_list"]] <- ModsOfInterst_list 
}


  #############
  #Save as CSV#
  #############
for (Datasetname  in names(WGCNA_list)) {

  data <- WGCNA_list[[Datasetname]]$ModsOfInterst_list[[paste("ModsOfInterest",
                                                                            Datasetname, sep="_")]]
  
  #data.frame(ID = rep(names(data), sapply(data, length)), Obs = unlist(data))
  #data.table::rbindlist(data, idcol="df")
  data <- data  %>% 
  imap_dfr(~ .x %>% 
             mutate(TraitOfInterest = .y))

  
  split_names <- str_split_fixed(rownames(data), "\\.", 2)
  data <- cbind(
    data,
    Module = split_names[, 1])
  rownames(data) <- NULL
  data$MODULE <- sub("ME", "", data$Module)
  data$Mod <- paste(Datasetname, data$MODULE, sep="")
  #data <- data %>% 
  #  arrange(MODULE)
 

  write.csv2(data , file = paste0(file.path(path_Output_16S, 
                paste(paste("SSU_ModulesOfInterst", Datasetname, sep="_"), 
                      "csv", sep="."))))
}


```

### 9.3.2 .csv module ASV & GS

```{r,  Dataframe creation, message=FALSE,warning=FALSE}
for (Datasetname  in names(WGCNA_list)) {
  
  omics_data    <- WGCNA_list[[Datasetname]]$omics_data
  datTraits     <- WGCNA_list[[Datasetname]]$datTraits
  moduleLabels  <- WGCNA_list[[Datasetname]]$moduleLabels
  moduleColors  <- WGCNA_list[[Datasetname]]$moduleColors
  MEs           <- WGCNA_list[[Datasetname]]$MEs
  network       <- WGCNA_list[[Datasetname]]$network
  ps            <- WGCNA_list[[Datasetname]]$ps
  ModsOfInterest <- WGCNA_list[[Datasetname]]$ModsOfInterst_list[[paste("ModsOfInterest",
                                                                            Datasetname, sep="_")]]
  data <-  ModsOfInterest  %>% 
  imap_dfr(~ .x %>% 
             mutate(TraitOfInterest = .y))

  
  split_names <- str_split_fixed(rownames(data), "\\.", 2)
  data <- cbind(
    data,
    Module = split_names[, 1])
  rownames(data) <- NULL
  data$MODULE <- sub("ME", "", data$Module)
  data$Mod <- paste(Datasetname, data$MODULE, sep="")
  #############################################
  #Create Bacterial Counts and Reseq Dataframe#
  #############################################  

  TAX <- as.data.frame(tax_table(ps))
  OTU <- as.data.frame(t(otu_table(ps)))
  REFSEQ <- refseq(ps)
  REFSEQ <- stack(as.character(REFSEQ, use.names=TRUE))
  colnames(REFSEQ)[colnames(REFSEQ) == "ind"] <- "ASV"

  SeasonSums <- ps %>%
    transform_sample_counts(function(x) {x/sum(x)*100}) %>%
    phyloseq::otu_table() %>%
    as.data.frame() %>%
    rownames_to_column(var = "SampleID") %>%
    dplyr::left_join(SAMDF16S, by = c("SampleID" = "SampleID")) %>%
    dplyr::group_by(Season) %>%
    dplyr::summarise(dplyr::across(rownames(tax_table(ps)), mean, na.rm = TRUE)) %>% 
    t() %>%
    as.data.frame() %>%
    `colnames<-`(.[1, ]) %>%
    .[-1, ] %>%
    setNames(paste0("avg_", colnames(.))) %>%
    mutate_all(as.numeric) %>%
    rownames_to_column(var="ASV")

    SSUData  <- TAX %>%  
     rownames_to_column(var = "ASV") %>% 
       left_join( #Add relative ASVmeans 
       data.frame(t(phyloseq::otu_table(ps %>%
        transform_sample_counts(function(x) {x/sum(x)*100})))) %>%
          dplyr::mutate(ASVmeans = rowMeans(.)) %>%
          dplyr::mutate(ASV = rownames(.)) %>% 
          dplyr::select(ASV, ASVmeans)
       ) %>%
    left_join( #Add Sums by Season
        SeasonSums
       ) %>%
    left_join( #Add relative ASV data per sample
        data.frame(t(phyloseq::otu_table(ps %>%
        transform_sample_counts(function(x) {x/sum(x)*100})))) %>%
        rownames_to_column(var = "ASV")
    ) %>%
     left_join(REFSEQ
    ) %>%
      dplyr::arrange(desc(ASVmeans))
   
   rownames(SSUData) <- SSUData$ASV

   write.csv2(SSUData, paste0(file.path(path_Output_16S, paste(paste(save_name, 
            paste("SSU_ALL", sep=""), Date, Datasetname,  sep="_"),".csv", sep=""))))
   
  ############################################################################
  #Create WGCNA Dataframe: Species, ModuleMembership, Correlation to Abiotics#
  ############################################################################
  modNames     <- names(MEs)
  nSamples     <- nrow(omics_data)
  SSUWGCNAlist <- list()
  
  for (i in names(MEs)) {
    
    a <- length(SSUWGCNAlist)
    ModuleOfInterst <- paste(sub("ME", "", i))
  
    geneModuleMembership = as.data.frame(cor(omics_data, MEs, use = "p"));
    MMPvalue = as.data.frame(corPvalueStudent(as.matrix(geneModuleMembership), nSamples));
    names(geneModuleMembership) = paste("MM", modNames, sep="");
    names(MMPvalue) = paste("p.MM", modNames, sep="");
    
    
    DatTraitOfInterest <- as.data.frame(datTraits[data[data$Module %in% i,]$TraitOfInterest])

    GS_list <- list()
      if (ncol(DatTraitOfInterest) > 0) {
        for (TraitOfInterest in names(DatTraitOfInterest)) {
      
        geneTraitSignificance = 
        as.data.frame(WGCNA::cor(omics_data, DatTraitOfInterest[TraitOfInterest], use = "p"));
        GSPvalue = as.data.frame(WGCNA::corPvalueStudent(as.matrix(geneTraitSignificance), nSamples));
        names(geneTraitSignificance) = paste("GS.", names(DatTraitOfInterest[TraitOfInterest]), sep="");
        names(GSPvalue) = paste("p.GS.", names(DatTraitOfInterest[TraitOfInterest]), sep="");
        GS_list[[TraitOfInterest]] <- geneTraitSignificance 
      }
    
      align_rows <- function(lst) {
      common_rows <- Reduce(intersect, lapply(lst, rownames))
      aligned_list <- lapply(lst, function(df) df[common_rows, , drop=FALSE])
      return(aligned_list)
      }
      aligned_GS_list <- align_rows(GS_list)
      combined_df <- do.call(cbind, aligned_GS_list)
    } else {
    cat("'TraitOfInterest' does not exist in the names of DatTraitOfInterest.\n")
    }

    OmicsPerModule <- as.data.frame(names(moduleLabels[moduleLabels == ModuleOfInterst]))
    names(OmicsPerModule) <- paste("ME", ModuleOfInterst, sep="")
    rownames(OmicsPerModule) <- OmicsPerModule[,1]
 
    SSUWGCNAdata <- OmicsPerModule %>% rownames_to_column("RowName") %>%
          left_join(geneModuleMembership[rownames(OmicsPerModule),, drop = FALSE][names(geneModuleMembership) %in%
          paste("MMME", ModuleOfInterst, sep="")] %>% rownames_to_column("RowName"), by = "RowName") %>%
          column_to_rownames("RowName")
    
    
   if (ncol(DatTraitOfInterest) > 0) {
      SSUWGCNAdata1 <- SSUWGCNAdata %>% 
        rownames_to_column("RowName") %>%
        left_join(combined_df %>% 
        rownames_to_column("RowName"))
      SSUWGCNAdata1$ASV <- SSUWGCNAdata1$RowName
      SSUWGCNAdata2 <- SSUWGCNAdata1 %>%
        left_join(SSUData[SSUData$ASV %in% SSUWGCNAdata1$RowName,]) %>%
        dplyr::arrange(desc(ASVmeans)) 

    } else {
        SSUWGCNAdata2 <- SSUWGCNAdata %>%
          mutate(ASV = rownames(.)) %>%
        left_join(SSUData[SSUData$ASV %in% rownames(SSUWGCNAdata),]) %>%
        dplyr::arrange(desc(ASVmeans)) 
    }
  
  # SSUWGCNAdata  <- SSUWGCNAdata  %>% rownames_to_column("RowName") %>%
  #         left_join(geneTraitSignificance[rownames(OmicsPerModule),, drop = FALSE][names(geneTraitSignificance) %in%
  #         paste("GS.", TraitOfInterest, sep="")] %>% rownames_to_column("RowName"), by = "RowName") %>%
  #         column_to_rownames("RowName")
  # 

  
  #Reoder by kME/Module Membership
  #SSUWGCNAdata <- SSUWGCNAdata %>%
  #          dplyr::arrange(desc(SSUWGCNAdata[paste("MMME", ModuleOfInterst, sep="")]))

  SSUWGCNAlist[[a+1]] <- SSUWGCNAdata2
  
  names(SSUWGCNAlist)[[a+1]] <- paste("SSU",ModuleOfInterst, sep="")
  
  write.csv2(SSUWGCNAdata2, paste0(file.path(path_Output_16S, paste(paste(save_name, 
            paste("SSU",ModuleOfInterst, sep=""), Date, Datasetname,  sep="_"),".csv", sep=""))))
  
  }
  
  WGCNA_list[[Datasetname]][["SSUWGCNAlist"]] <- SSUWGCNAlist
}


#Export ASVs as Fasta 
# pslist$ps_SL %>%
#       refseq() %>%
#       Biostrings::writeXStringSet(paste0(file.path(path_Output_16S, "SSUWGCNAlist_SL_21.08.23.asv.fna")), append=FALSE,
#                                   compress=FALSE, compression_level=NA, format="fasta")
# fasta_sequences <- Biostrings::readDNAStringSet(paste0(file.path(path_Output_16S, "SSUWGCNAlist_SL_21.08.23.asv.fna")))
# target_names    <- SSUWGCNAlist$SSU8$ASV
# # Subset the sequences based on the target names
# subset_sequences <- fasta_sequences[names(fasta_sequences) %in% target_names]
# Biostrings::writeXStringSet(subset_sequences, paste0(file.path(path_Output_16S, "SSUWGCNAlist_SL_21.08.23_SSU8.asv.fna")))

#######################################
#Extract and Inspect Sequences on NCBI#
#######################################  
  # minTotRelAbun = 0.001
  # x = taxa_sums(pslist$ps_Mock)
  # keepTaxa = which((x / sum(x)) > minTotRelAbun)
  # prunedSet = prune_taxa(as.character(keepTaxa), pslist$ps_Mock)
  # 
  # prunedSet %>%
  #     refseq() %>%
  #     Biostrings::writeXStringSet("~/asv.fna", append=FALSE,
  #                                 compress=FALSE, compression_level=NA, format="fasta")
saveRDS(WGCNA_list, file = paste0(file.path(path_Output_16S, paste(paste(save_name, "WGCNA_list", Date, sep="_"), ".rds", sep=""))))

```


### 9.3.3 Integrated Heatmap OE & GC

```{r,  message=FALSE,warning=FALSE, fig.width=20, fig.height=15}

hmps_list <- list()
for (Datasetname  in names(WGCNA_list)[grepl("OE|GC", names(WGCNA_list))]) {
  
  omics_data    <- WGCNA_list[[Datasetname]]$omics_data
  datTraits     <- WGCNA_list[[Datasetname]]$datTraits
  moduleLabels  <- WGCNA_list[[Datasetname]]$moduleLabels
  moduleColors  <- WGCNA_list[[Datasetname]]$moduleColors
  RNA_MEs       <- WGCNA_list[[Datasetname]]$MEs
    names(RNA_MEs) <- sub("ME", paste(Datasetname), names(RNA_MEs))
  WF_MEs       <- WGCNA_list[["WF"]]$MEs
    names(WF_MEs) <- sub("ME", "WF", names(WF_MEs))
  network       <- WGCNA_list[[Datasetname]]$network
  ps            <- WGCNA_list[[Datasetname]]$ps
  traitData     <- WGCNA_list[[Datasetname]]$traitData
  SAM_MEs       <- data.frame(sample_data(WGCNA_list[[Datasetname]]$ps))
  
  ASVsums <- as.data.frame(sapply(WGCNA_list[[Datasetname]]$SSUWGCNAlist, function(x) sum(x$ASVmeans))) 
  ASVsums<- ASVsums %>% 
    round(0) %>%
    setNames("ASVsum") %>%
    rownames_to_column(var = "Module") %>%
    dplyr::arrange(desc(ASVsum))
  ASVsums$Module <- sub("SSU", paste(Datasetname), ASVsums$Module)


  # WGCNA_NormalHeatmap_RK(
  #   SAM_MEs = SAM_MEs,
  #   SSU_MEs = MEs,
  #   WIDTH = WIDTH,
  #   HEIGHT = HEIGHT,
  #   traitData = traitData)
  # Normal_hmap
  
  ##############################################################
  #Creating artificially expanded Bakterioplankton ME dataframe#
  ##############################################################
  ps_WF <- pslist[[paste("ps", "WF", sep="_")]]
  
  Names_Fish <- substring(sample_data(ps)$SampleID, first = 3)
  NAME_WF <- substring(rownames(WF_MEs), first = 3)
  
  NAME_WF <- gsub("\\d+$", "", NAME_WF)
  NAME_WF <- substr(NAME_WF , 1, nchar(NAME_WF ) - 2)
  
  Names_Fish_with_matching_WF <- Names_Fish[substr(gsub("\\d+$", "", Names_Fish), 1, 
                                 nchar(gsub("\\d+$", "", Names_Fish)) - 2) %in% NAME_WF]
  print("These Fish samples have real matching Waterfilters from the same Catch")
  print(Names_Fish_with_matching_WF)
  
  print("These will be created from related catches")
  print(setdiff(Names_Fish, Names_Fish_with_matching_WF))
  
  # matching_WF <- sample_data(ps) |>
  #   mutate(Names_Fish = gsub("\\d+$", "", substring(SampleID, first = 3))) |>
  #   mutate(Names_Fish = substr(Names_Fish , 1, nchar(Names_Fish ) - 2))
  # matching_WF <- matching_WF[matching_WF$Names_Fish %in% NAME_WF]

  WF_ME_Expanded <- list()
    for (i in seq_along(Names_Fish)) {
        NAME  <- Names_Fish[i]
        NAME2 <- gsub("\\d+$", "", NAME)
        NAME3 <- substr(NAME2 , 1, nchar(NAME2 ) - 2)
        NAME4 <- substr(NAME3 , 1, nchar(NAME3 ) - 2)

        if (paste("WF", NAME3, "EB", sep="") %in% rownames(WF_MEs)) {
          WF_ME_Expanded[[i]] <- WF_MEs[rownames(WF_MEs) %in% paste("WF", NAME3, "EB", sep=""),]
        } else if (paste("WF", NAME3, "FL", sep="") %in% rownames(WF_MEs)){
          WF_ME_Expanded[[i]] <- WF_MEs[rownames(WF_MEs) %in% paste("WF", NAME3, "FL", sep=""),]
          
        } else if (paste("WF", NAME4, "TWEB", sep="") %in% rownames(WF_MEs)){
          WF_ME_Expanded[[i]] <- WF_MEs[rownames(WF_MEs) %in% paste("WF", NAME4, "TWEB", sep=""),]
          
        } else if (paste("WF", NAME4, "MLFL", sep="") %in% rownames(WF_MEs)){
          WF_ME_Expanded[[i]] <- WF_MEs[rownames(WF_MEs) %in% paste("WF", NAME4, "MLFL", sep=""),]
          
        } else {print(NA)}
        names(WF_ME_Expanded)[[i]] <- paste("WF", NAME, sep="")
  }
  WF_ME_Expanded_df <- do.call(rbind, WF_ME_Expanded)  
  
  ##############################
  #Creating Integraded heatmaps#
  ##############################
  hmps_length <- length(hmps_list)
  FILENAME    <- paste(paste("IntegratedHeatmap", Datasetname, Date, sep="_"),".png", sep="")
        
      WGCNA_IntegratedHeatmap_RK(
        SAM_MEs =  SAM_MEs,
        RNA_MEs =  RNA_MEs,#[names(RNA_MEs) != paste(Datasetname, "0", sep="")],
        SSU_MEs =  WF_ME_Expanded_df[names(  WF_ME_Expanded_df) != "WF0"], 
        WIDTH     = 16,
        HEIGHT  = 5,
        OutlineColor = "grey20",
        traitData = traitData)
        
     hmps_list[[hmps_length+1]] <- ht_list
     names(hmps_list)[[hmps_length+1]] <- paste("ht_list", Datasetname, sep="_")
     

    prow <- cowplot::plot_grid(grid.grabExpr(ComplexHeatmap::draw(ht_list, auto_adjust = FALSE, 
                    background = "transparent",
                   heatmap_legend_side = "left", annotation_legend_side = "bottom")))
    title <- ggdraw() 
    subtitle <- ggdraw() + draw_label_themeRKwhite(paste("Heatmap MEs", sep = " "), 
              element = "plot.subtitle",x = 0.05, hjust = 0, vjust = 1)
    b <- plot_grid(title, subtitle, prow, ncol = 1, rel_heights = c(0.04, 0.05, 0.98)) 
    #Safe the plots in a specified folder <- may have to change the width and height

    plot(prow)
     
}



```

### 9.3.3 Integrated Heatmap Bakterioplankton

```{r,  message=FALSE,warning=FALSE, fig.width=15, fig.height=15}
for (Datasetname  in names(WGCNA_list)[grepl("WF", names(WGCNA_list))]) {
   
  omics_data    <- WGCNA_list[[Datasetname]]$omics_data
  datTraits     <- WGCNA_list[[Datasetname]]$datTraits
  moduleLabels  <- WGCNA_list[[Datasetname]]$moduleLabels
  moduleColors  <- WGCNA_list[[Datasetname]]$moduleColors
  RNA_MEs       <- WGCNA_list[[Datasetname]]$MEs 
    names(RNA_MEs) <- sub("ME", "WF", names(RNA_MEs))
  
  network       <- WGCNA_list[[Datasetname]]$network
  ps            <- WGCNA_list[[Datasetname]]$ps
  traitData     <- WGCNA_list[[Datasetname]]$traitData
  SAM_MEs       <- data.frame(sample_data(WGCNA_list[[Datasetname]]$ps))
  
  ASVsums <- as.data.frame(sapply(WGCNA_list[[Datasetname]]$SSUWGCNAlist, function(x) sum(x$ASVmeans))) 
  ASVsums<- ASVsums %>% 
    round(0) %>%
    setNames("ASVsum") %>%
    rownames_to_column(var = "Module") %>%
    dplyr::arrange(desc(ASVsum))
  ASVsums$Module <- sub("SSU", paste(Datasetname), ASVsums$Module)
  
  ##############################
  #Creating Integraded heatmaps#
  ##############################
  hmps_length <- length(hmps_list)
  FILENAME    <- paste(paste("IntegratedHeatmap", Datasetname, Date, sep="_"),".png", sep="")
  
  WGCNA_IntegratedHeatmap_Bakterioplankton_RK (
        SAM_MEs =  SAM_MEs,
        RNA_MEs =  RNA_MEs,#[names(RNA_MEs) != "WF0"],
        WIDTH     = 10,
        HEIGHT  = 5,
        OutlineColor = "grey20",
        traitData = traitData)

  hmps_list[[hmps_length+1]] <- ht_list
  names(hmps_list)[[hmps_length+1]] <- paste("ht_list", Datasetname, sep="_")
  
  
  prow <- cowplot::plot_grid(grid.grabExpr(ComplexHeatmap::draw(ht_list, auto_adjust = FALSE, 
                    background = "transparent",
                   heatmap_legend_side = "left", annotation_legend_side = "bottom")))
    title <- ggdraw() 
    subtitle <- ggdraw() + draw_label_themeRKwhite(paste("Heatmap MEs", sep = " "), 
              element = "plot.subtitle",x = 0.05, hjust = 0, vjust = 1)
    b <- plot_grid(title, subtitle, prow, ncol = 1, rel_heights = c(0.04, 0.05, 0.98)) 
    #Safe the plots in a specified folder <- may have to change the width and height

    plot(prow)
}

```

#### 9.3.3.1 Module Top Barplot

```{r}
 ASVsums <- as.data.frame(sapply(WGCNA_list[[Datasetname]]$SSUWGCNAlist, function(x) sum(x$ASVmeans))) 
  ASVsums<- ASVsums %>% 
    round(0) %>%
    setNames("ASVsum") %>%
    rownames_to_column(var = "Module") %>%
    dplyr::arrange(desc(ASVsum))
  ASVsums$Module <- sub("SSU", paste(Datasetname), ASVsums$Module)

  head(WGCNA_list[[Datasetname]]$SSUWGCNAlist$SSU2$ASVmeans, 5)
  


Module_Top5_Barplot_list <- list() 
bars_list <- list()
for (Datasetname in names(WGCNA_list)[grepl("OE|GC|WF", names(WGCNA_list))]) {
  #Datasetname <- sub("ps_","", Dataset)
  
  ps <- pslist[[paste("ps", Datasetname, sep="_")]]
  
  Module_Top5_Barplot_list[[Datasetname]] <- list()
  bars_list[[Datasetname]] <- list()
  
  for (Interest_ME  in names(WGCNA_list[[Datasetname]]$SSUWGCNAlist)) {

    ################################################
    Interest_ME_dat <- WGCNA_list[[Datasetname]]$SSUWGCNAlist[[paste(Interest_ME,
                                sep="")]]
    
    print(paste("rel ASVmeans in Module", Interest_ME))

      data <- head(
      Interest_ME_dat %>%
        dplyr::mutate(total_sum_ASVmeans = sum(ASVmeans, na.rm = TRUE)) %>%
        dplyr::group_by(ASV) %>%
        dplyr::mutate(sum_ASVmeans = sum(ASVmeans, na.rm = TRUE)) %>%
        dplyr::summarize(rel_ASVmeans = round(sum(sum_ASVmeans) / sum(total_sum_ASVmeans) * 100,
                                              digits=2))%>%
        dplyr::arrange(desc(rel_ASVmeans)) %>% 
        as.data.frame() %>% 
        left_join(Interest_ME_dat[c("Phylum", "Class", "Order", "Family", "Genus", "Species", "ASV")])
      , 5)
     print(head(data, 2))
     
     data$ASVcut <-  sub(".*:", "", data$ASV)
     result <- data %>%
       dplyr::group_by(ASVcut) %>%
       dplyr::summarise(rel_ASVmeans = sum(rel_ASVmeans, na.rm = TRUE),
            Phylum = dplyr::first(Phylum),
            Class = dplyr::first(Class),
            Order = dplyr::first(Order),
            Family = dplyr::first(Family),
            Genus = dplyr::first(Genus),
            Species = dplyr::first(Species))
 
    p <- ggplot(result, aes(x = ASVcut, y = rel_ASVmeans, fill = Phylum)) +
    geom_bar(stat = "identity", alpha = 0.7) +
    theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
    labs(title = "Relative ASV Means", x = "ASV", y = "Relative ASV Means") +
    scale_fill_manual(values = phylum_colors_Cytoscape) +
  #scale_fill_brewer(palette = "Set3") +
     #       annotate("text", x = x_pos, y = y_pos, label = paste(sub("SSU", Datasetname, Interest_ME)), hjust = 0, vjust = 1.5, size = 8, color = "black", fontface = "bold") +
    #       annotate("text", x = Inf, y = Inf, label = paste(sub("SSU", Datasetname, Interest_ME)), hjust = -0.1, vjust = 1.5) +
      coord_flip() +
      theme(panel.border = element_rect(color = "black", fill = NA, size = 1)) 

    
 
    
    y_start <- ifelse(range(result$rel_ASVmeans) >= 0 & range(result$rel_ASVmeans) <= 5, 2, 
                  ifelse(range(result$rel_ASVmeans) > 5 & range(result$rel_ASVmeans) <= 10, 4.5, 
                          ifelse(range(result$rel_ASVmeans) > 10 & range(result$rel_ASVmeans) <= 20, 7, 
                                  ifelse(range(result$rel_ASVmeans) > 20 & range(result$rel_ASVmeans) <= 50, 18, 
                                         ifelse(range(result$rel_ASVmeans) > 50 & range(result$rel_ASVmeans) <= 100, 30,
                          NA)))))
                  


# Add y-axis labels as annotations starting at the calculated position
  p <-  p + geom_text(aes(label = ASVcut, y = y_start[2]), vjust = 1, size = 3.8, fontface='bold') +
      #p <- p + geom_text(aes(label = ASVcut, y = 5), vjust = 1, size = 4) +
      #geom_text(aes(label = ASVcut), vjust = -0.5, size = 3) +
  theme(axis.title.y=element_blank(),
        axis.text.y=element_blank(),
        axis.ticks.y=element_blank()) +

      theme(strip.text.y = element_text(angle = 0))  +
        theme(
         panel.background = element_rect(fill='transparent'), #transparent panel bg
         plot.background = element_rect(fill='transparent', color=NA), #transparent plot bg
         #legend.background = element_rect(fill='transparent'), #transparent legend bg
         #legend.box.background = element_rect(fill='transparent') #transparent legend panel
         ) +
      #theme(#axis.title.x.bottom =  element_text(color="grey13"), 
      #  strip.text = element_text(color = "black", face= "bold")) +
      theme(
        #legend.title=element_text(size=12), 
        #legend.text=element_text(size=12), 
        axis.text.x.bottom = element_text(size= 12, face = "bold", angle = 45, hjust = 1))+
        #strip.text.y.left = element_text(size = 12,face = "bold"), 
        #axis.title.y.left = element_text(size=12,face = "bold")) +
        theme(legend.position = "none") +
      #ylab("ASV mean [%]") +
      labs(title = "", x = "", y = "") #module ASV mean [%]

    
    prow <- cowplot::plot_grid(p, labels = c(""), ncol = 1)
    Module_Top5_Barplot_list[[Datasetname]][[Interest_ME]] <- prow
    bars_list[[Datasetname]][[Interest_ME]] <- data.frame(SSU = Interest_ME, bars = dim(result)[1])
  }
}

####
#OE#
####
  cowplot::plot_grid(Module_Top5_Barplot_list$OE$SSU8, Module_Top5_Barplot_list$OE$SSU13,
                   Module_Top5_Barplot_list$OE$SSU6, Module_Top5_Barplot_list$OE$SSU12,
                   Module_Top5_Barplot_list$OE$SSU3,  Module_Top5_Barplot_list$OE$SSU10,
                   Module_Top5_Barplot_list$OE$SSU2, nrow=1, 
  labels = c("OE8", "OE13", "OE6", "OE12", "OE3", "OE10", "OE2")) -> part_1

  cowplot::plot_grid( Module_Top5_Barplot_list$OE$SSU11, Module_Top5_Barplot_list$OE$SSU5,
                    Module_Top5_Barplot_list$OE$SSU7,Module_Top5_Barplot_list$OE$SSU4,
                    Module_Top5_Barplot_list$OE$SSU1, Module_Top5_Barplot_list$OE$SSU9,
                    Module_Top5_Barplot_list$OE$SSU0, nrow=1, 
                    labels = c( "OE11", "OE5", "OE7", "OE4", "OE1", "OE9", "OE0")) -> part_2
  cowplot::plot_grid(part_1, part_2, nrow= 2) -> part_3
  ggsave(part_3, filename = paste(paste("Module_topTaxa_plot", 
          sep="_"),".png", sep=""), path = pathPlots , device='png', dpi=300, width = 16.5,height = 6)
####
#GC#
####
cowplot::plot_grid(Module_Top5_Barplot_list$GC$SSU3, Module_Top5_Barplot_list$GC$SSU5,
                   Module_Top5_Barplot_list$GC$SSU9, Module_Top5_Barplot_list$GC$SSU6,
                   Module_Top5_Barplot_list$GC$SSU10,  Module_Top5_Barplot_list$GC$SSU7,
                   Module_Top5_Barplot_list$GC$SSU8, Module_Top5_Barplot_list$GC$SSU16, 
                   Module_Top5_Barplot_list$GC$SSU4, 
                   nrow=1, 
labels = c("GC3", "GC5", "GC9", "GC6", "GC10", "GC7", "GC8", "GC16", "GC4")) -> part_1

cowplot::plot_grid( Module_Top5_Barplot_list$GC$SSU14, Module_Top5_Barplot_list$GC$SSU13,
                    Module_Top5_Barplot_list$GC$SSU2,Module_Top5_Barplot_list$GC$SSU15,
                    Module_Top5_Barplot_list$GC$SSU11, Module_Top5_Barplot_list$GC$SSU1,
                    Module_Top5_Barplot_list$GC$SSU12, Module_Top5_Barplot_list$GC$SSU0,
                    nrow=1, 
                    labels = c( "GC14", "GC13", "GC2", "GC15", "GC11", "GC1", "GC12", "GC0")) -> part_2
cowplot::plot_grid(part_1, part_2, nrow= 2) -> part_3
ggsave(part_3, filename = paste(paste("Module_topTaxa_plot_GC", 
          sep="_"),".png", sep=""), path = pathPlots , device='png', dpi=300, width = 18,height = 6)

#### 
#WF#
####

cowplot::plot_grid(Module_Top5_Barplot_list$WF$SSU9, Module_Top5_Barplot_list$WF$SSU17,
                   Module_Top5_Barplot_list$WF$SSU4, Module_Top5_Barplot_list$WF$SSU16,
                   Module_Top5_Barplot_list$WF$SSU23,  Module_Top5_Barplot_list$WF$SSU15,
                   Module_Top5_Barplot_list$WF$SSU21, Module_Top5_Barplot_list$WF$SSU2, 
                   Module_Top5_Barplot_list$WF$SSU10, 
                   nrow=1, 
labels = c("WF9", "WF17", "WF4", "WF16", "WF23", "WF15", "WF21", "WF2", "WF10")) -> part_1

cowplot::plot_grid(Module_Top5_Barplot_list$WF$SSU5, Module_Top5_Barplot_list$WF$SSU12,
                   Module_Top5_Barplot_list$WF$SSU18,Module_Top5_Barplot_list$WF$SSU3,
                   Module_Top5_Barplot_list$WF$SSU13, Module_Top5_Barplot_list$WF$SSU14,
                   Module_Top5_Barplot_list$WF$SSU19,Module_Top5_Barplot_list$WF$SSU7,
                    nrow=1, 
                   labels = c("WF5", "WF12", "WF18", "WF3", "WF13", "WF14", "WF19", "WF7")) -> part_2

cowplot::plot_grid( 
                    Module_Top5_Barplot_list$WF$SSU22, Module_Top5_Barplot_list$WF$SSU11,
                    Module_Top5_Barplot_list$WF$SSU8, Module_Top5_Barplot_list$WF$SSU20,
                    Module_Top5_Barplot_list$WF$SSU6, Module_Top5_Barplot_list$WF$SSU1,
                    Module_Top5_Barplot_list$WF$SSU24, Module_Top5_Barplot_list$WF$SSU0,
                    nrow=1, 
                    labels = c(  "WF22", "WF11", "WF8", "WF20", "WF6", "WF1", "WF24", "WF0")) -> part_3
cowplot::plot_grid(part_1, part_2, part_3, nrow= 3) -> part_4

ggsave(part_4, filename = paste(paste("Module_topTaxa_plot_WF", 
          sep="_"),".png", sep=""), path = pathPlots , device='png', dpi=300, width = 16,height = 9)
 
 
 
 
 cowplot::plot_grid(Module_Top5_Barplot_list$WF$SSU9, Module_Top5_Barplot_list$WF$SSU17,
                   Module_Top5_Barplot_list$WF$SSU4, Module_Top5_Barplot_list$WF$SSU16,
                   Module_Top5_Barplot_list$WF$SSU23,  Module_Top5_Barplot_list$WF$SSU15,
                   Module_Top5_Barplot_list$WF$SSU21, 
                   nrow=1, 
labels = c("WF9", "WF17", "WF4", "WF16", "WF23", "WF15", "WF21")) -> part_1

cowplot::plot_grid(Module_Top5_Barplot_list$WF$SSU2, Module_Top5_Barplot_list$WF$SSU10, 
                   Module_Top5_Barplot_list$WF$SSU5, Module_Top5_Barplot_list$WF$SSU12,
                   Module_Top5_Barplot_list$WF$SSU18,Module_Top5_Barplot_list$WF$SSU3,
                    nrow=1, 
                   labels = c("WF2", "WF10", "WF5", "WF12", "WF18", "WF3")) -> part_2

cowplot::plot_grid( Module_Top5_Barplot_list$WF$SSU13, Module_Top5_Barplot_list$WF$SSU14,
                    Module_Top5_Barplot_list$WF$SSU19,Module_Top5_Barplot_list$WF$SSU7,
                    Module_Top5_Barplot_list$WF$SSU22, Module_Top5_Barplot_list$WF$SSU11,
                   
                    nrow=1, 
                    labels = c("WF13", "WF14", "WF19", "WF7", "WF22", "WF11", "WF8", "WF20", "WF6", "WF1", "WF24", "WF0")) -> part_3


cowplot::plot_grid( Module_Top5_Barplot_list$WF$SSU8, Module_Top5_Barplot_list$WF$SSU20,
                    Module_Top5_Barplot_list$WF$SSU6, Module_Top5_Barplot_list$WF$SSU1,
                    Module_Top5_Barplot_list$WF$SSU24, Module_Top5_Barplot_list$WF$SSU0,
                    nrow=1, 
                    labels = c( "WF8", "WF20", "WF6", "WF1", "WF24", "WF0")) -> part_4
 cowplot::plot_grid(part_1, part_2, part_3, part_4, nrow= 4) -> part_5
ggsave(part_5, filename = paste(paste("Module_topTaxa_plot_WF", 
          sep="_"),".png", sep=""), path = pathPlots , device='png', dpi=300, width = 12,height = 11)

 
 


```




### 9.3.4 Scatter with Kin

Lets check our understanding of these measurements:
1) kTotal - connectivity of the each gene based on its r-values to all other genes in the whole network
2) kWithin - connectivity of the each gene within a single module based on its r-values to all other genes within the same module
3) and 4) kOut and kDiff mathematical derivatives from 1) and 2)
So, let say WGCNA identified 10 modules, but kWithin for "Module 2" is the largest and obviously larger than kTotal. This suggest "Module 2" to be a core of the network, or more important. Let say You perform functional annotation of the genes in this module and will find them to be enriched in amino acid analysis. And Your study was dedicated to metabolic changes under some conditions. So You can make conclusion that Your condition strongly affects AA metabolism, and via it - whole network.
In contrast, high kOut can suggest that total connectivity is much larger that connectivity within modules, and I would say - reflects sort of network's stability under tested conditions. So a set of vertices with high kOut can be targets for annotation as hubs that determined this stability. And elimination of them (knockout mutations, for example) can break the whole network.


```{r,  message=FALSE,warning=FALSE}
################################################
#Scatter GS vs ModuleMembership over all Traits#
################################################
Kin_data <- list()
for (Datasetname  in names(WGCNA_list)[grepl("OE|GC", names(WGCNA_list))]) {

  require(WGCNA)
  Kin_data[[Datasetname]] <- list()
  omics_data    <- WGCNA_list[[Datasetname]]$omics_data
  datTraits     <- WGCNA_list[[Datasetname]]$datTraits
  moduleLabels  <- WGCNA_list[[Datasetname]]$moduleLabels
  moduleColors  <- WGCNA_list[[Datasetname]]$moduleColors
  MEs           <- WGCNA_list[[Datasetname]]$MEs
  network       <- WGCNA_list[[Datasetname]]$network
  ps            <- WGCNA_list[[Datasetname]]$ps
  softPower     <- WGCNA_list[[Datasetname]]$softPower
  SSUWGCNAlist  <- WGCNA_list[[Datasetname]]$SSUWGCNAlist
  
  TaxAnno       <- data.frame(tax_table(WGCNA_list$WF$ps)) %>% rownames_to_column(var="ASV")
  ModsOfInterst_list <- WGCNA_list[[Datasetname]]$ModsOfInterst_list[[paste("ModsOfInterest", 
                                                                            Datasetname, sep="_")]]
  

  module_size<- as.data.frame(table(moduleLabels))
  colnames(module_size) <- c("Module", "Size")
  module_size %>% dplyr::mutate(Module_color = labels2colors(as.numeric(as.character(Module)))) -> 
  module_size

  degrees <- intramodularConnectivity.fromExpr(as.data.frame(omics_data), 
                                             colors = moduleColors, power = softPower,
                                             networkType = "signed", distFnc = "bicor")
  degrees<- cbind(moduleLabels, degrees )

        
  #############################################################################
  #Creating GeneMembership and GeneSignificance Dataframes with GeneAnnotation#
  #############################################################################

  for (TraitOfInterest in colnames(datTraits)) {
    
    if (length(rownames(ModsOfInterst_list[[TraitOfInterest]])) != 0) {
    
      Kin_data[[Datasetname]][[TraitOfInterest]] <- list()
    

      for (MODULE in rownames(ModsOfInterst_list[[TraitOfInterest]])) {
            
      print(MODULE)
          
      modNames = names(MEs) #substring(names(MEs), 2)
      column = match(MODULE, modNames);
      ASV <- names(moduleLabels[moduleLabels == sub("ME","", MODULE)])
      moduleColor <-  labels2colors(as.numeric(as.character( sub("ME","", MODULE))))
      nSamples = nrow(omics_data)
      Data <- as.data.frame(cbind(ASV, moduleColor))
      Data  <- Data %>%
         left_join( #Add relative ASVmeans
         data.frame(t(phyloseq::otu_table(ps %>%
          transform_sample_counts(function(x) {x/sum(x)*100})))) %>%
            dplyr::mutate(ASVmeans = rowMeans(.)) %>%
            dplyr::mutate(ASV = rownames(.)) %>%
            dplyr::select(ASV, ASVmeans)) %>%
        left_join(as.data.frame(tax_table(ps)) %>% rownames_to_column(var="ASV"))
    
    geneModuleMembership <- cor(omics_data, MEs, use = "p") %>%
        as.data.frame() %>% #Create ModuleMembership 
        dplyr::select(paste("ME", sub("ME","", MODULE), sep="")) %>%
        setNames(paste0("MM"))  #No Individual naming here for Cytoscape columns beeing equal
    
    MMPvalue <- #Creating p.values for Module memberships
        as.data.frame(corPvalueStudent(as.matrix(geneModuleMembership), length(rownames(MEs)))) %>%
        dplyr::select(paste("MM", sep="")) %>%
        setNames(paste0("p.MM")) 
    
    geneTraitSignificance = as.data.frame(WGCNA::cor(omics_data,  datTraits[TraitOfInterest], use = "p"));
        GSPvalue = as.data.frame(WGCNA::corPvalueStudent(as.matrix(geneTraitSignificance), nSamples));
        names(geneTraitSignificance) = "GS"
        names(GSPvalue) = "p.GS"
 
    Data <- Data %>%
       left_join(geneModuleMembership  %>% rownames_to_column(var="ASV")) %>%
       left_join(MMPvalue  %>% rownames_to_column(var="ASV")) %>%
       left_join(geneTraitSignificance  %>% rownames_to_column(var="ASV")) %>%
       left_join(GSPvalue  %>% rownames_to_column(var="ASV"))  %>%
       left_join(degrees%>% rownames_to_column(var = "ASV"))
       # left_join(SeasonSums) %>%
       # left_join(RepSums)
    #dplyr::arrange(desc(ASVmeans))
    rownames(Data) <- Data$ASV
    
    Data$ASVname <- gsub("^ASV\\d+:", "", Data$ASV)
    Data$Trait <- TraitOfInterest
    
    #######################
    #Filter for Parameters#
    #######################
    #Data_filt <- Data %>% 
    #        filter(abs(MM) > 0.5 & p.MM < 0.05 & ASVmeans > 0.005) 
    Kin_data[[Datasetname]][[TraitOfInterest]][[MODULE]] <- Data
      }
  
        ######
        #Plot#
        ######
        if (!is.null(Kin_data[[Datasetname]][[TraitOfInterest]])) {
          BB <- do.call(rbind, Kin_data[[Datasetname]][[TraitOfInterest]])
        }
        BB$Modules <- sub("\\..*","",rownames(BB))
        rownames(BB) <-NULL
        
        #if (any(BB$moduleColor != "grey")) {
        #  BBB <- BB #[BB$moduleColor != "grey", ]
        #  } else {
          BBB <- BB
        #  }
        
        BBB$Modules <- sub(paste("_", TraitOfInterest, sep=""), "", BBB$Modules)
        BBB$Modules <- sub("ME", "", BBB$Modules)

        names(BBB) <- gsub(TraitOfInterest, "", names(BBB))
        BBB$TraitOfInterest <- TraitOfInterest
        
      require(cowplot)
      tryCatch({
      FILENAME    <- paste(paste("MultiModuleScatter-kwithin", Datasetname, TraitOfInterest, sep="_"),
                          ".png", sep="")

      plot <- ggplot(data = BBB, aes(x = .data$MM, y = .data$GS)) +
        geom_point(aes(colour = .data$moduleColor, size = ASVmeans), alpha = 0.5) +
        scale_size_continuous(range = c(0.4, 4)) +  # Adjust the size range
        xlab(paste("Module Membership", sep = " ")) +
        ylab(paste("ASV significance for", TraitOfInterest, sep = " ")) +
        labs(title = "",#paste(Tissue, Type, "Module Membership vs. ASV Significance")
        color = "sig. Modules") +
        scale_color_identity(guide = 'legend',
                       breaks = unique(BBB$moduleColor),
                       labels = paste(Datasetname, unique(BBB$moduleLabels))) +
        geom_hline(yintercept = 0, color = "red", linetype = "dashed")
      
        label <-  BBB %>%
                dplyr::arrange(desc(ASVmeans)) %>%
                dplyr::slice(c(1:5, (n() - 4):n()))
        
        label2 <- BBB %>%
                dplyr::arrange(desc(GS)) %>%
                dplyr::slice(c(1:5, (n() - 4):n()))
        label <- rbind(label, label2)
        label <- label[!duplicated(label$ASV),]

        plot <- plot + 
            ggrepel::geom_text_repel(
            data = label, size = 4,  aes(label = ASVname), color = OutlineColor) 
        
        # plot <- plot + ggrepel::geom_text_repel(
        #   data = BBB, size = 2.5, aes(label = ASVname), color = OutlineColor)
    
        # plot <- plot + theme_minimal() + atheme + theme(axis.title.x = element_blank()) +
        # theme(
        #   panel.grid.major = element_line(colour = "grey50"),
        #   panel.grid.minor = element_line(colour = "grey50"),
        #   legend.position = "right")
      
       plot <- plot + theme_minimal() + 
          #atheme+
          #theme(legend.position = "none") +
          theme(axis.title.x = element_blank()) +
          theme(
          #panel.grid.major = element_line(colour = "grey50"), 
          #panel.grid.minor = element_line(colour = "grey50"),
          legend.position = "right", 
          legend.title = element_text( size = 12, face = "bold"),
          legend.text = element_text(size = 12,face = "bold"), 
          axis.text.x.bottom = element_text(size = 15, face = "bold", angle = 45, hjust = 1),
          axis.text.y.left = element_text(size = 15, face = "bold"),
          axis.title.x = element_text(size = 15, face = "bold"),  # Axis title for x
          axis.title.y = element_text(size = 15, face = "bold"))

        ggsave(plot, filename = FILENAME, path = pathPlots, device='png', dpi=300, width = 6.5, height = 5)
    }, error=function(e){cat("ERROR :",conditionMessage(e), "\n")})
        
    }
  }
  WGCNA_list[[Datasetname]][["Kin_data"]] <- Kin_data
  }

```

#### 9.3.4.2 Specific Correlation

```{r}
Interest <- list("NO2" = 
                   list("OE" = "ME7", "GC" = "ME2"), 
                 "O2" = 
                   list("OE" = "ME7", "GC" = "ME2"), 
                  "Salinity" = 
                   list("OE" = "ME3", "GC" = "ME7") 
                 )
for (Datasetname in names(WGCNA_list)[grepl("OE|GC", names(WGCNA_list))]) {
  
  for (TraitOfInterest in names(Interest)) {

  GS_SSU <- WGCNA_list[[Datasetname]]$Kin_data[[Datasetname]][[TraitOfInterest]]
  MODULE <- Interest[[TraitOfInterest]][[Datasetname]]
  GS_SSU <- GS_SSU[[MODULE]]
  color_mapping<- pslist$Optics$colored_taxonomy_Fish

  #GS_SSU <- do.call(rbind, Kin_data$OE$NO2$ME7)  #%>% 
            #filter(abs(MM) > 0.5 & p.MM < 0.05 & ASVmeans > 0.005 & GS < -0.2) 

  COL <- na.omit(color_mapping[unique(names(color_mapping))])
  color_mapping <- pslist$Optics$colored_taxonomy_Fish
  COL <- na.omit(color_mapping[unique(names(color_mapping))])
  
  GS_SSU$Taxa <- GS_SSU$ASVname
  
  GS_SSU<- GS_SSU  %>% 
  left_join(COL)

  GS_SSU$Color<- GS_SSU$Color %>% replace_na("grey50")

    color_mapping <- setNames(GS_SSU$Color, GS_SSU$ASVname)
    color_mapping[["Candidatus Megaira"]] <- "purple"
    color_mapping[["Acinetobacter.lwoffii"]] <- "#996600"
    color_mapping[["Acinetobacter.johnsonii"]] <- "#663300"
    color_mapping[["Shewanella"]] <- "#FF3366"
    color_mapping[["Shewanella.baltica"]] <- "#FF0099"
    color_mapping[["Shewanella.putrefaciens"]] <-"#FF0066"
    color_mapping[["Photobacterium"]] <- "#FFF000"
    color_mapping[["Aeromonas"]] <- "#FFCC00"

  BacteriaHostCorrelationPlot <- ggplot(data = GS_SSU, aes(x = MM, y = GS)) + 
          geom_point(aes(colour = ASVname, size = ASVmeans), alpha = 0.8) +
          scale_size_continuous(range = c(1, 8)) +  # Adjust the size range
          xlab(paste("Intramodular correlation", sep = " ")) + 
          ylab(paste("Correlation to",unique(GS_SSU$Trait) , sep = " ")) +
          labs(#title = paste("Bacterial abundance correlated to host Gill-", subset_df$RNA_Module[1],
              #               sep=""),
          color = "Module") +
          theme(legend.position = "none") +
          scale_color_manual(values = color_mapping) +
          #scale_color_identity(guide = 'legend', 
          #             breaks = unique(GS_SSU$moduleColor), 
          #             labels = paste(Datasetname, unique(GS_SSU$moduleLabels), sep="")) +
          geom_hline(yintercept = 0, color = "red", size = 1,linetype = "dashed")

      #BacteriaHostCorrelatonPlot <- BacteriaHostCorrelatonPlot + 
      #      ggrepel::geom_text_repel(
      #      data = GS_SSU, size = 4,  aes(label = ASVname), color = OutlineColor) #white
      
  
      label <-  GS_SSU %>%
                dplyr::arrange(desc(ASVmeans)) %>%
                head(10)

      BacteriaHostCorrelationPlot <- BacteriaHostCorrelationPlot + 
            ggrepel::geom_text_repel(
            data = label, size = 4,  aes(label = ASVname), color = OutlineColor) 
   
      

      BacteriaHostCorrelationPlot <- BacteriaHostCorrelationPlot + theme_minimal() + 
          #atheme+
          theme(legend.position = "none") +
          theme(axis.title.x = element_blank()) +
          theme(
          #panel.grid.major = element_line(colour = "grey50"), 
          #panel.grid.minor = element_line(colour = "grey50"),
          #legend.position = "right", 
          legend.title = element_text( size = 12, face = "bold"),
          legend.text = element_text(size = 12,face = "bold"), 
          axis.text.x.bottom = element_text(size = 15, face = "bold", angle = 45, hjust = 1),
          axis.text.y.left = element_text(size = 15, face = "bold"),
          axis.title.x = element_text(size = 15, face = "bold"),  # Axis title for x
          axis.title.y = element_text(size = 15, face = "bold"))
          
      ggsave(BacteriaHostCorrelationPlot, filename = paste(paste(save_name, "GS_SSU", Datasetname,
            unique(GS_SSU$moduleLabels), unique(GS_SSU$Trait), sep="_"), ".png", sep="") , 
            path = pathPlots, device='png', dpi=300, width = 4, height = 4)
      
      plot(BacteriaHostCorrelationPlot)
  }
}
```

### 9.3.5 WGCNA & Core stats

```{r}

#Overall abundance per Module
ASVsums <- as.data.frame(sapply(WGCNA_list$OE$SSUWGCNAlist, function(x) sum(x$ASVmeans))) 
ASVsums<- ASVsums %>% 
  setNames("ASVsum") %>%
  rownames_to_column(var = "Module") %>%
  dplyr::arrange(desc(ASVsum))
ASVsums

ASVsums <- as.data.frame(sapply(WGCNA_list$GC$SSUWGCNAlist, function(x) sum(x$ASVmeans))) 
ASVsums<- ASVsums %>% 
  setNames("ASVsum") %>%
  rownames_to_column(var = "Module") %>%
  dplyr::arrange(desc(ASVsum))
ASVsums

ASVsums <- as.data.frame(sapply(WGCNA_list$WF$SSUWGCNAlist, function(x) sum(x$ASVmeans))) 
ASVsums<- ASVsums %>% 
  setNames("ASVsum") %>%
  rownames_to_column(var = "Module") %>%
  dplyr::arrange(desc(ASVsum))
ASVsums



####################################################
#Prevalence core vs network core & Bacterioplankton#
####################################################
for (Datasetname in names(WGCNA_list)) {
  #Datasetname <- sub("ps_","", Dataset)
  
  ps <- pslist[[paste("ps", Datasetname, sep="_")]]
  
  if (Datasetname == "OE") {
    Core_ME <- "6"
  } else if (Datasetname == "GC") {
    Core_ME <- "8"
  }
    
  SampleSums <- ps %>%
      transform_sample_counts(function(x) {x/sum(x)*100}) %>%
      phyloseq::otu_table() %>%
      as.data.frame() %>%
      rownames_to_column(var = "SampleID") %>%
      dplyr::left_join(SAMDF16S, by = c("SampleID" = "SampleID")) %>%
      dplyr::group_by(SampleID) %>%
      dplyr::summarise(dplyr::across(rownames(tax_table(ps)), mean, na.rm = TRUE)) %>% 
      t() %>%
      as.data.frame() %>%
      `colnames<-`(.[1, ]) %>%
      .[-1, ] %>%
      stats::setNames(paste0("avg_", colnames(.))) %>%
      mutate_all(as.numeric) %>%
      round(., digits = 2) %>%
      rownames_to_column(var="ASV")
  
   SeasonSums <- ps %>%
      transform_sample_counts(function(x) {x/sum(x)*100}) %>%
      phyloseq::otu_table() %>%
      as.data.frame() %>%
      rownames_to_column(var = "SampleID") %>%
      dplyr::left_join(SAMDF16S, by = c("SampleID" = "SampleID")) %>%
      dplyr::group_by(Season) %>%
      dplyr::summarise(dplyr::across(rownames(tax_table(ps)), mean, na.rm = TRUE)) %>% 
      t() %>%
      as.data.frame() %>%
      `colnames<-`(.[1, ]) %>%
      .[-1, ] %>%
      stats::setNames(paste0("avg_", colnames(.))) %>%
      mutate_all(as.numeric) %>%
      round(., digits = 2) %>%
      rownames_to_column(var="ASV")
   
   RepsSums <- ps %>%
      transform_sample_counts(function(x) {x/sum(x)*100}) %>%
      phyloseq::otu_table() %>%
      as.data.frame() %>%
      rownames_to_column(var = "SampleID") %>%
      dplyr::left_join(SAMDF16S, by = c("SampleID" = "SampleID")) %>%
      dplyr::group_by(Replicates) %>%
      dplyr::summarise(dplyr::across(rownames(tax_table(ps)), mean, na.rm = TRUE)) %>% 
      t() %>%
      as.data.frame() %>%
      `colnames<-`(.[1, ]) %>%
      .[-1, ] %>%
      stats::setNames(paste0("avg_", colnames(.))) %>%
      mutate_all(as.numeric) %>%
      round(., digits = 2) %>%
      rownames_to_column(var="ASV")
   
  ################################################
  #How much does the Core microbiome account for: 
  Core  <- pslist[[paste("Core", Datasetname, sep="_")]] %>%
            left_join( #Add relative ASVmeans 
            data.frame(t(phyloseq::otu_table(ps %>%
            transform_sample_counts(function(x) {x/sum(x)*100})))) %>%
            dplyr::mutate(ASVmeans = rowMeans(.)) %>%
            dplyr::mutate(ASV = rownames(.)) %>% 
            dplyr::select(ASV, ASVmeans)) 
  
  Core_ME_dat <- WGCNA_list[[Datasetname]]$SSUWGCNAlist[[paste("SSU", Core_ME,
                                sep="")]]
  
   print("Seasonal")
   print(SeasonSums  %>%
      dplyr::filter(ASV %in% Core$ASV) %>%
      dplyr::select(-ASV) %>%
      colSums() %>%
      as.data.frame()
   )
   
    print("Replicates")
    print(
    RepsSums  %>%
      dplyr::filter(ASV %in% Core$ASV) %>%
      dplyr::select(-ASV) %>%
      colSums() %>%
      as.data.frame()
    )
    
  #############################
  #Core Part of the Microbiome#
  #############################
  print(Datasetname)
  print(paste("Core Taxa account for", round(sum(Core$ASVmeans), digits=2), "%", "of the", 
              Datasetname, "Microbiome"))
  print(paste("Core Taxa", length(Core$ASVmeans)))
  
  print("Sample summary")
  print(SampleSums %>% 
    dplyr::filter(ASV %in% Core$ASV) %>%
    dplyr::select(-ASV) %>%
    colSums() %>%
    summary())
  
  print(paste("sd", sd(SampleSums %>% 
    dplyr::filter(ASV %in% Core$ASV) %>%
    dplyr::select(-ASV) %>%
    colSums())))
  
    print("rel ASVmeans per Phylum in Core")
    print(
      Core %>%
        dplyr::mutate(total_sum_ASVmeans = sum(ASVmeans, na.rm = TRUE)) %>%
        dplyr::group_by(Phylum) %>%
        dplyr::mutate(sum_ASVmeans = sum(ASVmeans, na.rm = TRUE)) %>%
        dplyr::summarize(rel_ASVmeans = round(sum(sum_ASVmeans) / sum(total_sum_ASVmeans) * 100,
                                              digits=2))%>%
        dplyr::arrange(desc(rel_ASVmeans)) %>% 
        as.data.frame()
      )
    
    print("rel ASVmeans per Order in Core")
    print(
      Core %>%
        dplyr::mutate(total_sum_ASVmeans = sum(ASVmeans, na.rm = TRUE)) %>%
        dplyr::group_by(Order) %>%
        dplyr::mutate(sum_ASVmeans = sum(ASVmeans, na.rm = TRUE)) %>%
        dplyr::summarize(rel_ASVmeans = round(sum(sum_ASVmeans) / sum(total_sum_ASVmeans) * 100,
                                              digits=2))%>%
        dplyr::arrange(desc(rel_ASVmeans)) %>% 
        as.data.frame()
      )
  
  
    print("rel ASVmeans per Taxon in Core")
    print(
      Core %>%
        dplyr::mutate(Taxon = gsub("ASV\\d+:", "", ASV)) %>%
        dplyr::group_by(Taxon) %>%
        dplyr::summarize(Taxon_means = sum(ASVmeans))  %>%
        dplyr::arrange(desc(Taxon_means)) %>% 
        as.data.frame()
      )
    
  ######################
  #Module genes in Core#
  ######################
  print(paste("ME Taxa", length(Core_ME_dat[[paste("ME", Core_ME,
                                sep="")]])))
  length((Core$ASV %in% Core_ME_dat$ASV))

  print(paste(round(length(Core[Core$ASV %in% Core_ME_dat$ASV,]$ASV)/ length(Core$ASV) *100, digits=2),"% Core ASVs in Module", Datasetname, Core_ME))
  
  print(paste("Relative Abundance of", Datasetname, "Core Taxa in", Datasetname, Core_ME))
  print(sum(Core[Core$ASV %in% Core_ME_dat$ASV,]$ASVmeans)/sum(Core$ASVmeans)*100)
  
  print(paste("Relative Abundance of", Datasetname, Core_ME,  "in Core Taxa in", Datasetname))
  print(sum(Core_ME_dat[Core_ME_dat$ASV %in% Core$ASV,]$ASVmeans)/sum(Core_ME_dat$ASVmeans))

  print("-")
  
  
  #####################
  #Core in Waterfilter#
  #####################
    WF_ASVmeans <- pslist$ps_WF %>%
      transform_sample_counts(function(x) {x/sum(x)*100}) %>%
      phyloseq::otu_table() %>%
      t() %>%
      as.data.frame() %>%
            dplyr::mutate(ASVmeans = rowMeans(.)) %>%
            dplyr::mutate(ASV = rownames(.)) %>% 
            dplyr::select(ASV, ASVmeans)
  
  print(paste("Amount of Taxa shared in Core and Bacterioplankton"))
  print(sum(Core$ASV %in% rownames(t(otu_table(pslist$ps_WF)))/length(Core$ASV))*100)
  
  print(paste("Relative Abundance of", Datasetname, "Core Taxa in",  "in Bacterioplankton"))
  print(sum(WF_ASVmeans[WF_ASVmeans$ASV %in% Core$ASV,]$ASVmeans))

  print(paste("Relative Abundance of", Datasetname,  Core_ME,  "in Bacterioplankton"))
  print(sum(WF_ASVmeans[WF_ASVmeans$ASV %in% Core_ME_dat$ASV,]$ASVmeans))
  

  #In section Bacterioplankton vs Fish 
  
 #  #################################
 #  #Overlapping Taxa betweem biomes#
 #  #################################
 #  Overlapping  <- as.data.frame(Overlapping_Taxa) %>%
 #    `colnames<-`("ASV") %>%
 #            left_join( #Add relative ASVmeans 
 #            data.frame(t(phyloseq::otu_table(ps %>%
 #            transform_sample_counts(function(x) {x/sum(x)*100})))) %>%
 #            dplyr::mutate(ASVmeans = rowMeans(.)) %>%
 #            dplyr::mutate(ASV = rownames(.)) %>% 
 #            dplyr::select(ASV, ASVmeans)) 
 # print(paste("Relative Abundance of Overlapping taxa between biomes in", Datasetname))
 # print(sum(Overlapping$ASVmeans))
 #   
 #        print(paste("Relative Abundance of Overlapping taxa between biomes in Bacterioplankton"))
 #  print(sum(WF_ASVmeans[WF_ASVmeans$ASV %in%Overlapping_Taxa,]$ASVmeans))
 # 
 #    
 #  
 #   RepsSums[RepsSums$ASV %in% Overlapping$ASV,] %>% 
 #    dplyr::summarize(across(starts_with("avg_"), sum, na.rm = TRUE))%>% 
 #    as.data.frame()
  
  
}


##############################
#Sums for modules of interest#
##############################
for (Datasetname in names(WGCNA_list)[grepl("OE|GC", names(WGCNA_list))]) {
  #Datasetname <- sub("ps_","", Dataset)
  
  ps <- pslist[[paste("ps", Datasetname, sep="_")]]
  
  if (Datasetname == "OE") {
    Interest_ME <- "0"
  } else if (Datasetname == "GC") {
    Interest_ME <- "7"
  }
    
  SampleSums <- ps %>%
      transform_sample_counts(function(x) {x/sum(x)*100}) %>%
      phyloseq::otu_table() %>%
      as.data.frame() %>%
      rownames_to_column(var = "SampleID") %>%
      dplyr::left_join(SAMDF16S, by = c("SampleID" = "SampleID")) %>%
      dplyr::group_by(SampleID) %>%
      dplyr::summarise(dplyr::across(rownames(tax_table(ps)), mean, na.rm = TRUE)) %>% 
      t() %>%
      as.data.frame() %>%
      `colnames<-`(.[1, ]) %>%
      .[-1, ] %>%
      stats::setNames(paste0("avg_", colnames(.))) %>%
      mutate_all(as.numeric) %>%
      round(., digits = 2) %>%
      rownames_to_column(var="ASV")
  
   SeasonSums <- ps %>%
      transform_sample_counts(function(x) {x/sum(x)*100}) %>%
      phyloseq::otu_table() %>%
      as.data.frame() %>%
      rownames_to_column(var = "SampleID") %>%
      dplyr::left_join(SAMDF16S, by = c("SampleID" = "SampleID")) %>%
      dplyr::group_by(Season) %>%
      dplyr::summarise(dplyr::across(rownames(tax_table(ps)), mean, na.rm = TRUE)) %>% 
      t() %>%
      as.data.frame() %>%
      `colnames<-`(.[1, ]) %>%
      .[-1, ] %>%
      stats::setNames(paste0("avg_", colnames(.))) %>%
      mutate_all(as.numeric) %>%
      round(., digits = 2) %>%
      rownames_to_column(var="ASV")
   
   RepsSums <- ps %>%
      transform_sample_counts(function(x) {x/sum(x)*100}) %>%
      phyloseq::otu_table() %>%
      as.data.frame() %>%
      rownames_to_column(var = "SampleID") %>%
      dplyr::left_join(SAMDF16S, by = c("SampleID" = "SampleID")) %>%
      dplyr::group_by(Replicates) %>%
      dplyr::summarise(dplyr::across(rownames(tax_table(ps)), mean, na.rm = TRUE)) %>% 
      t() %>%
      as.data.frame() %>%
      `colnames<-`(.[1, ]) %>%
      .[-1, ] %>%
      stats::setNames(paste0("avg_", colnames(.))) %>%
      mutate_all(as.numeric) %>%
      round(., digits = 2) %>%
      rownames_to_column(var="ASV")
   
  ################################################
  Interest_ME_dat <- WGCNA_list[[Datasetname]]$SSUWGCNAlist[[paste("SSU", Interest_ME,
                                sep="")]]
  
   print("Seasonal")
   print(SeasonSums  %>%
      dplyr::filter(ASV %in% Interest_ME_dat$ASV) %>%
      dplyr::select(-ASV) %>%
      colSums() %>%
      as.data.frame()
   )
    print("Replicates")
    print(
    RepsSums  %>%
      dplyr::filter(ASV %in% Interest_ME_dat$ASV) %>%
      dplyr::select(-ASV) %>%
      colSums() %>%
      as.data.frame()
    )
    
  
    print("rel ASVmeans per Order in Core")
    print(
      head(Interest_ME_dat %>%
        dplyr::mutate(total_sum_ASVmeans = sum(ASVmeans, na.rm = TRUE)) %>%
        dplyr::group_by(ASV) %>%
        dplyr::mutate(sum_ASVmeans = sum(ASVmeans, na.rm = TRUE)) %>%
        dplyr::summarize(rel_ASVmeans = round(sum(sum_ASVmeans) / sum(total_sum_ASVmeans) * 100,
                                              digits=2))%>%
        dplyr::arrange(desc(rel_ASVmeans)) %>% 
        as.data.frame() %>% 
        left_join(Interest_ME_dat[c("Phylum", "Class", "Order", "Family", "Genus", "Species", "ASV")])
      ))
    
      print("rel ASVmeans per Genus in Core")
      print(
        head(Interest_ME_dat %>%
        dplyr::mutate(total_sum_ASVmeans = sum(ASVmeans, na.rm = TRUE)) %>%
        dplyr::group_by(Genus) %>%
        dplyr::mutate(sum_ASVmeans = sum(ASVmeans, na.rm = TRUE)) %>%
        dplyr::summarize(rel_ASVmeans = round(sum(sum_ASVmeans) / sum(total_sum_ASVmeans) * 100,
                                              digits=2))%>%
        dplyr::arrange(desc(rel_ASVmeans)) %>% 
        as.data.frame() 
      ))
    
    
  #####################
  #Interest in Waterfilter#
  #####################
    WF_ASVmeans <- pslist$ps_WF %>%
      transform_sample_counts(function(x) {x/sum(x)*100}) %>%
      phyloseq::otu_table() %>%
      t() %>%
      as.data.frame() %>%
            dplyr::mutate(ASVmeans = rowMeans(.)) %>%
            dplyr::mutate(ASV = rownames(.)) %>% 
            dplyr::select(ASV, ASVmeans)
  
  print(paste("Amount of Taxa shared", Datasetname, Interest_ME,  "and Bacterioplankton"))
  print(sum(Interest_ME_dat$ASV %in% rownames(t(otu_table(pslist$ps_WF)))/length(Interest_ME_dat$ASV ))*100)
  
  print(paste("Relative Abundance of", Datasetname, Interest_ME,  "in Bacterioplankton"))
  print(sum(WF_ASVmeans[WF_ASVmeans$ASV %in% Interest_ME_dat$ASV,]$ASVmeans))


}




sum(rownames(WGCNA_list[["GC"]]$SSUWGCNAlist[[paste("SSU", 8,
                                sep="")]]) %in% 
rownames(WGCNA_list[["OE"]]$SSUWGCNAlist[[paste("SSU", 6,
                                sep="")]]))/length(rownames(WGCNA_list[["GC"]]$SSUWGCNAlist[[paste("SSU", 8,
                                sep="")]]) )*100

```

### 9.3.6  Barplot Specific Taxa 

```{r,  message=FALSE,warning=FALSE}
colored_taxonomy_Fish <- pslist$Optics$colored_taxonomy_Fish

##############
#Network CORE#
##############
TaxLevel <- "ASV"
flipped <- T
for (Dataset in names(pslist)[grepl("ps_GCWF|ps_OEWF", names(pslist))]) {

  require(plyr); require(dplyr); require(ggrepel); require(cowplot); require(phyloseq)

    Datasetname <- sub("ps_", "", Dataset)


    # GroupOfInterest_OE <- na.omit(unique(WGCNA_list[["OE"]]$SSUWGCNAlist[["SSU7"]]$ASV))
    # GroupOfInterest_GC <- na.omit(unique(WGCNA_list[["GC"]]$SSUWGCNAlist[["SSU2"]]$ASV))
    # print(paste(sum(GroupOfInterest_OE %in% GroupOfInterest_GC)/length(GroupOfInterest_OE)*100, "% of OE Module SSU7 are in GC Module SSU2"))
    #
    # GroupOfInterest <- c(GroupOfInterest_OE, GroupOfInterest_GC)
    # #GroupOfInterest <- sub(".*:", "", GroupOfInterest)
    # GroupOfInterest <-unique(GroupOfInterest)

    if (grepl("GC", Datasetname)) {
      MODULE <- "SSU8"
    } else if (grepl("OE", Datasetname)) {
      MODULE <- "SSU6"
    }

    ps <- pslist[[Dataset]]

    GroupOfInterest <- na.omit(unique(WGCNA_list[[sub("WF", "",
                                                      Datasetname)]]$SSUWGCNAlist[[MODULE]]$ASV))


    FILENAME    <- paste(paste(save_name, "Alpha_BarPlot_WF", MODULE, Datasetname,  sep="_"), ".png", sep="")

    if (Datasetname %in% c("GC", "OE")) {
      WIDTH <- 10 + length(sample_names(pslist[[Dataset]])) *0.12
      HEIGHT <- 10 #length(sample_names(pslist[[Dataset]])) *0.08
    } else if (Datasetname %in% c("WF")) {
      WIDTH <-  5 + length(sample_names(pslist[[Dataset]])) *0.12
       HEIGHT <- 10 #length(sample_names(pslist[[Dataset]])) *0.08
    } else {
     WIDTH <-  10 + length(sample_names(pslist[[Dataset]])) *0.12
      HEIGHT <- 10 #length(sample_names(pslist[[Dataset]])) *0.08
    }


    ################################
    #Create Relative Abundance Data#
    ################################
    ps_alpha_barplot <- ps %>%
    #tax_glom(taxrank =  TaxLevel)   %>%
    transform_sample_counts(function(x) {x/sum(x)*100}) %>% # Transform to rel. abundance
    psmelt() %>%                                         # Melt to long format
    #filter(Abundance > 1) %>%                       # Filter out low abundance taxa
    arrange(Genus)        %>%                                # Sort data frame alphabetically by phylum
    dplyr::arrange(desc(Abundance))


    ps_alpha_barplot$ASV <- sub(".*:", "", ps_alpha_barplot$OTU)
    #ps_alpha_barplot$ASV <- sub('\\.', ' ', ps_alpha_barplot$ASV)

    ############################
    #Create TotalAbundance Data#
    ############################
    # phylum_abundance <- ps_alpha_barplot %>%
    #   dplyr::group_by(.data[[TaxLevel]]) %>%
    #   dplyr::summarise(TotalAbundance = sum(Abundance))
    # ordered_levels <- phylum_abundance %>%
    #   dplyr::arrange(desc(TotalAbundance)) %>%
    #   pull(.data[[TaxLevel]])
    #
    # ps_alpha_barplot$Taxa <- factor(ps_alpha_barplot[[TaxLevel]], levels = ordered_levels)

    ps_alpha_barplot$SampleID <- factor(ps_alpha_barplot$SampleID, levels =
                                          SSU_Samples[SSU_Samples %in% sample_names(pslist[[Dataset]])])


    SSU_Samples[SSU_Samples %in% sample_names(pslist[[Dataset]])]

    ##########################
    #Subset for Interest ASVs#
    ##########################
    df <- ps_alpha_barplot #[ps_alpha_barplot$OTU %in% GroupOfInterest,]
    #df <- df[df$OTU %in% GroupOfInterest,]
    df$Abundance[!(df$OTU %in% GroupOfInterest)] <- 0

    phylum_abundance <- df %>%
      dplyr::group_by(.data[[TaxLevel]]) %>%
      dplyr::summarise(TotalAbundance = sum(Abundance))
    ordered_levels <- phylum_abundance %>%
      dplyr::arrange(desc(TotalAbundance)) %>%
      pull(.data[[TaxLevel]])

    df$Taxa <- factor(df[[TaxLevel]], levels = ordered_levels)

    Alpha_Diversity_df <- df
    Alpha_Diversity_df$Colors <- NA
    Alpha_Diversity_df$Reps <-  factor(Alpha_Diversity_df$Reps, levels = RepOrder[RepOrder %in% Alpha_Diversity_df$Reps])

    #################################
    #Update to colored_taxonomy_Fish#
    #################################

    taxa_levels <- c("Genus", "Family", "Order", "Class", "Phylum")
    taxa_level2 <- c("Taxa", "Phylum2")

    Alpha_Diversity_df$Color <- "grey"

  # Loop through each row of Alpha_Diversity_df
  for (i in 1:nrow(Alpha_Diversity_df)) {
    matching_color <- NA  # Initialize matching color to NA
    # Loop through each taxonomic level
    for (level in taxa_levels) {
    matching_row <- colored_taxonomy_Fish[colored_taxonomy_Fish$Taxa %in%
                                            Alpha_Diversity_df[[level]][i], ]
    # If there's a match, update matching_color and exit the loop
    if (nrow(matching_row) > 0) {
      matching_color <- matching_row$Color
      break
    }
  }
  # If there's no match at any level, try matching without numbers
  if (is.na(matching_color)) {
    matching_row <- colored_taxonomy_Fish[gsub("\\d", "", colored_taxonomy_Fish$Phylum2) %in%
                                            Alpha_Diversity_df[["Phylum"]][i], ]
    if (nrow(matching_row) > 0) {
      matching_color <- matching_row$Color
    }
  }
  # Assign the matching color to the corresponding row in Alpha_Diversity_df
  Alpha_Diversity_df$Color[i] <- matching_color
  }

    color_mapping <- setNames(Alpha_Diversity_df$Color, Alpha_Diversity_df$Taxa)
    color_mapping[["Candidatus Megaira"]] <- "purple"
    color_mapping[["Acinetobacter.lwoffii"]] <- "#996600"
    color_mapping[["Acinetobacter.johnsonii"]] <- "#663300"
    color_mapping[["Shewanella"]] <- "#FF3366"
    color_mapping[["Shewanella.baltica"]] <- "#FF0099"
    color_mapping[["Shewanella.putrefaciens"]] <-"#FF0066"
    color_mapping[["Photobacterium"]] <- "#FFF000"
    color_mapping[["Aeromonas"]] <- "#FFCC00"


    levels(Alpha_Diversity_df$Taxa)[!levels(Alpha_Diversity_df$Taxa) %in% head(unique(sub(".*:", "", GroupOfInterest)), 34)  ] <-
      "Other"

    if (flipped == FALSE) {
      if (Datasetname == "WF") {
        p <- ggplot(Alpha_Diversity_df,
          aes(x = SampleID, y = Abundance, fill = factor(Taxa))) +
          geom_bar(stat = "identity") +
          facet_grid(. ~ factor(Season, levels = SeasonOrder), drop = TRUE, scale = "free",
                     space = "free_x")
        COL <- col.Palette$col.Palette.Season[names(col.Palette$col.Palette.Season) %in%
                                              unique(sample_data(ps)$Season)]
      } else {
       p <- ggplot(Alpha_Diversity_df,
        aes(x = SampleID, y = Abundance, fill = factor(Taxa))) +
        geom_bar(stat = "identity") +
        facet_grid(. ~ factor(Reps, levels = RepOrder), drop = TRUE, scale = "free", space = "free_y")
      COL <- col.Palette$col.Palette.Reps[names(col.Palette$col.Palette.Reps) %in%                                    unique(sample_data(ps)$Reps)]
      }
      p <- p +
        atheme +
        ylab("Relative Abundance [%] \n") + xlab("") +
        labs(fill="") +
        scale_fill_manual(values = color_mapping) +
        ylim(0, 60) +

        #ggrepel::geom_text_repel(x = df$SampleID, y = df$Abundance,  aes(label = Labels),
        #inherit.aes = FALSE, min.segment.length = 0,nudge_y = 20,size=3, max.overlaps = Inf) +
      #awhite +
        theme(strip.text.y = element_text(angle = 0))  +
        #theme(axis.text.x=element_blank(),
        #axis.text.y=element_blank(),
        #axis.title.y.left = element_blank(),
        #axis.ticks.y =element_blank()
        #) +
        theme(
         panel.background = element_rect(fill='transparent'), #transparent panel bg
         plot.background = element_rect(fill='transparent', color=NA), #transparent plot bg
         #legend.background = element_rect(fill='transparent'), #transparent legend bg
         #legend.box.background = element_rect(fill='transparent') #transparent legend panel
         ) +
      theme(axis.title.x.bottom =  element_text(color="grey13"),
        strip.text = element_text(color = "black", face= "bold")) +
      theme(
        legend.title=element_text(size=9),
        legend.text=element_text(size=9),
        axis.text.x.bottom = element_text(size= 9, face = "bold", angle = 45, hjust = 1),
        strip.text.y.left = element_text(size = 9,face = "bold"),
        axis.title.y.left = element_text(size=12,face = "bold"))

      g <- ggplot_gtable(ggplot_build(p))
        stripr <- which(grepl('strip-t', g$layout$name))
        fills <- alpha(COL, 0.8)
        k <- 1
        for (iii in stripr) {
        j <- which(grepl('rect', g$grobs[[iii]]$grobs[[1]]$childrenOrder))
        g$grobs[[iii]]$grobs[[1]]$children[[j]]$gp$fill <- fills[k]
        k <- k+1}

        Alpha_Diversity_BarPlot <- cowplot::plot_grid(g, labels = c(""), ncol = 1)
        Alpha_Diversity_BarPlot <- plot_grid(Alpha_Diversity_BarPlot, ncol = 1, rel_heights = c(100))
        ggsave(Alpha_Diversity_BarPlot, filename = FILENAME, path = pathPlots, device='png', dpi=300,
               width = WIDTH, height = 6)

    } else if (flipped == TRUE) {
      # New facet label names for supp variable

      COL <- col.Palette$col.Palette.Reps[names(col.Palette$col.Palette.Reps) %in%                                    unique(sample_data(ps)$Reps)]

      Short.labs <- gsub("[^0-9]", "", Alpha_Diversity_df$Reps)
      names(Short.labs) <- Alpha_Diversity_df$Reps


      p <- ggplot(Alpha_Diversity_df, aes(x = SampleID, y = Abundance, fill = factor(Taxa))) +
            geom_bar(stat = "identity") +
            coord_flip() +
            #facet_grid(rows = vars(Reps), drop = TRUE, scale = "free", space = "free_x", switch = "y")
        facet_grid(rows = vars(Reps), drop = TRUE, scale = "free", space = "free_x", switch = "y",
              labeller = labeller(Reps = Short.labs))

      p <- p +
        ylab("Relative Abundance [%] \n") + xlab("") +
        labs(fill="") + #atheme+
        scale_fill_manual(values = color_mapping) +
        ylim(0, 60) +
            theme(axis.title.y=element_blank(),
            axis.text.y=element_blank(),
            axis.ticks.y=element_blank()) +
        theme(
         panel.background = element_rect(fill='transparent'), #transparent panel bg
         plot.background = element_rect(fill='transparent', color=NA), #transparent plot bg
         ) +
      theme(axis.title.x.bottom =  element_text(color="grey13", size=15, face ="bold"),
        strip.text = element_text(color = "black", face= "bold")) +
      theme(
        legend.title=element_text(size=9),
        legend.text=element_text(size=9),
        axis.text.x.bottom = element_text(size= 15, face = "bold", angle = 45, hjust = 1),
        #strip.text.y.left = element_text(size = 9,face = "bold"),
        #axis.title.y.left = element_text(size=12,face = "bold")
        ) +
        theme(legend.position = "none")

      g <- ggplot_gtable(ggplot_build(p))
        stripr <- which(grepl('strip-l', g$layout$name))
        fills <- alpha(COL, 0.8)
        k <- 1
        for (iii in stripr) {
        j <- which(grepl('rect', g$grobs[[iii]]$grobs[[1]]$childrenOrder))
        g$grobs[[iii]]$grobs[[1]]$children[[j]]$gp$fill <- fills[k]
        k <- k+1}

    Alpha_Diversity_BarPlot <- cowplot::plot_grid(g, labels = c(""), ncol = 1)
    Alpha_Diversity_BarPlot <- plot_grid(Alpha_Diversity_BarPlot, ncol = 1, rel_heights = c(100))
    ggsave(Alpha_Diversity_BarPlot, filename = FILENAME, path = pathPlots, device='png', dpi=300, width = 2.7, height = HEIGHT)

    }
}

##########
#Salinity#
##########
TaxLevel <- "ASV"
flipped <- T
for (Dataset in names(pslist)[grepl("ps_GCWF|ps_OEWF", names(pslist))]) {
  
  require(plyr); require(dplyr); require(ggrepel); require(cowplot); require(phyloseq)
     
    Datasetname <- sub("ps_", "", Dataset)
    
  
    # GroupOfInterest_OE <- na.omit(unique(WGCNA_list[["OE"]]$SSUWGCNAlist[["SSU7"]]$ASV))
    # GroupOfInterest_GC <- na.omit(unique(WGCNA_list[["GC"]]$SSUWGCNAlist[["SSU2"]]$ASV))
    # print(paste(sum(GroupOfInterest_OE %in% GroupOfInterest_GC)/length(GroupOfInterest_OE)*100, "% of OE Module SSU7 are in GC Module SSU2"))
    # 
    # GroupOfInterest <- c(GroupOfInterest_OE, GroupOfInterest_GC)
    # #GroupOfInterest <- sub(".*:", "", GroupOfInterest)  
    # GroupOfInterest <-unique(GroupOfInterest)
    
    if (grepl("GC", Datasetname)) {
      MODULE <- "SSU7"
    } else if (grepl("OE", Datasetname)) {
      MODULE <- "SSU3"
    }
    
    ps <- pslist[[Dataset]] 
    
    GroupOfInterest <- na.omit(unique(WGCNA_list[[sub("WF", "", 
                                                      Datasetname)]]$SSUWGCNAlist[[MODULE]]$ASV))
    

    FILENAME    <- paste(paste(save_name, "Alpha_BarPlot_WF", MODULE, Datasetname,  sep="_"), ".png", sep="")
    
    if (Datasetname %in% c("GC", "OE")) {
      WIDTH <- 10 + length(sample_names(pslist[[Dataset]])) *0.12
      HEIGHT <- 10 #length(sample_names(pslist[[Dataset]])) *0.08
    } else if (Datasetname %in% c("WF")) {
      WIDTH <-  5 + length(sample_names(pslist[[Dataset]])) *0.12
       HEIGHT <- 10 #length(sample_names(pslist[[Dataset]])) *0.08
    } else {
     WIDTH <-  10 + length(sample_names(pslist[[Dataset]])) *0.12
      HEIGHT <- 10 #length(sample_names(pslist[[Dataset]])) *0.08
    }
    
  
    ################################
    #Create Relative Abundance Data#
    ################################
    ps_alpha_barplot <- ps %>%
    #tax_glom(taxrank =  TaxLevel)   %>%  
    transform_sample_counts(function(x) {x/sum(x)*100}) %>% # Transform to rel. abundance
    psmelt() %>%                                         # Melt to long format
    #filter(Abundance > 1) %>%                       # Filter out low abundance taxa
    arrange(Genus)        %>%                                # Sort data frame alphabetically by phylum
    dplyr::arrange(desc(Abundance))
 
  
    ps_alpha_barplot$ASV <- sub(".*:", "", ps_alpha_barplot$OTU)  
    #ps_alpha_barplot$ASV <- sub('\\.', ' ', ps_alpha_barplot$ASV)
    
    ############################
    #Create TotalAbundance Data#
    ############################
    # phylum_abundance <- ps_alpha_barplot %>%
    #   dplyr::group_by(.data[[TaxLevel]]) %>%
    #   dplyr::summarise(TotalAbundance = sum(Abundance))
    # ordered_levels <- phylum_abundance %>%
    #   dplyr::arrange(desc(TotalAbundance)) %>%
    #   pull(.data[[TaxLevel]])
    #   
    # ps_alpha_barplot$Taxa <- factor(ps_alpha_barplot[[TaxLevel]], levels = ordered_levels)

    ps_alpha_barplot$SampleID <- factor(ps_alpha_barplot$SampleID, levels = 
                                          SSU_Samples[SSU_Samples %in% sample_names(pslist[[Dataset]])])
  
    
    SSU_Samples[SSU_Samples %in% sample_names(pslist[[Dataset]])]
    
    ##########################
    #Subset for Interest ASVs#
    ##########################
    df <- ps_alpha_barplot #[ps_alpha_barplot$OTU %in% GroupOfInterest,]
    #df <- df[df$OTU %in% GroupOfInterest,]
    df$Abundance[!(df$OTU %in% GroupOfInterest)] <- 0
    
    phylum_abundance <- df %>%
      dplyr::group_by(.data[[TaxLevel]]) %>%
      dplyr::summarise(TotalAbundance = sum(Abundance))
    ordered_levels <- phylum_abundance %>%
      dplyr::arrange(desc(TotalAbundance)) %>%
      pull(.data[[TaxLevel]])
      
    df$Taxa <- factor(df[[TaxLevel]], levels = ordered_levels)
    
    Alpha_Diversity_df <- df
    Alpha_Diversity_df$Colors <- NA
    Alpha_Diversity_df$Reps <-  factor(Alpha_Diversity_df$Reps, levels = RepOrder[RepOrder %in% Alpha_Diversity_df$Reps])
    
    #################################
    #Update to colored_taxonomy_Fish#
    #################################

    taxa_levels <- c("Genus", "Family", "Order", "Class", "Phylum")
    taxa_level2 <- c("Taxa", "Phylum2")

    Alpha_Diversity_df$Color <- "grey"

  # Loop through each row of Alpha_Diversity_df
  for (i in 1:nrow(Alpha_Diversity_df)) {
    matching_color <- NA  # Initialize matching color to NA
    # Loop through each taxonomic level
    for (level in taxa_levels) {
    matching_row <- colored_taxonomy_Fish[colored_taxonomy_Fish$Taxa %in%
                                            Alpha_Diversity_df[[level]][i], ]
    # If there's a match, update matching_color and exit the loop
    if (nrow(matching_row) > 0) {
      matching_color <- matching_row$Color
      break
    }
  }
  # If there's no match at any level, try matching without numbers
  if (is.na(matching_color)) {
    matching_row <- colored_taxonomy_Fish[gsub("\\d", "", colored_taxonomy_Fish$Phylum2) %in%
                                            Alpha_Diversity_df[["Phylum"]][i], ]
    if (nrow(matching_row) > 0) {
      matching_color <- matching_row$Color
    }
  }
  # Assign the matching color to the corresponding row in Alpha_Diversity_df
  Alpha_Diversity_df$Color[i] <- matching_color
  }
    
    color_mapping <- setNames(Alpha_Diversity_df$Color, Alpha_Diversity_df$Taxa)
    color_mapping[["Candidatus Megaira"]] <- "purple"
    color_mapping[["Acinetobacter.lwoffii"]] <- "#996600"
    color_mapping[["Acinetobacter.johnsonii"]] <- "#663300"
    color_mapping[["Shewanella"]] <- "#FF3366"
    color_mapping[["Shewanella.baltica"]] <- "#FF0099"
    color_mapping[["Shewanella.putrefaciens"]] <-"#FF0066"
    color_mapping[["Photobacterium"]] <- "#FFF000"
    color_mapping[["Aeromonas"]] <- "#FFCC00"
    

    levels(Alpha_Diversity_df$Taxa)[!levels(Alpha_Diversity_df$Taxa) %in% head(unique(sub(".*:", "", GroupOfInterest)), 34)  ] <-
      "Other"

    if (flipped == FALSE) {
      if (Datasetname == "WF") {
        p <- ggplot(Alpha_Diversity_df, 
          aes(x = SampleID, y = Abundance, fill = factor(Taxa))) + 
          geom_bar(stat = "identity") +
          facet_grid(. ~ factor(Season, levels = SeasonOrder), drop = TRUE, scale = "free", 
                     space = "free_x")
        COL <- col.Palette$col.Palette.Season[names(col.Palette$col.Palette.Season) %in%
                                              unique(sample_data(ps)$Season)]
      } else {
       p <- ggplot(Alpha_Diversity_df, 
        aes(x = SampleID, y = Abundance, fill = factor(Taxa))) + 
        geom_bar(stat = "identity") +
        facet_grid(. ~ factor(Reps, levels = RepOrder), drop = TRUE, scale = "free", space = "free_y")
      COL <- col.Palette$col.Palette.Reps[names(col.Palette$col.Palette.Reps) %in%                                    unique(sample_data(ps)$Reps)]
      }
      p <- p + 
        atheme +
        ylab("Relative Abundance [%] \n") + xlab("") + 
        labs(fill="") +
        scale_fill_manual(values = color_mapping) +
        ylim(0, 60) +
  
        #ggrepel::geom_text_repel(x = df$SampleID, y = df$Abundance,  aes(label = Labels),
        #inherit.aes = FALSE, min.segment.length = 0,nudge_y = 20,size=3, max.overlaps = Inf) +
      #awhite + 
        theme(strip.text.y = element_text(angle = 0))  +
        #theme(axis.text.x=element_blank(),
        #axis.text.y=element_blank(),
        #axis.title.y.left = element_blank(),
        #axis.ticks.y =element_blank() 
        #) +
        theme(
         panel.background = element_rect(fill='transparent'), #transparent panel bg
         plot.background = element_rect(fill='transparent', color=NA), #transparent plot bg
         #legend.background = element_rect(fill='transparent'), #transparent legend bg
         #legend.box.background = element_rect(fill='transparent') #transparent legend panel
         ) +
      theme(axis.title.x.bottom =  element_text(color="grey13"), 
        strip.text = element_text(color = "black", face= "bold")) +
      theme(
        legend.title=element_text(size=9), 
        legend.text=element_text(size=9), 
        axis.text.x.bottom = element_text(size= 9, face = "bold", angle = 45, hjust = 1),
        strip.text.y.left = element_text(size = 9,face = "bold"), 
        axis.title.y.left = element_text(size=12,face = "bold"))
      
      g <- ggplot_gtable(ggplot_build(p))
        stripr <- which(grepl('strip-t', g$layout$name))
        fills <- alpha(COL, 0.8)
        k <- 1
        for (iii in stripr) {
        j <- which(grepl('rect', g$grobs[[iii]]$grobs[[1]]$childrenOrder))
        g$grobs[[iii]]$grobs[[1]]$children[[j]]$gp$fill <- fills[k]
        k <- k+1}
    
        Alpha_Diversity_BarPlot <- cowplot::plot_grid(g, labels = c(""), ncol = 1)
        Alpha_Diversity_BarPlot <- plot_grid(Alpha_Diversity_BarPlot, ncol = 1, rel_heights = c(100))
        ggsave(Alpha_Diversity_BarPlot, filename = FILENAME, path = pathPlots, device='png', dpi=300,
               width = WIDTH, height = 6)
        
    } else if (flipped == TRUE) {
      # New facet label names for supp variable
    
      COL <- col.Palette$col.Palette.Reps[names(col.Palette$col.Palette.Reps) %in%                                    unique(sample_data(ps)$Reps)]
      
      Short.labs <- gsub("[^0-9]", "", Alpha_Diversity_df$Reps)
      names(Short.labs) <- Alpha_Diversity_df$Reps

      
      p <- ggplot(Alpha_Diversity_df, aes(x = SampleID, y = Abundance, fill = factor(Taxa))) + 
            geom_bar(stat = "identity") +
            coord_flip() +
            #facet_grid(rows = vars(Reps), drop = TRUE, scale = "free", space = "free_x", switch = "y")
        facet_grid(rows = vars(Reps), drop = TRUE, scale = "free", space = "free_x", switch = "y", 
              labeller = labeller(Reps = Short.labs)) 
      
      p <- p + 
        ylab("Relative Abundance [%] \n") + xlab("") + 
        labs(fill="") + #atheme+
        scale_fill_manual(values = color_mapping) +
        ylim(0, 60) +
            theme(axis.title.y=element_blank(),
            axis.text.y=element_blank(),
            axis.ticks.y=element_blank()) +
        theme(
         panel.background = element_rect(fill='transparent'), #transparent panel bg
         plot.background = element_rect(fill='transparent', color=NA), #transparent plot bg
         ) +
      theme(axis.title.x.bottom =  element_text(color="grey13", size=15, face ="bold"), 
        strip.text = element_text(color = "black", face= "bold")) +
      theme(
        legend.title=element_text(size=9), 
        legend.text=element_text(size=9), 
        axis.text.x.bottom = element_text(size= 15, face = "bold", angle = 45, hjust = 1),
        #strip.text.y.left = element_text(size = 9,face = "bold"), 
        #axis.title.y.left = element_text(size=12,face = "bold")
        ) +
        theme(legend.position = "none")
      
      g <- ggplot_gtable(ggplot_build(p))
        stripr <- which(grepl('strip-l', g$layout$name))
        fills <- alpha(COL, 0.8)
        k <- 1
        for (iii in stripr) {
        j <- which(grepl('rect', g$grobs[[iii]]$grobs[[1]]$childrenOrder))
        g$grobs[[iii]]$grobs[[1]]$children[[j]]$gp$fill <- fills[k]
        k <- k+1}
        
    Alpha_Diversity_BarPlot <- cowplot::plot_grid(g, labels = c(""), ncol = 1)
    Alpha_Diversity_BarPlot <- plot_grid(Alpha_Diversity_BarPlot, ncol = 1, rel_heights = c(100))
    ggsave(Alpha_Diversity_BarPlot, filename = FILENAME, path = pathPlots, device='png', dpi=300, width = 2.7, height = HEIGHT)
    
    }
}

```


#-

## 9.4 WGCNA Cytoscape

Excluded for knitting, works fine, just un-# the whole chunk

```{r,  message=FALSE,warning=FALSE }
# #You need to download and Open Cytoscape on your computer for this to work 
# #http://www.bioconductor.org/packages/devel/bioc/vignettes/rWikiPathways/inst/doc/Pathway-Analysis.html
# #https://yulab-smu.top/biomedical-knowledge-mining-book/clusterprofiler-go.html
# library(tidyverse)
# library(dplyr)
# library(plyr)
# library(clusterProfiler)
# library(enrichplot)
# library(ggplot2)
# library("org.Hs.eg.db")
# library("org.Dr.eg.db")
# library("org.Mm.eg.db")
# library(DOSE)
# library(rWikiPathways)
# library(jsonlite)
# library("DOSE")
# library("GO.db")
# library("GSEABase")
# library("dplyr")
# library("tidyr")
# library("stringr")
# library("RColorBrewer")
# library("rWikiPathways")
# library("RCy3")
# 
# ###########
# #Cytoscape#
# ###########
# #list of cytoscape apps to install
# #Open Cytoscape
#  cytoscapePing()
# # #list of app to install Do that once!
# # installApp('WikiPathways')
# # installApp('CyTargetLinker')
# # installApp('stringApp')
# # installApp('enrichmentMap')
# # installApp('autoannotate')
# # installApp('wordcloud')
# # installApp('stringapp')
# # installApp('aMatReader')
# # installApp('clustermaker2')
# # cytoscapeVersionInfo ()
# # installApp('STRINGapp')
# # installApp('aMatReader')
# # installApp('clusterMaker2')
# # The following setting is important, do not omit.
# library(WGCNA)
# options(stringsAsFactors = FALSE);
# for (Datasetname  in names(WGCNA_list)) {
#   
#   omics_data    <- WGCNA_list[[Datasetname]]$omics_data
#   datTraits     <- WGCNA_list[[Datasetname]]$datTraits
#   moduleLabels  <- WGCNA_list[[Datasetname]]$moduleLabels
#   moduleColors  <- WGCNA_list[[Datasetname]]$moduleColors
#   MEs           <- WGCNA_list[[Datasetname]]$MEs
#   network       <- WGCNA_list[[Datasetname]]$network
#   ps            <- WGCNA_list[[Datasetname]]$ps
#   softPower     <- WGCNA_list[[Datasetname]]$softPower
#   GeneAnno      <- WGCNA_list$WF$SSUWGCNAlist
#   TaxAnno       <- data.frame(tax_table(WGCNA_list$WF$ps)) %>% rownames_to_column(var="ASV")
#   
#   RepSums <- ps %>%
#       transform_sample_counts(function(x) {x/sum(x)*100}) %>%
#       phyloseq::otu_table() %>%
#       as.data.frame() %>%
#       rownames_to_column(var = "SampleID") %>%
#       dplyr::left_join(SAMDF16S, by = c("SampleID" = "SampleID")) %>%
#       dplyr::group_by(Replicates) %>%
#       dplyr::summarise(dplyr::across(rownames(tax_table(ps)), mean, na.rm = TRUE)) %>% 
#       t() %>%
#       as.data.frame() %>%
#       `colnames<-`(.[1, ]) %>%
#       .[-1, ] %>%
#       stats::setNames(paste0("avg_", colnames(.))) %>%
#       mutate_all(as.numeric) %>%
#       round(., digits = 2) %>%
#       rownames_to_column(var="ASV") 
#     
#     SeasonSums <- ps %>%
#       transform_sample_counts(function(x) {x/sum(x)*100}) %>%
#       phyloseq::otu_table() %>%
#       as.data.frame() %>%
#       rownames_to_column(var = "SampleID") %>%
#       dplyr::left_join(SAMDF16S, by = c("SampleID" = "SampleID")) %>%
#       dplyr::group_by(Season) %>%
#       dplyr::summarise(dplyr::across(rownames(tax_table(ps)), mean, na.rm = TRUE)) %>% 
#       t() %>%
#       as.data.frame() %>%
#       `colnames<-`(.[1, ]) %>%
#       .[-1, ] %>%
#       stats::setNames(paste0("avg_", colnames(.))) %>%
#       mutate_all(as.numeric) %>%
#       round(., digits = 2) %>%
#       rownames_to_column(var="ASV") 
#     
#   ############################################################################
#   #Create WGCNA Dataframe: Species, ModuleMembership, Correlation to Abiotics#
#   ############################################################################
#   for (i in names(MEs)) {
#      tryCatch({
#     
#     ModuleOfInterst <- paste(sub("ME", "", i))
#   
#     TOM = TOMsimilarityFromExpr(omics_data, power = softPower, nThreads =8);
#     modules = as.numeric(sub("ME", "", i))
# 
#     colors <- labels2colors(modules)
#     genes  <- names(omics_data)
#     inModule <- is.finite(match(moduleColors, colors));
#     ASV <- genes[inModule];
#     modColors <- moduleColors[inModule]
#     Data <- as.data.frame(cbind(ASV, modColors))
#   
#     Data  <- Data %>%  
#        left_join( #Add relative ASVmeans 
#        data.frame(t(phyloseq::otu_table(ps %>%
#         transform_sample_counts(function(x) {x/sum(x)*100})))) %>%
#           dplyr::mutate(ASVmeans = rowMeans(.)) %>%
#           dplyr::mutate(ASV = rownames(.)) %>% 
#           dplyr::select(ASV, ASVmeans)) %>% 
#       left_join(as.data.frame(tax_table(ps)) %>% rownames_to_column(var="ASV"))
#     
#       geneModuleMembership <- cor(omics_data, MEs, use = "p") %>%
#         as.data.frame() %>% #Create ModuleMembership 
#         dplyr::select(paste("ME", ModuleOfInterst, sep="")) %>%
#         setNames(paste0("MM"))  #No Individual naming here for Cytoscape columns beeing equal
#     
#       MMPvalue <- #Creating p.values for Module memberships
#         as.data.frame(corPvalueStudent(as.matrix(geneModuleMembership), length(rownames(MEs)))) %>%
#         dplyr::select(paste("MM", sep="")) %>%
#         setNames(paste0("p.MM")) 
#  
#      #setNames(paste0(sub("MM", "p.MM", names(.)), sep="")) %>%
#      #dplyr::select(paste("p.MM", sep=""))
# 
#     Data <- Data %>%
#        left_join(geneModuleMembership  %>% rownames_to_column(var="ASV")) %>%
#        left_join(MMPvalue  %>% rownames_to_column(var="ASV")) %>%
#        left_join(SeasonSums) %>%
#        left_join(RepSums)
#     #dplyr::arrange(desc(ASVmeans))
#     rownames(Data) <- Data$ASV
#     
#     Data$ASVname <- gsub("^ASV\\d+:", "", Data$ASV)
#     
#     
#     # Select the corresponding Topological Overlap
#     TOM_mod = TOM[inModule, inModule];
#     dimnames(TOM_mod) = list(Data$ASV, Data$ASV)
#     
#     #######################
#     #Filter for Parameters#
#     #######################
#     Data_filt <- Data %>% 
#             filter(abs(MM) > 0.5 & p.MM < 0.05 & ASVmeans > 0.005) 
#     TOM_filt <- TOM_mod[Data_filt$ASV, Data_filt$ASV]
#   # Export the network into edge and node list files Cytoscape can read
#   #https://support.bioconductor.org/p/95965/
#   # My operational answer is to select a threshold that keeps the file size manageable, then use     filtering in Cytoscape to interactively choose a threshold that results in an informative plot. This assumes that Cytoscape is only used for visualization; if you're going to use Cytoscape for further analysis, you should probably set the threshold to zero.
#   #https://www.biostars.org/p/9514423/
# 
#     cyt = exportNetworkToCytoscape(TOM_filt,
#     edgeFile =     paste(paste(file.path(path_Output_16S,"CytoscapeInput_ASV_edges"), paste(modules, Datasetname, sep="_"), sep="_"), "txt", sep ="."),
#     nodeFile =  paste(paste(file.path(path_Output_16S,"CytoscapeInput_ASV_nodes"), paste(modules, Datasetname, sep="_"), sep="_"), "txt", sep ="."),
#     weighted = TRUE,
#     threshold = 0.01, #Doing real Filtering in Cytoscape for Abundance
#     nodeNames = Data_filt$ASV,
#     altNodeNames = Data_filt$ASVname,
#     nodeAttr = Data_filt)
#   }, error=function(e){cat("ERROR :",conditionMessage(e), "\n")})}
# }
# 
# ###########
# #Cytoscape#
# ###########
# #list of cytoscape apps to install
# #Open Cytoscape
# cytoscapePing()
# ##############################
# #Import Networks to Cytoscape#
# ##############################
# library("RCy3")
# cytoscapePing () # make sure cytoscape is open
# cytoscapeVersionInfo ()
# for (Datasetname  in names(WGCNA_list)) {
#   
#   omics_data    <- WGCNA_list[[Datasetname]]$omics_data
#   datTraits     <- WGCNA_list[[Datasetname]]$datTraits
#   moduleLabels  <- WGCNA_list[[Datasetname]]$moduleLabels
#   moduleColors  <- WGCNA_list[[Datasetname]]$moduleColors
#   MEs           <- WGCNA_list[[Datasetname]]$MEs
# 
#   
#   for (i in names(MEs)) {
#       tryCatch({
# 
#     modules = as.numeric(sub("ME", "", i))
#     colors = labels2colors(modules)
# 
#     node <- read.delim(paste(paste(file.path(path_Output_16S,"CytoscapeInput_ASV_nodes"), 
#                                    paste(modules, Datasetname, sep="_"), sep="_"), "txt", sep ="."))
#     
#     edge <- read.delim(paste(paste(file.path(path_Output_16S,"CytoscapeInput_ASV_edges"), 
#                                    paste(modules, Datasetname, sep="_"), sep="_"), "txt", sep ="."))
# 
#     
#     #colnames(node)
#     #colnames(node) <- c("id","altName","node_attributes")
# 
#     node <- node %>% 
#       dplyr::mutate(id = nodeName) %>%
#       dplyr::select(id, everything())
#     
#     edge <- edge %>%
#       rename("fromNode"     = "source") %>%
#       rename("toNode"       =  "target") %>%
#       rename("direction"    = "interaction") 
# 
#     createNetworkFromDataFrames(node, edge, title= paste(modules, Datasetname, sep="_"),
#                               collection=paste("DataFrame", Datasetname, sep="_"))
# 
# 
#     ###########################
#     #Set some style parameters#
#     ###########################
#     #getVisualPropertyNames()
#     setVisualStyle('Sample1')
#     # set up my own style
#     style.name = paste("Style", Datasetname, sep="_")
#     defaults <- list( #NODE_SHAPE="diamond",
#                     NODE_SIZE=10,
#                     NODE_FILL_COLOR ="black",
#                     EDGE_TRANSPARENCY=120
#                     #NODE_LABEL_POSITION="W,E,c,0.00,0.00"
#                     )
#     nodeLabels <- mapVisualProperty('node label','id','p')
#     arrowShapes <- mapVisualProperty('Edge Target Arrow     Shape','interaction','d',c("activates","inhibits","interacts"),c("Arrow","T","None"))
#   
#   edgeWidth <- mapVisualProperty('edge width','weight','p')
#   
#     nodeFills <- mapVisualProperty('node fill color','Phylum','d', names(phylum_colors_Cytoscape), as.character(phylum_colors_Cytoscape))
# 
#   #nodeSize<- mapVisualProperty('NODE_SIZE','avg_Spring_22','c',c(0, 100),c(10, 1000))
#   
#   nodeSize <- mapVisualProperty('NODE_SIZE', paste0("ASVmeans"), 'c', c(0, 100), c(15, 1000))
#   
#   nodeLabelSize <- mapVisualProperty('NODE_LABEL_FONT_SIZE', paste0("ASVmeans"), 'c', c(0, 100), c(15, 100))
# 
#   nodeLabel<-mapVisualProperty('node label','ASVname','p')
#     
#    createVisualStyle(style.name, defaults, list(nodeLabels,arrowShapes, nodeFills, nodeLabel, nodeSize, edgeWidth, nodeLabelSize))
#    
#   setVisualStyle(style.name)
# 
#    }, error=function(e){cat("ERROR :",conditionMessage(e), "\n")})
#   }
# }
# 
# 
# # For Visualization in Figure 3B change to cytoscape and do: 
# # Cytoscape -> Import -> Table -> SSU_Data with Column relMeanASV -> To selected network only 
# #Styles -> LabelSize and LableText continous 
# #https://www.biostars.org/p/192885/#192910
# #https://www.biostars.org/p/454313/
# 
# #https://manual.cytoscape.org/en/stable/Styles.html#tutorial-3-creating-a-new-style-with-a-continuous-mapping
# #https://manual.cytoscape.org/en/stable/Styles.html
# #https://www.biostars.org/p/454866/
# 
# 

```

### 9.4.1 Overview network

```{r,  message=FALSE,warning=FALSE}
# #You need to download and Open Cytoscape on your computer for this to work 
# #http://www.bioconductor.org/packages/devel/bioc/vignettes/rWikiPathways/inst/doc/Pathway-Analysis.html
# #https://yulab-smu.top/biomedical-knowledge-mining-book/clusterprofiler-go.html
# 
# ###########
# #Cytoscape#
# ###########
# #list of cytoscape apps to install
# #Open Cytoscape
# cytoscapePing()
# library(WGCNA)
# options(stringsAsFactors = FALSE);
# for (Datasetname  in names(WGCNA_list)) {
#   
#   omics_data    <- WGCNA_list[[Datasetname]]$omics_data
#   datTraits     <- WGCNA_list[[Datasetname]]$datTraits
#   moduleLabels  <- WGCNA_list[[Datasetname]]$moduleLabels
#   moduleColors  <- WGCNA_list[[Datasetname]]$moduleColors
#   MEs           <- WGCNA_list[[Datasetname]]$MEs
#   network       <- WGCNA_list[[Datasetname]]$network
#   ps            <- WGCNA_list[[Datasetname]]$ps
#   softPower     <- WGCNA_list[[Datasetname]]$softPower
#   GeneAnno      <- WGCNA_list$WF$SSUWGCNAlist
#   TaxAnno       <- data.frame(tax_table(WGCNA_list$WF$ps)) %>% rownames_to_column(var="ASV")
#   
#   RepSums <- ps %>%
#       transform_sample_counts(function(x) {x/sum(x)*100}) %>%
#       phyloseq::otu_table() %>%
#       as.data.frame() %>%
#       rownames_to_column(var = "SampleID") %>%
#       dplyr::left_join(SAMDF16S, by = c("SampleID" = "SampleID")) %>%
#       dplyr::group_by(Replicates) %>%
#       dplyr::summarise(dplyr::across(rownames(tax_table(ps)), mean, na.rm = TRUE)) %>% 
#       t() %>%
#       as.data.frame() %>%
#       `colnames<-`(.[1, ]) %>%
#       .[-1, ] %>%
#       stats::setNames(paste0("avg_", colnames(.))) %>%
#       mutate_all(as.numeric) %>%
#       round(., digits = 2) %>%
#       rownames_to_column(var="ASV") 
#     
#     SeasonSums <- ps %>%
#       transform_sample_counts(function(x) {x/sum(x)*100}) %>%
#       phyloseq::otu_table() %>%
#       as.data.frame() %>%
#       rownames_to_column(var = "SampleID") %>%
#       dplyr::left_join(SAMDF16S, by = c("SampleID" = "SampleID")) %>%
#       dplyr::group_by(Season) %>%
#       dplyr::summarise(dplyr::across(rownames(tax_table(ps)), mean, na.rm = TRUE)) %>% 
#       t() %>%
#       as.data.frame() %>%
#       `colnames<-`(.[1, ]) %>%
#       .[-1, ] %>%
#       stats::setNames(paste0("avg_", colnames(.))) %>%
#       mutate_all(as.numeric) %>%
#       round(., digits = 2) %>%
#       rownames_to_column(var="ASV") 
#     
#   ############################################################################
#   #Create WGCNA Dataframe: Species, ModuleMembership, Correlation to Abiotics#
#   ############################################################################
#   
#     TOM = TOMsimilarityFromExpr(omics_data, power = softPower, nThreads =8);
#     modules = as.numeric(sub("ME", "", i))
# 
#     
#     genes  <- names(omics_data)
#     inModule <- is.finite(match(moduleColors, moduleColors));
#     ASV <- genes[inModule];
#     modColors <- moduleColors[inModule]
#     Data <- as.data.frame(cbind(ASV, modColors))
#   
#     Data  <- Data %>%  
#        left_join( #Add relative ASVmeans 
#        data.frame(t(phyloseq::otu_table(ps %>%
#         transform_sample_counts(function(x) {x/sum(x)*100})))) %>%
#           dplyr::mutate(ASVmeans = rowMeans(.)) %>%
#           dplyr::mutate(ASV = rownames(.)) %>% 
#           dplyr::select(ASV, ASVmeans)) %>% 
#       left_join(as.data.frame(tax_table(ps)) %>% rownames_to_column(var="ASV"))
#     
#       geneModuleMembership <- cor(omics_data, MEs, use = "p") %>%
#         as.data.frame() #%>% #Create ModuleMembership 
#         #dplyr::select(paste("ME", ModuleOfInterst, sep="")) %>%
#         #setNames(paste0("MM"))  #No Individual naming here for Cytoscape columns beeing equal
#     
#       MMPvalue <- #Creating p.values for Module memberships
#         as.data.frame(corPvalueStudent(as.matrix(geneModuleMembership), length(rownames(MEs)))) #%>%
#         #dplyr::select(paste("MM", sep="")) %>%
#       names(MMPvalue) <- paste(sub("ME", "p.ME", names(MMPvalue)))
#   
#  
#      #setNames(paste0(sub("MM", "p.MM", names(.)), sep="")) %>%
#      #dplyr::select(paste("p.MM", sep=""))
# 
#     Data <- Data %>%
#        dplyr::left_join(geneModuleMembership  %>% tibble::rownames_to_column(var="ASV")) %>%
#        left_join(MMPvalue  %>% rownames_to_column(var="ASV")) %>%
#        left_join(SeasonSums) %>%
#        left_join(RepSums)
#     #dplyr::arrange(desc(ASVmeans))
#     rownames(Data) <- Data$ASV
#     
#     Data$ASVname <- gsub("^ASV\\d+:", "", Data$ASV)
#     
#     
#     # Select the corresponding Topological Overlap
#     TOM_mod = TOM[inModule, inModule];
#     dimnames(TOM_mod) = list(Data$ASV, Data$ASV)
#     
#     #######################
#     #Filter for Parameters#
#     #######################
#     #Data_filt <- Data %>% 
#     #        filter(abs(MM) > 0.5 & p.MM < 0.05 & ASVmeans > 0.005) 
#     
#     Data_filt <- Data %>%
#       group_by(modColors) %>%
#       top_n(50, ASVmeans)
#     
#     TOM_filt <- TOM_mod[Data_filt$ASV, Data_filt$ASV]
#     
#     
#     
#     
#   # Export the network into edge and node list files Cytoscape can read
#   #https://support.bioconductor.org/p/95965/
#   # My operational answer is to select a threshold that keeps the file size manageable, then use     filtering in Cytoscape to interactively choose a threshold that results in an informative plot. This assumes that Cytoscape is only used for visualization; if you're going to use Cytoscape for further analysis, you should probably set the threshold to zero.
#   #https://www.biostars.org/p/9514423/
# 
#     cyt = exportNetworkToCytoscape(TOM_filt,
#     edgeFile =     paste(paste(file.path(path_Output_16S,"CytoscapeInput_ASV_edges"), paste(Datasetname, sep="_"), sep="_"), "txt", sep ="."),
#     nodeFile =  paste(paste(file.path(path_Output_16S,"CytoscapeInput_ASV_nodes"), paste(Datasetname, sep="_"), sep="_"), "txt", sep ="."),
#     weighted = TRUE,
#     threshold = 0.1, #Doing real Filtering in Cytoscape for Abundance
#     nodeNames = Data_filt$ASV,
#     altNodeNames = Data_filt$ASVname,
#     nodeAttr = Data_filt)
# }
# 
# ###########
# #Cytoscape#
# ###########
# ##############################
# #Import Networks to Cytoscape#
# ##############################
# library("RCy3")
# cytoscapePing () # make sure cytoscape is open
# cytoscapeVersionInfo ()
# for (Datasetname  in names(WGCNA_list)) {
#   
#   omics_data    <- WGCNA_list[[Datasetname]]$omics_data
#   datTraits     <- WGCNA_list[[Datasetname]]$datTraits
#   moduleLabels  <- WGCNA_list[[Datasetname]]$moduleLabels
#   moduleColors  <- WGCNA_list[[Datasetname]]$moduleColors
#   MEs           <- WGCNA_list[[Datasetname]]$MEs
# 
#     modules = as.numeric(sub("ME", "", i))
#     colors = labels2colors(modules)
# 
#     node <- read.delim(paste(paste(file.path(path_Output_16S,"CytoscapeInput_ASV_nodes"), 
#                                    paste(Datasetname, sep="_"), sep="_"), "txt", sep ="."))
#     
#     edge <- read.delim(paste(paste(file.path(path_Output_16S,"CytoscapeInput_ASV_edges"), 
#                                    paste(Datasetname, sep="_"), sep="_"), "txt", sep ="."))
# 
#     
#     #colnames(node)
#     #colnames(node) <- c("id","altName","node_attributes")
# 
#     node <- node %>% 
#       dplyr::mutate(id = nodeName) %>%
#       dplyr::select(id, everything())
# 
#     
#     edge <- edge %>% plyr::rename(c("fromNode" = "source",
#                             "toNode"   =  "target", 
#                             "direction" = "interaction"))
#   
# 
#     createNetworkFromDataFrames(node, edge, title= paste(Datasetname, sep="_"),
#                               collection=paste("DataFrame", Datasetname, sep="_"))
# 
# 
#     ###########################
#     #Set some style parameters#
#     ###########################
#     #getVisualPropertyNames()
#     setVisualStyle('Sample1')
#     # set up my own style
#     style.name = paste("Style_overall", Datasetname, sep="_")
#     defaults <- list( #NODE_SHAPE="diamond",
#                     NODE_SIZE=10,
#                     NODE_FILL_COLOR ="black",
#                     EDGE_TRANSPARENCY=120
#                     #NODE_LABEL_POSITION="W,E,c,0.00,0.00"
#                     )
#     nodeLabels <- mapVisualProperty('node label','id','p')
#     arrowShapes <- mapVisualProperty('Edge Target Arrow     Shape','interaction','d',c("activates","inhibits","interacts"),c("Arrow","T","None"))
#   
#   edgeWidth <- mapVisualProperty('edge width','weight','p')
#   
#     nodeFills <- mapVisualProperty('node fill color','Phylum','d', names(phylum_colors_Cytoscape), as.character(phylum_colors_Cytoscape))
# 
#   #nodeSize<- mapVisualProperty('NODE_SIZE','avg_Spring_22','c',c(0, 100),c(10, 1000))
#   
#   nodeSize <- mapVisualProperty('NODE_SIZE', paste0("ASVmeans"), 'c', c(0, 100), c(15, 1000))
#   
#   nodeLabelSize <- mapVisualProperty('NODE_LABEL_FONT_SIZE', paste0("ASVmeans"), 'c', c(0, 100), c(15, 100))
# 
#   nodeLabel<-mapVisualProperty('node label','ASVname','p')
#     
#    createVisualStyle(style.name, defaults, list(nodeLabels,arrowShapes, nodeFills, nodeLabel, nodeSize, edgeWidth, nodeLabelSize))
#    
#   setVisualStyle(style.name)
# 
#   }
# 
# 
# 
# # For Visualization in Figure 3B change to cytoscape and do: 
# # Cytoscape -> Import -> Table -> SSU_Data with Column relMeanASV -> To selected network only 
# #Styles -> LabelSize and LableText continous 
# #https://www.biostars.org/p/192885/#192910
# #https://www.biostars.org/p/454313/
# 
# #https://manual.cytoscape.org/en/stable/Styles.html#tutorial-3-creating-a-new-style-with-a-continuous-mapping
# #https://manual.cytoscape.org/en/stable/Styles.html
# #https://www.biostars.org/p/454866/

```


#-

# 10 Picrust2

PICRUST2
https://github.com/picrust/picrust2/wiki/Full-pipeline-script

How to interpret PICRUSt2 output
The most important thing to keep in mind when running PICRUSt2 is that predictions of functional potential are output. This data can be useful for generating hypotheses, but should always be interpreted cautiously especially when focused on a single function or predictions for a single ASV (or OTU). You should read through the key limitations of metagenome inference before proceeding.
The final output tables produced by PICRUSt2 are essentially the read depth per ASV multiplied by the predicted function abundances per ASV. The output is calculated slightly differently depending on the file as described below, but that is the basic idea. Accordingly, the final tables are not output in terms of relative abundance and the abundances per sample will sum to different numbers.

There are many possible ways to analyze the output of PICRUSt2, such as rounding the data and using the ALDEx2 R package. However, no matter what approach you use it is important to keep in mind that the data is compositional. This means that it would be inappropriate to run a Wilcoxon test (for example) on the output table without first transforming the data somehow (e.g. to relative abundance, centred-log ratio transformation, etc.).

The Enzyme Commission (EC) [4] has classified all enzymes based on the enzymatic reactions they catalyze. Each enzyme has an EC number, which is a hierarchical number that distinguishes enzymes by the type of reactions they catalyze.

awk '{print $1 }' ps_asv.fna > seqs1.fna
sed 's/://g' < seqs1.fna > seqs.fna

The input files should be a FASTA of amplicon sequences variants (ASVs; i.e. your representative sequences, not your raw reads, which is study_seqs.fna below) 
and a BIOM table of the abundance of each ASV across each sample (study_seqs.biom below). Note that a tab-delimited table with ASV ids as the first column and sample abundances as all subsequent columns will also work.

## 10.1 extract sequences

```{r, message=FALSE, warning=FALSE, include=FALSE}
# for (Datasetname  in names(WGCNA_list)) {
#   
#   omics_data    <- WGCNA_list[[Datasetname]]$omics_data
#   datTraits     <- WGCNA_list[[Datasetname]]$datTraits
#   moduleLabels  <- WGCNA_list[[Datasetname]]$moduleLabels
#   moduleColors  <- WGCNA_list[[Datasetname]]$moduleColors
#   MEs           <- WGCNA_list[[Datasetname]]$MEs
#   network       <- WGCNA_list[[Datasetname]]$network
#   ps            <- WGCNA_list[[Datasetname]]$ps
#   softPower     <- WGCNA_list[[Datasetname]]$softPower
#   GeneAnno      <- WGCNA_list$WF$SSUWGCNAlist
#   TaxAnno       <- data.frame(tax_table(WGCNA_list$WF$ps)) %>% rownames_to_column(var="ASV")
#   SSUWGCNAlist <- WGCNA_list[[Datasetname]]$SSUWGCNAlist
#   
#   ps %>%
#       refseq() %>%
#       Biostrings::writeXStringSet(paste0(file.path(path_Output_16S, 
#                                   paste(paste("SSU", Datasetname, Date, sep="_"), "asv.fna", sep="."))),
#                                   append=FALSE,
#                                   compress=FALSE, compression_level=NA, format="fasta")
# 
#   #Import ASVs as Fasta
#   fasta_sequences <- Biostrings::readDNAStringSet(paste0(file.path(path_Output_16S, 
#                                   paste(paste("SSU", Datasetname, Date, sep="_"), "asv.fna", sep="."))))
# 
#   names(fasta_sequences) <- sub(":.*", "",  names(fasta_sequences))
# 
#   #Export Fasta for Modules
#   for (MODULE in names(SSUWGCNAlist)) {
#   target_names    <- sub(":.*", "",  SSUWGCNAlist[[MODULE]]$ASV) 
#   #Subset the sequences based on the target names
#   subset_sequences <- fasta_sequences[names(fasta_sequences) %in% target_names]
#   Biostrings::writeXStringSet(subset_sequences,
#               paste0(file.path(path_Output_16S, "Fish_Picrust2", 
#                               paste(paste("SSU", Datasetname, MODULE, Date, sep="_"), "asv.fna",
#                                     sep="."))))
# 
#   A <- as.data.frame(t(otu_table(ps)))
#   rownames(A) <- sub(":.*", "",  rownames(A)) 
#   A <- A[rownames(A) %in% target_names, ]
#   
#   write.table(A, file=paste0(file.path(path_Output_16S, "Fish_Picrust2", 
#                               paste(paste("SSU", Datasetname, MODULE, Date, sep="_"), "counts.tsv",
#                                     sep="."))), quote=FALSE, sep='\t', col.names = NA)
#   }
# }
```

## 10.2 Run Picrust2

Version: 2.3.0_b
mamba create -n picrust2 -c bioconda  picrust2=2.3.0_b

Not installable on Apple M1 atm also not downgrading to 2.3.0_b because it requires pyhton <2.7 which also does not exist for M1
mamba create -n picrust2 -c bioconda -c conda-forge picrust2=2.5.2

Also on Cluster Biom-table seems to have a problem


```{r, message=FALSE, warning=FALSE, include=FALSE}
# # source /usw/baz7490/mambaforge/etc/profile.d/conda.sh
# # mamba create -n MAMBAPicrust2
# # conda activate MAMBAPicrust2
# # mamba install bioconda::picrust2
# # mamba -V
# # mamba 1.5.6
# # conda 23.11.0
# 
# #!/bin/bash
# #SBATCH --job-name=Picrust2
# #SBATCH --nodes=1
# #SBATCH --tasks-per-node=16
# #SBATCH --partition=std
# #SBATCH --time=12:00:00
# #SBATCH --export=NONE
# #SBATCH --error=error_Picrust2_WF.txt
# #SBATCH --mail-user=raphael.koll@uni-hamburg.de
# #SBATCH --mail-type=ALL
# source /sw/batch/init.sh
# source /usw/baz7490/mambaforge/etc/profile.d/conda.sh
# conda activate MAMBAPicrust2
# cd /work/baz7490/16S/picrust2/Fish_WGCNA/Fish_Picrust2
# 
# # Loop over identifiers SSU0 to SSU11
# for identifier in $(seq 0 25); do
# 
#     input_fasta="SSU_WF_SSU${identifier}_19.03.2024.asv.fna"
#     input_counts="SSU_WF_SSU${identifier}_19.03.2024.counts.tsv"
#     output_dir="SSU_WF_SSU${identifier}_19.03.2024.picrust2.out"
#     
#     # Run the picrust2_pipeline.py command
#     picrust2_pipeline.py -s "$input_fasta" -i "$input_counts" -o "$output_dir" -p 16 --per_sequence_contrib --stratified
# done
# 
# #Submitted batch job 4215541
# #Submitted batch job 4215542
# #Submitted batch job 4215543
# 
# 
# #The --strat_out option indicates that the stratified output file, which is a long-format table that indicates how ASVs contribute #ECs, will also be output.  
# 
# # pred_metagenome_contrib.tsv.gz: This default stratified pathway abundance table represents how much each ASV is contributing to the community-wide pathway abundance and not what the pathway abundance is predicted to be within the predicted genome of that ASV alone. For that output you would need to use the --per_sequence_contrib option, which is more computationally intensive to run since pathways need to be inferred for each individual ASV. As of v2.2.0-b an additional unstratified pathway abundance table will also be output when this option is used based on summing over all contributing sequences in this alternative stratified table (named path_abun_unstrat_per_seq.tsv.gz). A further discussion of the difference between these stratified pathway outputs is found here.
#     
# # Why do the stratified pathway abundances not sum to the community-wide abundance when the --per_sequence_contrib option is set?
# # When the "--per_sequence_contrib" option is used that means that pathway abundances and coverages are calculated for each predicted genome individually. If this option is not set then the contribution of each predicted genome to the community-wide pathway abundances is reported.
# # 
# # It is a little confusing to distinguish these two abundances, so here is an example.
# # 
# # Let’s say pathway X is made up of 3 reactions (A, B, and C).
# # 
# # If genome 1 has 40 copies of reaction A, but no copies of B and C then the pathway won't be called as present within that particular genome. However, if genome 2 has 30 copies of B and C each then pathway X might be called as present in that genome and at an abundance of 30.
# # 
# # To calculate the “community-wide” pathway abundances the individual genomes aren’t considered, only the total gene family abundances overall. If there are only genomes 1 and 2 in the community then the abundances would be 40, 30, and 30 for reactions A, B, and C respectively. The harmonic mean of these 3 values is higher than 30, which is what you would get by summing the pathway abundances within each genome alone. This simple example demonstrates how the community-wide and summed per-genome pathway abundance can differ.
# 
# #Rename the picrust2_KEGG Output data
# for folder in SSU_WF_SSU*.picrust2.out; do
#     # Remove the ".picrust2.out" part from the folder name
#     folder_name=$(echo "$folder" | sed 's/\.picrust2\.out//')
#       # Move and rename the files
#     mv "$folder/KO_metagenome_out/pred_metagenome_unstrat.tsv.gz" "$folder/KO_metagenome_out/${folder_name}_pred_metagenome_unstrat.tsv.gz"
#     mv "$folder/KO_metagenome_out/pred_metagenome_contrib.tsv.gz" "$folder/KO_metagenome_out/${folder_name}_pred_metagenome_contrib.tsv.gz"
# done
# 
# 

```

## 10.3 KO to KEGG 

```{r,message=FALSE, warning=FALSE, include=FALSE}
# #pkgs <- c("phyloseq", "ALDEx2", "SummarizedExperiment", "Biobase", "devtools", 
#           "ComplexHeatmap", "BiocGenerics", "BiocManager", "metagenomeSeq", 
#           "Maaslin2", "edgeR", "lefser", "limma", "KEGGREST", "DESeq2")
# #for (pkg in pkgs) {
# #  if (!requireNamespace(pkg, quietly = TRUE))
# #    BiocManager::install(pkg)}
# #install.packages("ggpicrust2")
# #devtools::install_github("thomasp85/patchwork")
# 
# 
# ##############################
# #Metadata file for ggpicrust2#
# ##############################
# 
# kegg_abundance_list <- list()
# for (Datasetname  in names(WGCNA_list)) {
#   
#   kegg_abundance_list[[Datasetname]] <- list()
#   omics_data    <- WGCNA_list[[Datasetname]]$omics_data
#   datTraits     <- WGCNA_list[[Datasetname]]$datTraits
#   MEs           <- WGCNA_list[[Datasetname]]$MEs
#   ps            <- WGCNA_list[[Datasetname]]$ps
#   
#   Analysis   <- "WGCNA"
#   prefix <- "SSU-"
# 
#   if (Datasetname %in% c("OE", "GC")) {
#   
#     traitData <- c(
#   "HSI", "SSI", "GSI", "FCF", "FillLevel", "Age", "Length", 
#   "NH4", "NO2", "NO3", "O2", "PO4", "TOC", "Temp",  "SPM", "Salinity", "LOC", "Season", "SampleID"
#   
#   ) } else if (Datasetname  %in% c("WF")) {
#   
#     traitData <- c(
#   "NH4", "NO2", "NO3", "O2", "PO4", "TOC", "Temp",  "SPM", "Salinity", "LOC", "Season", "SampleID"
#     ) }
#   
#   metadata_Picrust2<- SAMDF16S %>%
#     filter(Species == Datasetname) %>%
#     select(all_of(traitData))
#   
#   metadata_Picrust2 <- metadata_Picrust2  %>% select(SampleID, everything())
#   metadata_Picrust2  <- as_tibble(metadata_Picrust2 )
#   head(metadata_Picrust2)
#   print(paste("NAs", table(is.na(metadata_Picrust2)) == T))
#   kegg_abundance_list[[Datasetname]][["metadata_Picrust2"]] <- metadata_Picrust2
#   #########################
#   #Read in Picrust2 Output#
#   #########################
#   Identifyer <- paste("SSU", 1:(length(MEs)-1), sep=""); 
#   names(Identifyer) <- paste("SSU", 1:(length(MEs)-1), sep="")
#   library(ggpicrust2)
#   #Read in Pricrust2 Kegg output as loop 
# 
#   for  (MODULE  in Identifyer) {
#     
#     a <- length(kegg_abundance_list)
#     kegg_abundance <- ggpicrust2::ko2kegg_abundance(paste0(file.path(path_Output_16S, "Fish_Picrust2/picrust2_KEGG", 
#                               paste(paste("SSU", Datasetname, MODULE, Date, "pred_metagenome_unstrat",
#                                           sep="_"), "tsv",
#                                       sep="."))))
#     
#     kegg_abundance_list[[Datasetname]][[MODULE]] <- kegg_abundance
# 
#   } 
# }
#              
# saveRDS(kegg_abundance_list, 
#         file = paste0(paste0(file.path(path_Output_16S, "Fish_Picrust2/picrust2_KEGG",
#                                         paste(paste("SSU", Date, "Picrust2_Kegg_Abundance",
#                                         sep="_"), "rds",sep="."))))       
#       )
# ```
# 
# ## 10.4 KEGG Annotaton
# 
# ```{r, echo=false}
# #The KEGG server refuses answers after some hundred inquires so you have to restart R several times and restart the process. After each Module the Output is saved so we automatically determine which worked and restart with the remaining
# 
# kegg_abundance_list <- readRDS( 
#         file = paste0(paste0(file.path(path_Output_16S, "Fish_Picrust2/picrust2_KEGG",
#                                         paste(paste("SSU", "GC_OE",Date, "Picrust2_Kegg_Abundance",
#                                         sep="_"), "rds",sep=".")))))
# ###########################
# # KEGG Pathways Annotation#
# ###########################
# kegg_annotation_list <- list()
# 
# for (Datasetname in names(kegg_abundance_list)[grepl("OE", names(kegg_abundance_list))]) {
#   
#   ############################
#   #Check if files are present#
#   ############################
#   MODULES <- names(kegg_abundance_list[[Datasetname]])[grepl("SSU",
#                                       names(kegg_abundance_list[[Datasetname]]))]
#   
#   expected_files <- paste0(file.path(path_Output_16S, "Fish_Picrust2/picrust2_KEGG"),
#                          "/", paste("Picrust", Datasetname, MODULES, "kegg_annotation", sep="_"), ".rds")
#   # List files in the directory
#   existing_files <- 
#     list.files(file.path(path_Output_16S, "Fish_Picrust2/picrust2_KEGG"), full.names = TRUE)
#   
#   present_files <- expected_files[expected_files %in% existing_files]
#   
#   basename(present_files)
#   present_files <- sub("Picrust_OE_", "",  basename(present_files))
#   present_files <- sub("_kegg_annotation.rds", "",  present_files)
# 
#   kegg_annotation_list[[Datasetname]] <- list()
#   
#   for (MODULE in names(kegg_abundance_list[[Datasetname]])[names(kegg_abundance_list[[Datasetname]]) %in% setdiff(MODULES, present_files )]) {
#     
#     tryCatch({
#       
#     kegg_annotation_list[[Datasetname]][[MODULE]] <- list()
#   
#     kegg_annotation <- kegg_abundance_list[[Datasetname]][[MODULE]] %>% rownames_to_column(var = "feature")
# 
#     #Split into pieces to allow Kegg Database usage
#     kegg_annotation_split_list <- split(kegg_annotation, rep(1:ceiling(nrow(kegg_annotation)/10), 
#                                each = 10, length.out = nrow(kegg_annotation)))
#     print(MODULE)
#     print(length(kegg_annotation_split_list))
#     
#       kegg_annotated_results_list <- list()
#       for (x in names(kegg_annotation_split_list)) {
#         tryCatch({
#         print(x)
#         kegg_annotated_results <- kegg_annotation_split_list[[x]]
#         kegg_annotated_results$pathway_name <- NA
#         kegg_annotated_results$pathway_class <- NA
#         kegg_annotated_results$pathway_map <- NA
#         for (i in seq_along(kegg_annotated_results$feature)) {
#             tryCatch({
#             keggGet_results <- list()
#             keggGet_results[[i]] <- KEGGREST::keggGet(kegg_annotated_results$feature[i])
#             kegg_annotated_results[i, ]$pathway_name <- keggGet_results[[i]][[1]]$NAME
#             kegg_annotated_results[i, ]$pathway_class <- keggGet_results[[i]][[1]]$CLASS
#             kegg_annotated_results[i, ]$pathway_map <- keggGet_results[[i]][[1]]$PATHWAY_MAP
#             print(i)
#             }, error=function(e){cat("ERROR :",conditionMessage(e), "\n")})
#           }
#         
#           kegg_annotated_results_list[[x]] <- kegg_annotated_results
#           }, error=function(e){cat("ERROR :",conditionMessage(e), "\n")})
#         }
#       
#         kegg_annotated_results_df <- do.call(rbind, kegg_annotated_results_list)
#         
#         kegg_annotation_list[[Datasetname]][[MODULE]] <- kegg_annotated_results_df
#         saveRDS(kegg_annotation_list[[Datasetname]][[MODULE]], 
#         file = paste0(paste0(file.path(path_Output_16S, "Fish_Picrust2/picrust2_KEGG",
#                                         paste(paste("Picrust", Datasetname, MODULE, "kegg_annotation",
#                                         sep="_"), "rds",sep=".")))))
#      }, error=function(e){cat("ERROR :",conditionMessage(e), "\n")})
#   }
# }
  
```

## 10.5 DAA

```{r , message=FALSE, warning=FALSE, include=FALSE}
# #Differential Abudance Testing
#   variable <- "Replicates"
#   #variable_of_interst <- "SU21"
#   alpha <- 0.05
#   kegg_deseq_list <- list()
#   
# for (Datasetname in names(kegg_abundance_list)[grepl("OE", names(kegg_abundance_list))]) {
#   #################
#   #Create Metadata#
#   #################
#   kegg_deseq_list[[Datasetname]] <- list()
#   if (Datasetname %in% c("OE", "GC")) {
#   
#     traitData <- c(
#   "HSI", "SSI", "GSI", "FCF", "FillLevel", "Age", "Length", 
#   "NH4", "NO2", "NO3", "O2", "PO4", "TOC", "Temp",  "SPM", "Salinity", "LOC", "Season", "SampleID", "Replicates"
#   
#   ) } else if (Datasetname  %in% c("WF")) {
#   
#     traitData <- c(
#   "NH4", "NO2", "NO3", "O2", "PO4", "TOC", "Temp",  "SPM", "Salinity", "LOC", "Season", "SampleID"
#     ) }
#   
#   metadata_Picrust2<- SAMDF16S %>%
#     filter(Species == Datasetname) %>%
#     select(all_of(traitData))
#   
#   metadata_Picrust2 <- metadata_Picrust2  %>% select(SampleID, everything())
#   metadata_Picrust2  <- as_tibble(metadata_Picrust2)
#   head(metadata_Picrust2)
#   print(paste("NAs", table(is.na(metadata_Picrust2)) == T))
#   
#   ################################
#   #Differential Abundance Testing#
#   ################################
#   for (MODULE in names(kegg_abundance_list[[Datasetname]])[grepl("SSU",
#                         names(kegg_abundance_list[[Datasetname]]))]) {
#     kegg_deseq_list[[Datasetname]][[MODULE]] <- list()
#     tryCatch({
# 
#     has_all_zeros <- function(column) {all(column == 0)}
#     zero_columns <- sapply(kegg_abundance_list[[Datasetname]][[MODULE]], has_all_zeros)
#     # Remove columns with all zero values
#     print(paste(MODULE, dim(kegg_abundance_list[[Datasetname]][[MODULE]])[2]))
#     kegg_abundance_df_noAllZero <- kegg_abundance_list[[Datasetname]][[MODULE]][, !zero_columns]
#     print(paste("Check columns for all zero", MODULE, dim(kegg_abundance_df_noAllZero)[2]))
#     print(paste("Sample All Zero:", names(zero_columns[zero_columns == TRUE])))
#   
#     metadata_Picrust2 <- metadata_Picrust2[metadata_Picrust2$SampleID %in%
#                                     names(kegg_abundance_df_noAllZero),]
#     ########
#     #DESEQ2#
#     ########
#     require(DESeq2)
#     countData = round(as(kegg_abundance_df_noAllZero, "matrix"), digits = 0)
#   
#     dds <- DESeqDataSetFromMatrix(countData =countData, colData = metadata_Picrust2,
#         design =as.formula(paste("~",variable)))
#     dds  <- DESeq(dds)
#     vst   <- varianceStabilizingTransformation(dds)
#     
#     VARIABLE <- variable
#     
#     ###############Selection of Comparisons################
#     VariableOrder<- VariableOrder
#     A <- as.data.frame(t(combn(metadata_Picrust2 %>% 
#     arrange(factor(variable, levels = VariableOrder)) %>% #Chane hard coded Variable name here! 
#     pull(paste(variable)) %>% 
#     unique(),2)))
#     A$V3<-Reduce(function(...) paste(..., sep = "-"), A)
#     #A <- A[grepl(variable_of_interst, A$V3),]
#     
#     mylist <- list() 
#     for (i in 1:nrow(A)) {
#     res <- results(dds, lfcThreshold = 0.0, alpha=0.05, contrast=c(VARIABLE,A[i,1],A[i,2]))
#     mylist[[i]] <- res 
#     names(mylist)[[i]] <- A[i,3]
#     }
#     for (i in seq_along(mylist)) {
#       mylist[[i]] <- as.data.frame(mylist[[i]])
#        }
#     mylist <- lapply(mylist,na.omit)
#     mylist <- lapply(mylist, function(y) {y[which(y$padj < alpha),]})
#     mylist <- lapply(mylist, function(z){z[order(z$padj),]})
#     mylist <- lapply(mylist, function(x) {x$sign <-ifelse(sign(x$log2FoldChange) > 0, "enriched", "diminished");return(x)})
#       
#     daa <- do.call(rbind, mylist)
#     daa_results_df <- na.omit(daa)
#     attr(daa_results_df, "na.action") <- NULL
#     daa_results_df <- daa_results_df %>% rownames_to_column(var = "rownames")
#     daa_results_df <- separate(daa_results_df, rownames, into = c("comparison", "feature"), sep = "\\.")
#     daa_results_df <- na.omit(daa_results_df)
#     attr(daa_results_df, "na.action") <- NULL
#     }, error=function(e){cat("ERROR :",conditionMessage(e), "\n")})
#     kegg_deseq_list[[Datasetname]][[MODULE]] <- daa_results_df
#   }
# }
#   
# saveRDS(kegg_deseq_list[[Datasetname]], 
#       file = paste0(paste0(file.path(path_Output_16S, "Fish_Picrust2/picrust2_KEGG",
#                                         paste(paste("Picrust", Datasetname, "kegg_deseq",
#                                         sep="_"), "rds",sep=".")))))

```

## 10.6 Combine

```{r , message=FALSE, warning=FALSE, include=FALSE}

# for (Datasetname in names(kegg_abundance_list)[grepl("OE", names(kegg_abundance_list))]) {
#   
#   ############################
#   #Check if files are present#
#   ############################
#   MODULES <- names(kegg_abundance_list[[Datasetname]])[grepl("SSU",
#                                                              names(kegg_abundance_list[[Datasetname]]))]
# 
#   file_paths <- lapply(MODULES, function(module) {
#   file.path(path_Output_16S, "Fish_Picrust2/picrust2_KEGG", paste0("Picrust_", 
#                                 Datasetname, "_", module, "_kegg_annotation.rds"))})
#   
#   all_files <- lapply(file_paths, readRDS)
#   kegg_annotation_list <- setNames(all_files, MODULES)
# 
#   kegg_deseq <- kegg_deseq_list[[Datasetname]] 
#   
#   for (MODULE in MODULES) {
#     kegg_deseq[[MODULE]] <- kegg_deseq[[MODULE]] %>% 
#       left_join(kegg_annotation_list[[MODULE]])
#   }
#   
# }
#     
# ```
# 
# #### 10.1.3.3 Kegg-Dotplot
# 
# ```{r echo=false}
# 
#     B <- do.call(rbind.data.frame, kegg_deseq)
#     B$Modules <-  sub("\\.\\d+", "", rownames(B))
#     B <- na.omit(B)
#     B$PathwayActivation <- -log2(B$padj)
#     head(B)
# 
#     B <- B[!grepl("Human Diseases|Organismal Systems; Nervous system", B$pathway_class),]
#     
#     B <- B[grepl("Organismal Systems; Immune system", B$pathway_class),]
#     BB <- B[grepl("Metabolism", B$pathway_class),]
#     BB <- B[grepl("Metabolism; Energy metabolism", B$pathway_class),]
#     BB <- B[grepl("Human Diseases; Infectious disease: bacterial", B$pathway_class),]
#     
#   
#     mg <- ggplot(BB, aes(x = Modules, y = pathway_map, color=PathwayActivation, size = PathwayActivation))+ 
#         geom_point() + scale_size(range = c(3, 20)) + 
#         scale_color_gradientn(colours = c("blue", "pink", "red", "red"), 
#                         values = scales::rescale(x = c(0, 1, 5, 50), to = c(0,1), from = c(0, 50) ))
# 
#     mg <- mg  + facet_grid(B$pathway_class, scales = "free", space = "free") +
#         xlab("\n\nAhead AADT") +
#         #theme_minimal() + 
#         atheme + 
#         theme(strip.text.y = element_text(angle = 0))  +
#         theme(axis.text.x=element_blank(),
#         #axis.ticks.x=element_blank(),
#         axis.text.y=element_blank(),
#         axis.title.y.left = element_blank(),
#         axis.ticks.y =element_blank() 
#         #axis.title.x = element_blank()
#         ) +
#   theme(
#     panel.background = element_rect(fill='transparent'), #transparent panel bg
#     plot.background = element_rect(fill='transparent', color=NA), #transparent plot bg
#     #panel.grid.major = element_blank(), #remove major gridlines
#     #panel.grid.minor = element_blank(), #remove minor gridlines
#     legend.background = element_rect(fill='transparent'), #transparent legend bg
#     legend.box.background = element_rect(fill='transparent') #transparent legend panel
#   ) +
#   theme(axis.title.x.bottom =  element_text(color="grey13"), 
#         strip.text.y.right = element_text(size=12, color = "black", face= "bold"), 
#         axis.text.y.left = element_text(size=12, face = "bold", color= "white"), 
#         axis.text.x.bottom = element_text(size=10,face = "bold", angle = 45, hjust = 1, color= "white"), 
#         legend.position="none")
# 
#   g <- ggplot_gtable(ggplot_build(mg))
#         stripr <- which(grepl('strip-t', g$layout$name))
#         fills <- alpha(c("red", "blue"), 0.4)
#         k <- 1
#         for (i in stripr) {
#         j <- which(grepl('rect', g$grobs[[i]]$grobs[[1]]$childrenOrder))
#         g$grobs[[i]]$grobs[[1]]$children[[j]]$gp$fill <- fills[k]
#         k <- k+1}
#         prow <- cowplot::plot_grid(g, labels = c(""), ncol = 1)
#         AA<- print(cowplot::plot_grid(prow, ncol = 1, rel_heights = c(0.01, 0.999)))
# ggsave(AA, filename = paste("WGCNA-Picrust_KEGG_Slim", Species, Type, sep=""), path = pathPlots, 
#                device='png', dpi=300, width = 13,height = 12)
# 
# 
# ############################
# #For Subsets of SSU_Modules#
# ############################
# ModulesOfInterst <-c("SSU2","SSU3","SSU5","SSU6", "SSU9")
# BB <- B[B$Modules %in% ModulesOfInterst,]
# mg <- ggplot(BB, aes(x = Modules, y = Child, color=PathwayActivation, size = PathwayActivation)) + 
#         geom_point() + scale_size(range = c(3, 20)) + 
#         scale_color_gradientn(colours = c("blue", "pink", "red", "red"), 
#                         values = scales::rescale(x = c(0, 1, 5, 50), to = c(0,1), from = c(0, 50) ))
# 
#     mg <- mg  + facet_grid(Parent ~ factor(CorrelationToTraits, levels=Order), scales = "free", space = "free") +
#         xlab("\n\nAhead AADT") +
#         #theme_minimal() + 
#         awhite + 
#         theme(strip.text.y = element_text(angle = 0))  +
#         theme(axis.text.x=element_blank(),
#         #axis.ticks.x=element_blank(),
#         axis.text.y=element_blank(),
#         axis.title.y.left = element_blank(),
#         axis.ticks.y =element_blank() 
#         #axis.title.x = element_blank()
#         ) +
#   theme(
#     panel.background = element_rect(fill='transparent'), #transparent panel bg
#     plot.background = element_rect(fill='transparent', color=NA), #transparent plot bg
#     #panel.grid.major = element_blank(), #remove major gridlines
#     #panel.grid.minor = element_blank(), #remove minor gridlines
#     legend.background = element_rect(fill='transparent'), #transparent legend bg
#     legend.box.background = element_rect(fill='transparent') #transparent legend panel
#   ) +
#   theme(axis.title.x.bottom =  element_text(color="grey13"), 
#         strip.text.y.right = element_text(size=12, color = "black", face= "bold"), 
#         axis.text.y.left = element_text(size=12, face = "bold", color= "white"), 
#         axis.text.x.bottom = element_text(size=10,face = "bold", angle = 45, hjust = 1, color= "white"), 
#         legend.position="none")
# 
#   g <- ggplot_gtable(ggplot_build(mg))
#         stripr <- which(grepl('strip-t', g$layout$name))
#         fills <- alpha(c("red", "blue"), 0.4)
#         k <- 1
#         for (i in stripr) {
#         j <- which(grepl('rect', g$grobs[[i]]$grobs[[1]]$childrenOrder))
#         g$grobs[[i]]$grobs[[1]]$children[[j]]$gp$fill <- fills[k]
#         k <- k+1}
#         prow <- cowplot::plot_grid(g, labels = c(""), ncol = 1)
#         AA<- print(cowplot::plot_grid(prow, ncol = 1, rel_heights = c(0.01, 0.999)))
# ggsave(AA, filename = paste("WGCNA-Picrust_KEGG_Slim_Subset", Species, Type, sep=""), path = pathPlots, 
#                device='png', dpi=300, width = 9,height = 12)

```

##### Specific Child Terms

```{r, message=FALSE, warning=FALSE, include=FALSE}

# ############################
# #For Subsets of SSU_Modules#
# ############################
# ModulesOfInterst <-c("SSU2","SSU3","SSU5","SSU6", "SSU9", "SSU10")
# BB <- B[B$Modules %in% ModulesOfInterst,]
# 
# table(BB[BB$Parent == "Human Diseases",]$Child)
# 
# BBImmune <- BB[BB$Child %in% c(
# " Cancer: overview",          
# " Cancer: specific types",     
# " Cardiovascular disease",
# " Endocrine and metabolic disease", 
# " Immune disease",
# " Infectious disease: bacterial", 
# " Infectious disease: parasitic",       
# " Neurodegenerative disease", 
# " Immune disease",                                
# " Immune system"
# ), ]
# 
# mg <- ggplot(BBImmune, aes(x = Modules, y = pathway_name, color=PathwayActivation, size = PathwayActivation)) + 
#         geom_point() + scale_size(range = c(3, 20)) + 
#         scale_color_gradientn(colours = c("blue", "pink", "red", "red"), 
#                         values = scales::rescale(x = c(0, 1, 5, 50), to = c(0,1), from = c(0, 50) ))
#     mg <- mg  + facet_grid(Child ~ factor(CorrelationToTraits, levels=Order), scales = "free", space = "free") + guides(color = guide_legend(title = "-log2(p_adjust)"), size = guide_legend(title = "-log2(p_adjust)")) +
#         xlab("\n\nAhead AADT") +
#         #theme_minimal() + 
#         awhite + 
#         theme(strip.text.y = element_text(angle = 0))  +
#         theme(#axis.text.x=element_blank(),
#         #axis.ticks.x=element_blank(),
#         axis.text.y=element_blank(),
#         axis.title.y.left = element_blank(),
#         axis.ticks.y =element_blank() 
#         #axis.title.x = element_blank()
#         ) +
#   theme(
#     panel.background = element_rect(fill='transparent'), #transparent panel bg
#     plot.background = element_rect(fill='transparent', color=NA), #transparent plot bg
#     #panel.grid.major = element_blank(), #remove major gridlines
#     #panel.grid.minor = element_blank(), #remove minor gridlines
#     legend.background = element_rect(fill='transparent'), #transparent legend bg
#     legend.box.background = element_rect(fill='transparent'), #transparent legend panel
#     panel.grid.major = element_line(colour = "grey40"), 
#     panel.grid.minor = element_line(colour = "grey40") 
#   ) +
#   theme(axis.title.x.bottom =  element_text(color="grey13"), 
#         strip.text = element_text(color = "black", face= "bold"))
# 
# g <- ggplot_gtable(ggplot_build(mg))
#         stripr <- which(grepl('strip-t', g$layout$name))
#         fills <- alpha(c("salmon", "darkred"), 0.4)
#         k <- 1
#         for (x in stripr) {
#         j <- which(grepl('rect', g$grobs[[x]]$grobs[[1]]$childrenOrder))
#         g$grobs[[x]]$grobs[[1]]$children[[j]]$gp$fill <- fills[k]
#         k <- k+1}
#         prow <- cowplot::plot_grid(g, labels = c(""), ncol = 1)
#         AA<- print(cowplot::plot_grid(prow, ncol = 1, rel_heights = c(0.1, 0.99)))
# ggsave(AA, filename = paste("Slim_Immune_WGCNA_SSU_KEGGPathway", Species, gg, Type, sep="_"), path = pathPlots , device='png', dpi=300, width = 10,height = 12)

```








# -

# 11 Source Analysis

## 11.1 Feast

Does not work atm

https://github.com/cozygene/FEAST
https://www.nature.com/articles/s41592-019-0431-x

https://www.ncbi.nlm.nih.gov/pmc/articles/PMC10125963/

```{r}
# library(FEAST)
# metadata <- Load_metadata(metadata_path = "/Users/admin/Downloads/metadata_example_multi.txt")
# otus <- Load_CountMatrix(CountMatrix_path = "/Users/admin/Downloads/otu_example_multi.txt")
# 
# FEAST_output <- FEAST(C = otus, metadata = metadata, different_sources_flag = 1, dir_path = "~/FEAST/Data_files/", outfile="demo")
# 
# FEAST_output <- FEAST(C = otus, metadata = metadata, different_sources_flag = 1)
# 
# devtools::install_github("cozygene/FEAST", ref = "FEAST")
```


# -

# 12 Final dataset

## 12.1 Read Final Dataset 

```{r, message=FALSE, warning=FALSE}

#saveRDS(pslist, file.path(path_Output_16S,paste(paste(save_name,  "16S_merge_Filter_ASV_besttax", Date, sep="_"), ".rds", sep="")))

# pslistraw <- readRDS(file.path(path_Output_16S, paste(paste(save_name,"ps_16S_merge_pslistraw", Date, sep="_"), ".rds", sep="")))
# 
# pslist <- readRDS(file.path(path_Output_16S,paste(paste(save_name, "16S_merge_Filter_ASV_besttax", Date, sep="_"), ".rds", sep="")))
# 
# WGCNA_list <- readRDS(file = paste0(file.path(path_Output_16S, paste(paste(save_name, "WGCNA_list", Date, sep="_"), ".rds", sep=""))))
```


## 12.2 Update samdf 

when necessary

```{r}
# require(tidyverse)
# pslist <- pslist[!grepl("TSE|clr", names(pslist))]
# names(pslist)
# 
# for (i in names(pslist)[grepl("ps", names(pslist))]){
#     ps <- pslist[[i]]
#     g<- names(pslist[i])
# 
#     A<-SAMDF16S[SAMDF16S$SampleID %in% rownames(sample_data(ps)),]
#     Sample_Data <- as.data.frame(sample_data(ps))
#     A<-left_join(A, Sample_Data[,names(Sample_Data) %in% c("SampleID", "nonchim", "Run", "Input")])
#     rownames(A) <- A$SampleID
# 
#     #PHY <-phy_tree(ps)
#     OTU <- otu_table(ps, taxa_are_rows=FALSE)
#     TAX <- tax_table(ps)
#     pslist[[i]] <- phyloseq(otu_table(OTU, taxa_are_rows=FALSE),
#                sample_data(A), tax_table(TAX)) #, phy_tree(PHY)
#   }
# 
# for (i in names(pslist)[grepl("ps", names(pslist))]){
#   g <- paste(i)
#   a <- length(pslist)
#   ps <- pslist[[i]]
#   ps_clr <- microbiome::transform(ps, "clr")
#   pslist[[a+1]] <- ps_clr
#   names(pslist)[[a+1]] <- paste("clr", sub("ps", "\\1", g), sep="")}
# 
# for (i in names(pslist)[grepl("clr", names(pslist))]){
#   g <- paste(i)
#   a <- length(pslist)
#   clr <- pslist[[i]]
#   TSE<-mia::makeTreeSummarizedExperimentFromPhyloseq(clr)
#   pslist[[a+1]] <- TSE
#   names(pslist)[[a+1]] <- paste("TSEc.l.r", sub("clr", "\\1", g), sep="")}

```

#-


