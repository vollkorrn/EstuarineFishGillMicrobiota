---
title: "SL_Functions_16.01.24_Paper.Rmd"
output: html_document
date: "2024-01-16"
---

# 1 Basic functions

```{r}
#Not in
'%!in%' <- function(x,y)!('%in%'(x,y))
#noamross/source_rmd.R
#https://gist.github.com/noamross/a549ee50e8a4fd68b8b1
source_rmd = function(file, skip_plots = TRUE) {
  temp = tempfile(fileext=".R")
  knitr::purl(file, output=temp)

  if(skip_plots) {
    old_dev = getOption('device')
    options(device = function(...) {
      .Call("R_GD_nullDevice", PACKAGE = "grDevices")
    })
  }
  source(temp)
  if(skip_plots) {
    options(device = old_dev)
  }
}
```



# 2 Visualizations

```{r}
  Units <- c("Temperature" = "°C","pH" = "", "Salinity" = "psu", "O2Sat" = "%", "SecchiDepth" = "cm", "Age" = "years", "Cortison" = "ng/g", "Cortisol" = "ng/g", "HSI" = "Index", "GSI" = "Index", "SSI" = "Index", "FCF" = "Index", "FillLevel" = "Stomach", "Length" = "cm", "Turbidity" = "NTU", "O2" = "mg/L", "NH4" = "mg/ml","NO2"= "mg/ml", "NO3"= "mg/ml", "O2"= "mg/ml", "PO4"= "mg/ml", "pH"= "mg/ml", "SPM"= "mg/ml", "TOC"= "mg/ml", "LF" = "mS/m", "PC1" = "", "PC2" = "", "PC3" = "", "PC4" = "", "Shannon" = "Index", "Chao1.Chao1" = "Index", "InvSimpson" = "Index", "Observed" = "n ASVs", "Dispersion" = "BC")

AlphaIndices <- c("Shannon" = "Index", "Chao1.Chao1" = "Index", "InvSimpson" = "Index", "Observed" = "n ASVs", "Dispersion" = "BC")

#expression(paste("Weight/ Length (SL)"^3, "x 100")






col.Palette <-list(
  GC   =c("GCSU21BB" = "seagreen4","GCSU21SS" = "darkseagreen3","GCSU21ML" = "seagreen3",
          "GCWI21BB" = "seagreen4","GCWI21SS" = "darkseagreen3","GCWI21ML" = "seagreen3",
          "GCSP22BB" = "seagreen4","GCSP22SS" = "darkseagreen3","GCSP22ML" = "seagreen3",
          "GCAU22BB" = "seagreen4","GCAU22SS" = "darkseagreen3","GCAU22ML" = "seagreen3",
          "GCSU22ML" = "red", "GCSU22OS" = "purple"),
  
 col.Palette.Loc    =c("Medem Grund" = "steelblue", "Brunsbuettel" = "#9E9E9E", 
                         "Schwarztonnen Sand" = "#FF6A98", "Twielenfleth" = "#FFA726", "Muehlenberger Loch" = "#F8766D"), 
 
  col.Palette.LOC    =c("MG-713" = "#336699", "BB-692" = "#669999", "SS-665" = "#9E9E9E", "TF-651" = "#FFA726", "ML-633" = "#F8766D"), 
  
  col.Palette.Season    =c("Summer_21" = "goldenrod1", "Autumn_21"= "sienna3", "Winter_22" = "#35A2FF", "Spring_22" = "#00BF7D", "Summer_22" = "brown1"),
  
  col.Palette.Cruise    = c("Elbe_Summer_21" = "goldenrod1","Elbe_Autumn_21"= "sienna3", "Elbe_Winter_22" = "#35A2FF", "Elbe_Spring_22" = "#00BF7D", "Elbe_Summer_22"= "brown1","Oste_Summer_22" = "purple"),
  
  
  col.Palette.Species = c("SL" = "seashell4", "GC" = "seagreen", "OE" = "brown1", "WF" = "darkblue"), 
  col.Palette.RepsSeason = c(
  "GCSU21ML"= "goldenrod1", "GCSU21TW"= "goldenrod1", "GCSU21SS"="goldenrod1", "GCSU21BB"="goldenrod1", 
  "GCAU21ML"= "sienna3", "GCAU21TW"= "sienna3", "GCAU21SS"= "sienna3", "GCAU21BB"= "sienna3", 
  "GCWI22ML"= "#35A2FF", "GCWI22SS"= "#35A2FF", "GCWI22BB"= "#35A2FF", 
  "GCSP22ML"= "#00BF7D",  "GCSP22TW"= "#00BF7D", "GCSP22SS"= "#00BF7D", "GCSP22BB"= "#00BF7D"),
  
  col.Palette.Reps = c(
                 
    "SU 713" = "goldenrod1", "SU 692" = "goldenrod1","SU 665" ="goldenrod1","SU 651"="goldenrod1","SU 633"="goldenrod1", 
    
    "AU 713"="sienna3","AU 692"="sienna3","AU 665"="sienna3","AU 651"="sienna3","AU 633"="sienna3", 
    
    "WI 713"="#35A2FF","WI 692"="#35A2FF","WI 665"="#35A2FF","WI 651"="#35A2FF","WI 633"="#35A2FF", 
    
    "SP 713"= "#00BF7D","SP 692"= "#00BF7D","SP 665"= "#00BF7D","SP 651"= "#00BF7D","SP 633"= "#00BF7D", "WF"= "darkblue"), 
 
   col.Palette.Reps2 = c("WF"= "darkblue", 
                 
    "SU 713" = "#336699", "SU 692" = "#009999","SU 665" ="#9E9E9E","SU 651"="#FFA726","SU 633"="#F8766D", 
    
    "AU 713"= "#336699","AU 692"="#009999","AU 665"="#9E9E9E","AU 651"="#FFA726","AU 633"="#F8766D", 
    
    "WI 713"="#336699","WI 692"="#009999","WI 665"="#9E9E9E","WI 651"="#FFA726","WI 633"="#F8766D", 
    
    "SP 713"= "#336699","SP 692"= "#009999","SP 665"= "#9E9E9E","SP 651"= "#FFA726","SP 633"= "#F8766D"), 
 
col.Palette.RepsSpecs = c("WF"= "darkblue", 
                 
    "GC SU 713" = "goldenrod1", "GC SU 692" = "goldenrod1","GC SU 665" ="goldenrod1","GC SU 651"="goldenrod1","GC SU 633"="goldenrod1", 
    
    "GC AU 713"="sienna3","GC AU 692"="sienna3","GC AU 665"="sienna3","GC AU 651"="sienna3","GC AU 633"="sienna3", 
    
    "GC WI 713"="#35A2FF","GC WI 692"="#35A2FF","GC WI 665"="#35A2FF","GC WI 651"="#35A2FF","GC WI 633"="#35A2FF", 
    
    "GC SP 713"= "#00BF7D","GC SP 692"= "#00BF7D","GC SP 665"= "#00BF7D","GC SP 651"= "#00BF7D","GC SP 633"= "#00BF7D", 
    
    "OE SU 713" = "goldenrod2", "OE SU 692" = "goldenrod2","OE SU 665" ="goldenrod2","OE SU 651"="goldenrod2","OE SU 633"="goldenrod2", 
    
    "OE AU 713"="#993300","OE AU 692"="#993300","OE AU 665"="#993300","OE AU 651"="#993300","OE AU 633"="#993300", 
    
    "OE WI 713"="#0000FF","OE WI 692"="#0000FF","OE WI 665"="#0000FF","OE WI 651"="#0000FF","OE WI 633"="#0000FF", 
    
    "OE SP 713"= "green4","OE SP 692"= "green4","OE SP 665"= "green4","OE SP 651"= "green4","OE SP 633"= "green4")
)




    



library(tidyverse)
atheme<- theme(axis.text.x = element_text(angle = 90),
        axis.title.x.bottom = element_text(size=10,face = "bold"),
        axis.title.y.left = element_text(size=10,face = "bold"),
        strip.text.x = element_text(face = "bold"),
        strip.text.x.bottom = element_text(size = 10,face = "bold"),
        strip.text.y.left = element_text(size = 10,face = "bold"),
        axis.text.x.bottom = element_text(face = "bold", angle = 45, hjust = 1),
        axis.text.y.left = element_text(face = "bold"),
        legend.title = element_text( size = 9),
        legend.text = element_text(size = 9,face = "bold"),
        plot.title = element_text(size = 10, face = "bold"),
        plot.subtitle = element_text(size = 9),
        plot.caption = element_text(size = 9))

atheme2<- theme(axis.text.x = element_text(size=6, angle = 90),
        axis.title.x.bottom = element_text(size=6,face = "bold"),
        axis.title.y.left = element_text(size=6,face = "bold"),
        strip.text.x = element_text(face = "bold"),
        strip.text.x.bottom = element_text(size = 6,face = "bold"),
        strip.text.y.left = element_text(size = 6,face = "bold"),
        axis.text.x.bottom = element_text(size= 6, face = "bold", angle = 45, hjust = 1),
        axis.text.y.left = element_text(face = "bold"),
        legend.title = element_text( size = 6),
        legend.text = element_text(size = 6,face = "bold"),
        plot.title = element_text(size = 6, face = "bold"),
        plot.subtitle = element_text(size = 6),
        plot.caption = element_text(size = 6))

awhite<- theme(axis.text.x = element_text(angle = 90, color= "white"),
        axis.title.x.bottom = element_text(size=10,face = "bold", color= "white"),
        axis.title.y.left = element_text(size=10,face = "bold", color= "white"),
        strip.text.x = element_text(face = "bold", color= "white"),
        strip.text.x.bottom = element_text(size = 10,face = "bold", color= "white"),
        strip.text.y.left = element_text(size = 10,face = "bold", color= "white"),
        axis.text.x.bottom = element_text(face = "bold", angle = 45, hjust = 1, color= "white"),
        axis.text.y.left = element_text(face = "bold", color= "white"),
        legend.title = element_text( size = 6, color= "white"),
        legend.text = element_text(size = 6,face = "bold", color= "white"),
        plot.title = element_text(size = 10, face = "bold", color= "white"),
        plot.subtitle = element_text(size = 9, color= "white"),
        plot.caption = element_text(size = 9, color= "white"), 
        strip.text = element_text(size = 9, face= "bold", colour = 'white'), 
        panel.grid.major = element_line(colour = "grey20"), 
        panel.grid.minor = element_line(colour = "grey20"))

draw_label_themeRKwhite <- function(label, theme = awhite, element = "text", ...) {
  elements <- ggplot2::calc_element(element, theme)
  cowplot::draw_label(label, 
                      fontfamily = elements$family,
                      fontface = elements$face,
                      colour = OutlineColor,
                      size = elements$size,
                      ... )}

draw_label_themeRK <- function(label, theme = atheme, element = "text", ...) {
  if (is.null(theme)) {
    theme <- ggplot2::theme_get()
  }
  if (!element %in% names(theme)) {
    stop("Element must be a valid ggplot theme element name")
  }
  elements <- ggplot2::calc_element(element, theme)
  cowplot::draw_label(label, 
                      fontfamily = elements$family,
                      fontface = elements$face,
                      colour = elements$color,
                      size = elements$size,
                      ... )}

#############################################
#Deseq2 Results procession for Visualization#
#############################################
resProcessRK <- function(dat){
  require(stringr)
  require(sjmisc)
dat <- lapply(dat, function(x) {as.data.frame(x);return(x)}) 
dat2 <- list() 
  for (x in 1:length(dat)){ 
  tryCatch({
    GeneRatio <- as.numeric((as.data.frame(lengths(str_split(dat[[x]]$core_enrichment, "/"))) / as.data.frame(dat[[x]]$setSize))[,1])
    Output<-cbind(dat[[x]], as.data.frame(GeneRatio))
    dat2[[x]] <- Output  
    names(dat2)[[x]] <- names(dat)[[x]]
  }, error=function(e){cat("ERROR :",conditionMessage(e), "\n")})}
dat2<-dat2[lapply(dat2,length)>0]
library(sjmisc)
dat2<- lapply(dat2, function(x) {x$DescriptionWrap <-word_wrap(x$Description, 40);return(x)})
dat2<- lapply(dat2, function(x) {x$sign <-ifelse(sign(x$NES) > 0, "activated", "suppressed");return(x)})
dat2}
```


## 2.1 PCAs 

```{r}
print("PCA plots dapted from Marini F, Binder H (2019). “pcaExplorer: an R/Bioconductor package for interacting with RNA-seq principal components.” BMC Bioinformatics, 20(1), 331. doi:10.1186/s12859-019-2879-1, https://bioconductor.org/packages/pcaExplorer/.")

pcaplotRK2 <- function (x, intgroup = "condition", ntop = 1000, returnData = FALSE, 
    title = NULL, pcX = 1, pcY = 2, text_labels = TRUE, point_size = 2, 
    ellipse = TRUE, ellipse.prob = 0.95) 
{
      print(
      "Adapted from Marini F, Binder H (2019). “pcaExplorer: an R/Bioconductor package for interacting with RNA-seq principal components.” BMC Bioinformatics, 20(1), 331. doi:10.1186/s12859-019-2879-1, https://bioconductor.org/packages/pcaExplorer/.")
  require("ggrepel")
  require("plyr")
    rv <- rowVars(assay(x))
    select <- order(rv, decreasing = TRUE)[seq_len(min(ntop, 
        length(rv)))]
    pca <- prcomp(t(assay(x)[select, ]))
    percentVar <- pca$sdev^2/sum(pca$sdev^2)
    if (!all(intgroup %in% names(colData(x)))) {
        stop("the argument 'intgroup' should specify columns of colData(x)")
    }
    intgroup.df <- as.data.frame(colData(x)[, intgroup, drop = FALSE])
    group <- factor(apply(intgroup.df, 1, paste, collapse = " : "))
    d <- data.frame(PC1 = pca$x[, pcX], PC2 = pca$x[, pcY], group = group, 
        intgroup.df, names = colnames(x))
    colnames(d)[1] <- paste0("PC", pcX)
    colnames(d)[2] <- paste0("PC", pcY)
    if (returnData) {
        attr(d, "percentVar") <- percentVar[c(pcX, pcY)]
        return(d)
    }
    d$hjust <- ifelse((sign(d[, paste0("PC", pcX)]) == 1), 0.9, 
        0.1)
    g <- ggplot(data = d, aes_string(x = paste0("PC", pcX), y = paste0("PC", 
        pcY), color = "group")) + geom_point(size = point_size) + 
        xlab(paste0("PC", pcX, ": ", round(percentVar[pcX] * 
            100, digits = 2), "% variance")) + ylab(paste0("PC", 
        pcY, ": ", round(percentVar[pcY] * 100, digits = 2), 
        "% variance"))
    if (ellipse) {
        theta <- c(seq(-pi, pi, length = 50), seq(pi, -pi, length = 50))
        circle <- cbind(cos(theta), sin(theta))
        ell <- plyr::ddply(d, "group", function(x) {
            if (nrow(x) <= 2) {
                return(NULL)
            }
            sigma <- var(cbind(x[[paste0("PC", pcX)]], x[[paste0("PC", 
                pcY)]]))
            mu <- c(mean(x[[paste0("PC", pcX)]]), mean(x[[paste0("PC", 
                pcY)]]))
            ed <- sqrt(qchisq(ellipse.prob, df = 2))
            data.frame(sweep(circle %*% chol(sigma) * ed, 2, 
                mu, FUN = "+"), groups = x$group[1])
        })
        if (nrow(ell) > 0) {
            g <- g + geom_path(data = ell, aes_string(x = "X1", 
                y = "X2", color = "groups", group = "groups"))
        }
    }
    if (text_labels) 
        g <- g + ggrepel::geom_label_repel(mapping = aes_string(label = "names", 
            fill = "group"), color = "white", show.legend = TRUE) #size=2
    plot_title <- paste0("PCA plot - top ", length(select), " variable genes")
    if (!is.null(title)) {
        g <- g + ggtitle(title)
    }
    else {
        g <- g + ggtitle(plot_title)
    }
    g <- g + coord_fixed()
    g
}

pcaplotRK3<-function (x, intgroup = "condition", ntop = 500, returnData = FALSE, 
    title = NULL, pcX = 1, pcY = 2, text_labels = TRUE, point_size = 3, 
    ellipse = TRUE, ellipse.prob = 0.95) 
{
      print(
      "Adapted from Marini F, Binder H (2019). “pcaExplorer: an R/Bioconductor package for interacting with RNA-seq principal components.” BMC Bioinformatics, 20(1), 331. doi:10.1186/s12859-019-2879-1, https://bioconductor.org/packages/pcaExplorer/.")
  require("ggrepel")
  require("plyr")
  require("SummarizedExperiment")
    rv <- MatrixGenerics::rowVars(assay(x))
    select <- order(rv, decreasing = TRUE)[seq_len(min(ntop, 
        length(rv)))]
    pca <- prcomp(t(assay(x)[select, ]))
    percentVar <- pca$sdev^2/sum(pca$sdev^2)
    if (!all(intgroup %in% names(colData(x)))) {
        stop("the argument 'intgroup' should specify columns of colData(x)")
    }
    intgroup.df <- as.data.frame(colData(x)[, intgroup, drop = FALSE])
    group <- factor(apply(intgroup.df, 1, paste, collapse = " : "))
    d <- data.frame(PC1 = pca$x[, pcX], PC2 = pca$x[, pcY], group = group, 
        intgroup.df, names = colnames(x))
    colnames(d)[1] <- paste0("PC", pcX)
    colnames(d)[2] <- paste0("PC", pcY)
    if (returnData) {
        attr(d, "percentVar") <- percentVar[c(pcX, pcY)]
        return(d)
    }
    d$hjust <- ifelse((sign(d[, paste0("PC", pcX)]) == 1), 0.9, 
        0.1)
    
    g <- ggplot(data = d, aes_string(x = paste0("PC", pcX), y = paste0("PC", 
        pcY), color = "group")) + geom_point(size = point_size) + 
        xlab(paste0("PC", pcX, ": ", round(percentVar[pcX] * 
            100, digits = 2), "% variance")) + ylab(paste0("PC", 
        pcY, ": ", round(percentVar[pcY] * 100, digits = 2), 
        "% variance"))
    if (ellipse) {
        theta <- c(seq(-pi, pi, length = 50), seq(pi, -pi, length = 50))
        circle <- cbind(cos(theta), sin(theta))
        ell <- ddply(d, "group", function(x) {
            if (nrow(x) <= 2) {
                return(NULL)
            }
            sigma <- var(cbind(x[[paste0("PC", pcX)]], x[[paste0("PC", 
                pcY)]]))
            mu <- c(mean(x[[paste0("PC", pcX)]]), mean(x[[paste0("PC", 
                pcY)]]))
            ed <- sqrt(qchisq(ellipse.prob, df = 2))
            data.frame(sweep(circle %*% chol(sigma) * ed, 2, 
                mu, FUN = "+"), groups = x$group[1])
        })
        if (nrow(ell) > 0) {
            g <- g + geom_path(data = ell, aes_string(x = "X1", 
                y = "X2", color = "groups", group = "groups"))
        }
    }
    if (text_labels) 
        g <- g + geom_label_repel(mapping = aes_string(label = "names", 
            fill = "group"), size=1.2, color = "white", show.legend = TRUE)
    plot_title <- paste0("PCA plot - top ", length(select), " variable genes")
    if (!is.null(title)) {
        g <- g + ggtitle(title)
    }
    else {
        g <- g + ggtitle(plot_title)
    }
    g <- g + atheme
    g <- g + coord_fixed() 
    g
}  
   

pcaplotRK_publication <- function (x, intgroup = "condition", ntop = 500, returnData = FALSE, 
    title = NULL, pcX = 1, pcY = 2, text_labels = TRUE, point_size = 3, 
    ellipse = TRUE, ellipse.prob = 0.95, group_order = group_order) 
{
      print(
      "Adapted from Marini F, Binder H (2019). “pcaExplorer: an R/Bioconductor package for interacting with RNA-seq principal components.” BMC Bioinformatics, 20(1), 331. doi:10.1186/s12859-019-2879-1, https://bioconductor.org/packages/pcaExplorer/.")
  require("ggrepel")
  require("plyr")
    rv <- MatrixGenerics::rowVars(assay(x))
    select <- order(rv, decreasing = TRUE)[seq_len(min(ntop, 
        length(rv)))]
    pca <- prcomp(t(assay(x)[select, ]))
    percentVar <- pca$sdev^2/sum(pca$sdev^2)
    if (!all(intgroup %in% names(colData(x)))) {
        stop("the argument 'intgroup' should specify columns of colData(x)")
    }
    intgroup.df <- as.data.frame(colData(x)[, intgroup, drop = FALSE])
    group <- factor(apply(intgroup.df, 1, paste, collapse = " : "))
    d <- data.frame(PC1 = pca$x[, pcX], PC2 = pca$x[, pcY], group = group, 
        intgroup.df, names = colnames(x))
    colnames(d)[1] <- paste0("PC", pcX)
    colnames(d)[2] <- paste0("PC", pcY)
    if (returnData) {
        attr(d, "percentVar") <- percentVar[c(pcX, pcY)]
        return(d)
    }
    d$hjust <- ifelse((sign(d[, paste0("PC", pcX)]) == 1), 0.9, 
        0.1)
    d$group <- factor(d$group, levels = names(group_order))
    
    g <- ggplot(data = d, aes_string(x = paste0("PC", pcX), y = paste0("PC", 
        pcY), color = "group")) + 
      
      geom_point(size = point_size) + 
      
        xlab(paste0("PC", pcX, ": ", round(percentVar[pcX] * 
            100, digits = 2), "% variance")) + ylab(paste0("PC", 
        pcY, ": ", round(percentVar[pcY] * 100, digits = 2), 
        "% variance"))
    if (ellipse) {
        theta <- c(seq(-pi, pi, length = 50), seq(pi, -pi, length = 50))
        circle <- cbind(cos(theta), sin(theta))
        ell <- ddply(d, "group", function(x) {
            if (nrow(x) <= 2) {
                return(NULL)
            }
            sigma <- var(cbind(x[[paste0("PC", pcX)]], x[[paste0("PC", 
                pcY)]]))
            mu <- c(mean(x[[paste0("PC", pcX)]]), mean(x[[paste0("PC", 
                pcY)]]))
            ed <- sqrt(qchisq(ellipse.prob, df = 2))
            data.frame(sweep(circle %*% chol(sigma) * ed, 2, 
                mu, FUN = "+"), groups = x$group[1])
        })
        if (nrow(ell) > 0) {
            g <- g + geom_path(data = ell, aes_string(x = "X1", 
                y = "X2", color = "groups", group = "groups"))
        }
    }
    if (text_labels) 
        g <- g + geom_label_repel(mapping = aes_string(label = "names", 
            fill = "group"), size=1.2, color = "white", show.legend = TRUE)
    plot_title <- paste0("PCA plot - top ", length(select), " variable genes")
    if (!is.null(title)) {
        g <- g + ggtitle(title)
    }
    else {
        g <- g + ggtitle(plot_title)
    }
    g <- g + atheme
    g <- g + coord_fixed() 
    g
}  
  


#All Code Adapted from: 
#https://github.com/kevinblighe/PCAtools 
#https://bioconductor.org/packages/devel/bioc/vignettes/PCAtools/inst/doc/PCAtools.html
  print(
"Pairsplots adapted from https://github.com/kevinblighe/PCAtools 
#https://bioconductor.org/packages/devel/bioc/vignettes/PCAtools/inst/doc/PCAtools.html")
  
pairsplotRK <- function (pcaobj, components = getComponents(pcaobj, seq_len(5)), 
    triangle = TRUE, trianglelabSize = 18, plotaxes = F, margingaps = unit(c(0.1, 
        0.1, 0.1, 0.1), "cm"), ncol = NULL, nrow = NULL, x = NULL, 
    y = NULL, colby = NULL, colkey = NULL, singlecol = NULL, 
    shape = NULL, shapekey = NULL, pointSize = 1, legendPosition = "none", 
    legendLabSize = 6, legendIconSize = 1.5, xlim = NULL, ylim = NULL, 
    lab = NULL, labSize = 1.5, selectLab = NULL, drawConnectors = FALSE, 
    widthConnectors = 0.5, colConnectors = "grey50", xlab = NULL, 
    xlabAngle = 0, xlabhjust = 0.5, xlabvjust = 0.5, ylab = NULL, 
    ylabAngle = 0, ylabhjust = 0.5, ylabvjust = 0.5, axisLabSize = 10, 
    title = NULL, titleLabSize = 32, hline = NULL, hlineType = "longdash", 
    hlineCol = "grey50", hlineWidth = 0.4, vline = NULL, vlineType = "longdash", 
    vlineCol = "grey50", vlineWidth = 0.4, gridlines.major = TRUE, 
    gridlines.minor = TRUE, borderWidth = 0.8, borderColour = "white", 
    returnPlot = TRUE) 
{
  print(
"Adapted from https://github.com/kevinblighe/PCAtools 
#https://bioconductor.org/packages/devel/bioc/vignettes/PCAtools/inst/doc/PCAtools.html")
    biplots <- list()
    nplots <- 0
    for (i in seq_along(components)) {
        if (triangle == TRUE) {
            nplots <- nplots + 1
            biplots[[nplots]] <- ggdraw() + draw_label(x = 0.6, colour = "white",
                y = 0.6, paste0(components[i], ",\n", round(pcaobj$variance[components[i]], 
                  digits = 2), "%"), fontface = "bold", size = trianglelabSize)
            names(biplots)[nplots] <- "Label"
        }
        for (j in seq_along(components)) {
            if (i != j && i < j) {
                nplots <- nplots + 1
                x <- components[i]
                y <- components[j]
                biplots[[nplots]] <- biplot(pcaobj, x = x, y = y, 
                  colby = colby, colkey = colkey, singlecol = singlecol, 
                  shape = shape, shapekey = shapekey, selectLab = selectLab, 
                  xlim = xlim, ylim = ylim, lab = lab, xlab = paste0(x, 
                    ", ", round(pcaobj$variance[x], digits = 2), 
                    "%"), xlabAngle = xlabAngle, xlabhjust = xlabhjust, 
                  xlabvjust = xlabvjust, ylab = paste0(y, ", ", 
                    round(pcaobj$variance[y], digits = 2), "%"), 
                  ylabAngle = ylabAngle, ylabhjust = ylabhjust, 
                  ylabvjust = ylabvjust, axisLabSize = axisLabSize, 
                  pointSize = pointSize, labSize = labSize, legendPosition = legendPosition, 
                  legendLabSize = legendLabSize, legendIconSize = legendIconSize, 
                  drawConnectors = drawConnectors, widthConnectors = widthConnectors, 
                  colConnectors = colConnectors, hline = hline, 
                  hlineType = hlineType, hlineCol = hlineCol, 
                  hlineWidth = hlineWidth, vline = vline, vlineType = vlineType, 
                  vlineCol = vlineCol, vlineWidth = vlineWidth, 
                  gridlines.major = gridlines.major, gridlines.minor = gridlines.minor, 
                  borderWidth = borderWidth, borderColour = borderColour, 
                  returnPlot = returnPlot)
                names(biplots)[nplots] <- paste(components[i], 
                  "Vs", components[j])
            }
        }
    }
    margin <- theme(plot.margin = margingaps, plot.title = element_blank(), 
        plot.subtitle = element_blank(), plot.caption = element_blank())
    title <- ggdraw() + draw_label(title, fontface = "bold", 
        size = titleLabSize, colour = "white")
    if (triangle) {
        ncol <- nrow <- length(components)
        biplots.final <- list()
        nplots.final <- 0
        nplots.original <- 0
        l <- 0
        for (k in seq_along(components)) {
            numplot <- length(grep(paste0("^", components[k]), 
                names(biplots))) + 1
            l <- numplot
            while (l < length(components)) {
                nplots.final <- nplots.final + 1
                biplots.final[[nplots.final]] <- ggdraw() + draw_label(x = 0.5, 
                  y = 0.5, "", fontface = "bold", size = 32, colour = "white")
                l <- l + 1
            }
            for (m in seq_len(numplot)) {
                nplots.final <- nplots.final + 1
                nplots.original <- nplots.original + 1
                biplots.final[[nplots.final]] <- biplots[[nplots.original]]
            }
        }
        if (!plotaxes) {
            margin <- margin  + theme(
              panel.border = element_blank(),
              panel.grid = element_blank(),
              panel.background = element_rect(fill='transparent'),
              plot.background = element_rect(fill='transparent', color=NA),
              panel.grid.major = element_blank(),
              panel.grid.minor = element_blank(),
              legend.background = element_rect(fill='transparent'),
              legend.box.background = element_rect(fill='transparent'),
              axis.text.x = element_blank(), 
              axis.text.y = element_blank(), axis.ticks.x = element_blank(), 
              axis.ticks.y = element_blank(), axis.title = element_blank()) + panel_border(colour="grey15")
        }
        else if (plotaxes) {
            margin <- margin
        }
        biplots.final <- lapply(biplots.final, "+", margin)
        biplots.final <- lapply(biplots.final, "+", coord_flip())
        if (returnPlot) {
            return(plot_grid(title, do.call(plot_grid, c(biplots.final, 
                ncol = ncol, nrow = nrow)), ncol = 1, rel_heights = c(0.1, 
                1)))
        }
        else if (!returnPlot) {
            plot_grid(title, do.call(plot_grid, c(biplots.final, 
                ncol = ncol, nrow = nrow)), ncol = 1, rel_heights = c(0.1, 
                1))
        }
    }
    else if (!triangle) {
        if (is.null(ncol)) {
            ncol <- length(components) - 1
        }
        else {
            ncol <- ncol
        }
        if (is.null(nrow)) {
            nrow <- ceiling(ncol/2) + 1
        }
        else {
            nrow <- nrow
        }
        if (!plotaxes) {
              margin <- margin  + theme(
              panel.border = element_blank(),
              panel.grid = element_blank(),
              panel.background = element_rect(fill='transparent'),
              plot.background = element_rect(fill='transparent', color=NA),
              panel.grid.major = element_blank(),
              panel.grid.minor = element_blank(),
              legend.background = element_rect(fill='transparent'),
              legend.box.background = element_rect(fill='transparent'),
              axis.text.x = element_blank(), 
              axis.text.y = element_blank(), axis.ticks.x = element_blank(), 
              axis.ticks.y = element_blank(), axis.title = element_blank()) + panel_border(colour="grey15")
        }
        else if (plotaxes) {
            margin <- margin
        }
        biplots <- lapply(biplots, "+", margin)
        if (returnPlot) {
            return(plot_grid(title, do.call(plot_grid, c(biplots, 
                ncol = ncol, nrow = nrow)), ncol = 1, rel_heights = c(0.1, 
                1)))
        }
        else if (!returnPlot) {
            plot_grid(title, do.call(plot_grid, c(biplots, ncol = ncol, 
                nrow = nrow)), ncol = 1, rel_heights = c(0.1, 
                1))
        }
    }
}

# PCAtools 
#https://github.com/kevinblighe/plotloadingsRK
plotloadingsRK <- function (pcaobj, components = getComponents(pcaobj, seq_len(5)), 
    rangeRetain = 0.05, absolute = FALSE, col = c("gold", "white", 
        "royalblue"), colMidpoint = 0, shape = 21, shapeSizeRange = c(10, 
        10), legendPosition = "top", legendLabSize = 10, legendIconSize = 3, 
    xlim = NULL, ylim = NULL, labSize = 2, labhjust = 1.5, labvjust = 0, 
    drawConnectors = TRUE, positionConnectors = "right", widthConnectors = 0.5, 
    typeConnectors = "closed", endsConnectors = "first", lengthConnectors = unit(0.01, 
        "npc"), colConnectors = "grey50", xlab = "Principal component", 
    xlabAngle = 0, xlabhjust = 0.5, xlabvjust = 0.5, ylab = "Component loading", 
    ylabAngle = 0, ylabhjust = 0.5, ylabvjust = 0.5, axisLabSize = 16, 
    title = "", subtitle = "", caption = "", titleLabSize = 16, 
    subtitleLabSize = 12, captionLabSize = 12, hline = c(0), 
    hlineType = "longdash", hlineCol = "black", hlineWidth = 0.4, 
    vline = NULL, vlineType = "longdash", vlineCol = "black", 
    vlineWidth = 0.4, gridlines.major = TRUE, gridlines.minor = TRUE, 
    borderWidth = 0.8, borderColour = "black", returnPlot = TRUE) 
{
    x <- pcaobj$loadings[, components, drop = FALSE]
    retain <- c()
    for (i in seq_along(components)) {
        offset <- (max(x[, i]) - min(x[, i])) * rangeRetain
        uppercutoff <- max(x[, i]) - offset
        lowercutoff <- min(x[, i]) + offset
        retain <- unique(c(retain, which(x[, i] >= uppercutoff), 
            which(x[, i] <= lowercutoff)))
    }
    message("-- variables retained:")
    message(paste0(rownames(x)[retain], collapse = ", "))
    x <- x[retain, , drop = FALSE]
    PC <- Loading <- NULL
    x <- data.frame(rownames(x), x[, components, drop = FALSE])
    colnames(x)[1] <- "var"
    plotobj <- reshape2::melt(x, id = "var")
    colnames(plotobj) <- c("var", "PC", "Loading")
    if (absolute == TRUE) {
        plotobj$Loading <- abs(plotobj$Loading)
    }
    else if (absolute == FALSE) {
        plotobj$Loading <- plotobj$Loading
    }
    th <- theme_bw(base_size = 24) + theme(legend.background = element_rect(), 
        plot.title = element_text(angle = 0, size = titleLabSize, 
            face = "bold", vjust = 1), plot.subtitle = element_text(angle = 0, 
            size = subtitleLabSize, face = "plain", vjust = 1), 
        plot.caption = element_text(angle = 0, size = captionLabSize, 
            face = "plain", vjust = 1), axis.line = element_line(size = 1.5, 
            colour = "white"), axis.text.x = element_text(angle = xlabAngle, 
            size = axisLabSize, hjust = xlabhjust, vjust = xlabvjust), 
        axis.text.y = element_text(angle = ylabAngle, size = axisLabSize, 
            hjust = ylabhjust, vjust = ylabvjust), axis.title = element_text(size = axisLabSize), 
        legend.position = legendPosition, legend.direction = "horizontal", 
        legend.box = "horizontal", legend.key = element_blank(), 
        legend.key.size = unit(0.5, "cm"), legend.text = element_text(size = legendLabSize), 
        title = element_text(size = legendLabSize), legend.title = element_blank())
    plot <- ggplot(plotobj, aes(x = PC, y = Loading, size = Loading, 
        fill = Loading)) + th + geom_point(shape = shape) + labs(title = title, 
        subtitle = subtitle, caption = caption) + labs(x = xlab, 
        y = ylab, size = ylab, fill = ylab) + guides(fill = guide_legend(), 
        size = guide_legend(), colour = guide_legend(override.aes = list(size = legendIconSize)))
    plot <- plot + scale_size(range = shapeSizeRange)
    if (length(col) == 2) {
        plot <- plot + scale_fill_continuous(low = col[1], high = col[2])
    }
    else if (length(col) == 3) {
        plot <- plot + scale_fill_gradient2(low = col[1], mid = col[2], 
            high = col[3], midpoint = colMidpoint, space = "Lab")
    }
    if (!is.null(xlim)) {
        plot <- plot + xlim(xlim[1], xlim[2])
    }
    if (!is.null(ylim)) {
        plot <- plot + ylim(ylim[1], ylim[2])
    }
    if (!is.null(vline)) {
        plot <- plot + geom_vline(xintercept = vline, linetype = vlineType, 
            colour = vlineCol, size = vlineWidth)
    }
    if (!is.null(hline)) {
        plot <- plot + geom_hline(yintercept = hline, linetype = hlineType, 
            colour = hlineCol, size = hlineWidth)
    }
    plot <- plot + theme(panel.border = element_rect(colour = borderColour, 
        fill = NA, size = borderWidth))
    if (gridlines.major == TRUE) {
        plot <- plot + theme(panel.grid.major = element_line())
    }
    else {
        plot <- plot + theme(panel.grid.major = element_blank())
    }
    if (gridlines.minor == TRUE) {
        plot <- plot + theme(panel.grid.minor = element_line())
    }
    else {
        plot <- plot + theme(panel.grid.minor = element_blank())
    }
    if (drawConnectors == TRUE) {
        plot <- plot + geom_text_repel(colour= OutlineColor, data = plotobj, aes(label = as.character(var)), 
            size = labSize, nudge_x = ifelse(positionConnectors == 
                "left", -0.75, ifelse(positionConnectors == "right", 
                0.75, 0)), direction = "y", segment.color = colConnectors, 
            segment.size = widthConnectors, arrow = arrow(length = lengthConnectors, 
                type = typeConnectors, ends = endsConnectors), 
            show.legend = FALSE, hjust = labhjust, vjust = labvjust)
    }
    else if (drawConnectors == FALSE) {
        plot <- plot + geom_text(colour= OutlineColor, data = plotobj, aes(label = as.character(var)), 
            size = labSize, check_overlap = TRUE, show.legend = FALSE, 
            hjust = labhjust, vjust = labvjust)
    }
    if (returnPlot == TRUE) {
        return(plot)
    }
    else if (returnPlot == FALSE) {
        plot
    }
}
```

# -

# 3 SSU

## 3.1 Create Color Code

```{r, message=FALSE, warning=FALSE}
    ######################
    #Define Phylum Colors#
    ######################
    phylum_colors <- c(
          "Actinobacteriota"  = "red", 
          "Cyanobacteria"     = "green", 
          "Bacteroidota"      = "darkgreen",
          "Proteobacteria1"    = "darkorange2", 
          "Proteobacteria2"    = "#663300",
          #"Patescibacteria"  = "pink", 
          "Acidobacteriota "  = "#FF00CC",
          "Planctomycetota"   = "purple", 
          "Verrucomicrobiota" = "blue", 
          "Chloroflexota"     = "cyan",
          "Deinococcota"      = "#FFFF00",
          "Gemmatimonadota"   = "#8F7C00",  
          "Other" = "grey20")

     phylum_colors_Cytoscape <- c(
          "Actinobacteriota"  = "red", 
          "Cyanobacteria"     = "green", 
          "Bacteroidota"      = "darkgreen",
          "Proteobacteria"    = "#FF6600", 
          "Acidobacteriota "  = "#FF00CC",
          "Planctomycetota"   = "purple", 
          "Verrucomicrobiota" = "blue", 
          "Chloroflexota"     = "cyan",
          "Deinococcota"      = "#FFFF00",
          "Gemmatimonadota"   = "#8F7C00",  
          "Other" = "grey20")

generate_shades <- function(base_color, num_variations) {
    color_ramp <- colorRampPalette(c(base_color, "white"))
    # Generate a vector of colors
    colors <- color_ramp(num_variations+1)
    # Create a data frame with the colors
    color_palette <- colors[1:(length(colors) - 1)]
    return(color_palette)}
```

## 3.2 SSU basic functions 

```{r}
#https://rdrr.io/github/microbiome/microbiome/src/R/add_besthit.R
#@author Contact: Sudarshan A. Shetty \email{sudarshanshetty9@@gmail.com}
add_besthit <- function(x, sep=":"){
  
  Class<-Domain<- Family<- Genus<- Genus.Species<- NULL
  Order<- Phylum<- Species<-NULL
  
  x.nw <- x
  if(length(rank_names(x.nw))== 6){
    colnames(tax_table(x.nw)) <- c("Kingdom", "Phylum", "Class", "Order", "Family", "Genus")
  }
  if(length(rank_names(x.nw))==7){
    colnames(tax_table(x.nw)) <- c("Kingdom", "Phylum", "Class", "Order", "Family", "Genus", "Species")
  }
  
  tax.tib <- .get_taxa_tib_unite(x)
  
  tax.tib <- tax.tib %>% 
    dplyr::mutate(Kingdom =ifelse(is.na(Kingdom), "Unclassifed", Kingdom),
                  Phylum =ifelse(is.na(Phylum), Kingdom, Phylum),
                  Class =ifelse(is.na(Class), Phylum, Class),
                  Order =ifelse(is.na(Order), Class, Order),
                  Family =ifelse(is.na(Family), Order, Family),
                  Genus =ifelse(is.na(Genus), Family, Genus)) 
  if(length(rank_names(x))==7){
    tax.tib <- tax.tib %>%
      dplyr::mutate(Species =ifelse(is.na(Species), Genus, Species))
  }
  
  best_hit <- paste0(taxa_names(x), sep,tax.tib[,ncol(tax.tib)])
  
  taxa_names(x) <- best_hit
  return(x)
}
.get_taxa_tib_unite <- function(x){
  
  Genus<- Species <- Genus.Species<- NULL
  tax.tib <- tax_table(x) %>% 
    as.matrix() %>% 
    as.data.frame() 
  
  #n.rk <- length(rank_names(x))
  if(any(rank_names(x) == "Species") && any(rank_names(x) == "Genus")){
    
    tax.tib <- tax.tib %>% 
      dplyr::mutate(Genus.Species = ifelse(!is.na(Species), 
                                           paste0(Genus, ".", Species), Species)) %>%
      dplyr::select(-Species) %>%
      dplyr::rename(Species = Genus.Species)
    
  }
  return(tax.tib)
}



#https://github.com/pmartinezarbizu/pairwiseAdonis/blob/master/pairwiseAdonis/R/pairwise.adonis.R
#@author Pedro Martinez Arbizu & Sylvain Monteux
pairwise.adonis <- function(x,factors, sim.function = 'vegdist', sim.method = 'bray', p.adjust.m ='bonferroni',reduce=NULL,perm=999)
{

  co <- combn(unique(as.character(factors)),2)
  pairs <- c()
  Df <- c()
  SumsOfSqs <- c()
  F.Model <- c()
  R2 <- c()
  p.value <- c()


  for(elem in 1:ncol(co)){
    if(inherits(x, 'dist')){
      x1=as.matrix(x)[factors %in% c(as.character(co[1,elem]),as.character(co[2,elem])),
                      factors %in% c(as.character(co[1,elem]),as.character(co[2,elem]))]
      }

    else  (
      if (sim.function == 'daisy'){
            x1 = daisy(x[factors %in% c(co[1,elem],co[2,elem]),],metric=sim.method)
        }
      else{x1 = vegdist(x[factors %in% c(co[1,elem],co[2,elem]),],method=sim.method)}
    )

    x2 = data.frame(Fac = factors[factors %in% c(co[1,elem],co[2,elem])])

    ad <- adonis2(x1 ~ Fac, data = x2,
                 permutations = perm);
    pairs <- c(pairs,paste(co[1,elem],'vs',co[2,elem]));
    Df <- c(Df,ad$Df[1])
	SumsOfSqs <- c(SumsOfSqs,ad$SumOfSqs[1])
	F.Model <- c(F.Model,ad$F[1]);
    R2 <- c(R2,ad$R2[1]);
    p.value <- c(p.value,ad$`Pr(>F)`[1])
  }
  p.adjusted <- p.adjust(p.value,method=p.adjust.m)

  sig = c(rep('',length(p.adjusted)))
  sig[p.adjusted <= 0.05] <-'.'
  sig[p.adjusted <= 0.01] <-'*'
  sig[p.adjusted <= 0.001] <-'**'
  sig[p.adjusted <= 0.0001] <-'***'
  pairw.res <- data.frame(pairs,Df,SumsOfSqs,F.Model,R2,p.value,p.adjusted,sig)

  if(!is.null(reduce)){
    pairw.res <- subset (pairw.res, grepl(reduce,pairs))
    pairw.res$p.adjusted <- p.adjust(pairw.res$p.value,method=p.adjust.m)

    sig = c(rep('',length(pairw.res$p.adjusted)))
 	sig[pairw.res$p.adjusted <= 0.1] <-'.'
	sig[pairw.res$p.adjusted <= 0.05] <-'*'
	sig[pairw.res$p.adjusted <= 0.01] <-'**'
	sig[pairw.res$p.adjusted <= 0.001] <-'***'
    pairw.res <- data.frame(pairw.res[,1:7],sig)
  }
  class(pairw.res) <- c("pwadonis", "data.frame")
  return(pairw.res)
}


### Method summary
summary.pwadonis = function(object, ...) {
  cat("Result of pairwise.adonis:\n")
  cat("\n")
  print(object, ...)
  cat("\n")
  cat("Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n")
}


#https://github.com/pmartinezarbizu/pairwiseAdonis/blob/master/pairwiseAdonis/R/pairwise.adonis2.R
#@author Pedro Martinez Arbizu
pairwise.adonis2 <- function(x, data, strata = NULL, nperm=999, ... ) {

#describe parent call function
ststri <- ifelse(is.null(strata),'Null',strata)
fostri <- as.character(x)
#list to store results

#copy model formula
   x1 <- x
# extract left hand side of formula
  lhs <- eval(x1[[2]], environment(x1), globalenv())
  environment(x1) <- environment()
# extract factors on right hand side of formula
  rhs <- x1[[3]]
# create model.frame matrix
  x1[[2]] <- NULL
  rhs.frame <- model.frame(x1, data, drop.unused.levels = TRUE)

# create unique pairwise combination of factors
  co <- combn(unique(as.character(rhs.frame[,1])),2)

# create names vector
  nameres <- c('parent_call')
  for (elem in 1:ncol(co)){
  nameres <- c(nameres,paste(co[1,elem],co[2,elem],sep='_vs_'))
  }
#create results list
  res <- vector(mode="list", length=length(nameres))
  names(res) <- nameres

#add parent call to res
res['parent_call'] <- list(paste(fostri[2],fostri[1],fostri[3],', strata =',ststri, ', permutations',nperm ))


#start iteration trough pairwise combination of factors
 for(elem in 1:ncol(co)){

#reduce model elements
	if(inherits(eval(lhs),'dist')){
	    xred <- as.dist(as.matrix(eval(lhs))[rhs.frame[,1] %in% c(co[1,elem],co[2,elem]),
		rhs.frame[,1] %in% c(co[1,elem],co[2,elem])])
	}else{
	xred <- eval(lhs)[rhs.frame[,1] %in% c(co[1,elem],co[2,elem]),]
	}

	mdat1 <-  data[rhs.frame[,1] %in% c(co[1,elem],co[2,elem]),]

# redefine formula
	if(length(rhs) == 1){
		xnew <- as.formula(paste('xred',as.character(rhs),sep='~'))
		}else{
		xnew <- as.formula(paste('xred' ,
					paste(rhs[-1],collapse= as.character(rhs[1])),
					sep='~'))}

#pass new formula to adonis
	if(is.null(strata)){
	ad <- adonis2(xnew,data=mdat1, ... )
	}else{
	perm <- how(nperm = nperm)
    setBlocks(perm) <- with(mdat1, mdat1[,ststri])
    ad <- adonis2(xnew,data=mdat1,permutations = perm, ... )}

  res[nameres[elem+1]] <- list(ad[1:5])
  }
  #names(res) <- names
  class(res) <- c("pwadstrata", "list")
  return(res)
}


### Method summary
summary.pwadstrata = function(object, ...) {
  cat("Result of pairwise.adonis2:\n")
  cat("\n")
  print(object[1], ...)
  cat("\n")

  cat("Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n")
}
```

## 3.3 BacteriaHeatPlot

```{r}
#https://www.stat.berkeley.edu/~s133/Cluster2a.html
#The R cluster library provides a modern alternative to k-means clustering, known as pam, which is an acronym for "Partitioning around Medoids". The term medoid refers to an observation within a cluster for which the sum of the distances between it and all the other members of the cluster is a minimum. pam requires that you know the number of clusters that you want (like k-means clustering), but it does more computation than k-means in order to insure that the medoids it finds are truly representative of the observations within a given cluster. Recall that in the k-means method the centers of the clusters (which might or might not actually correspond to a particular observation) are only recaculated after all of the observations have had a chance to move from one cluster to another. With pam, the sums of the distances between objects within a cluster are constantly recalculated as observations move around, which will hopefully provide a more reliable solution. Furthermore, as a by-product of the clustering operation it identifies the observations that represent the medoids, and these observations (one per cluster) can be considered a representative example of the members of that cluster which may be useful in some situations. pam does require that the entire distance matrix is calculated to facilitate the recalculation of the medoids, and it does involve considerably more computation than k-means, but with modern computers this may not be a important consideration. As with k-means, there's no guarantee that the structure that's revealed with a small number of clusters will be retained when you increase the number of clusters.


BacteriaHeatPlotRK6 <- function (res = res, vst = vst, Species = Species, min_count = 10, genes_of_interest = genes_of_interest, Samples = Samples, SAMDF = SAMDF,  TITLE = TITLE, filename= FILENAME) {
  paste("Code Raphael Koll raphael.koll@uni-hamburg.de code adapted from https://github.com/kevinblighe/E-MTAB-6141")
  require(RColorBrewer)
  require(ComplexHeatmap)
  require(Cairo)
  require(circlize)
  require(digest)
  require(cluster)
  require(ComplexHeatmap)
  require(grid)
  require(DESeq2)
  require(tidyverse)
  require(ggplot2)
  
  #res <- res[res$baseMean >= 10,] #Select Species with Basemean higher 10
  #Output     <- vst[rownames(vst) %in% ress$rowname,]
  #Output2    <- Output[(rowSums(Output > min_count) >= 3),]
  #Output3    <- vst[rownames(vst) %in% rownames(Output2),]
  Output4    <- vst[rownames(vst) %in% genes_of_interest,]

  #z-Score of vst data
  heat       <- t(scale(t(as.matrix(Output4[, Samples]))))
  #sub uncharacterized for shorter names in heatmap
  rownames(heat) <- gsub("uncharacterized ", "",rownames(heat))
  #make and order metadate fitting to matrix
  metadata   <- SAMDF[SAMDF$SampleID %in% colnames(heat),]
  metadata   <- metadata[order(match(metadata$SampleID, colnames(heat))), , drop = FALSE]
  #create top-annotation
  
  LOCOrder <- LOCOrder[LOCOrder %in% metadata$LOC]
  CruiseOrder <- CruiseOrder[CruiseOrder %in% metadata$Cruise]
  
  annLOC        <- data.frame(Location = metadata$fLOC)#,stringsAsFactors = FALSE)
  annCruise     <- data.frame(Season   = metadata$fCruise)
  anno_df = data.frame(
    Location = annLOC,
    Season = annCruise)
  
    COL.LOC <- col.Palette$col.Palette.LOC[names(col.Palette$col.Palette.LOC) %in% metadata$LOC]
    COL.Cruises <- col.Palette$col.Palette.Cruise[names(col.Palette$col.Palette.Cruise) %in% metadata$Cruise]
  
  colAnn <-HeatmapAnnotation(
    annotation_name_side = "left",
    df =   anno_df,
    title = NULL,
    which = 'col', # 'col' (samples) or 'row' (gene) annotation?
    na_col = 'white', # default colour for any NA values in the annotation data-frame, 'ann'

    col = list(Location = COL.LOC,
               Season = COL.Cruises), 
    annotation_height = 0.4,
    annotation_width = unit(0.5, 'cm'),
    gap = unit(1, 'mm'),
    annotation_legend_param = list(
      Location = list(
        nrow = 1, # number of rows across which the legend will be arranged
        title = "Location", #
        title_position = 'topcenter',
        legend_direction = 'vertical',
        title_gp = gpar(col = "white",fontsize = 7, fontface = 'bold'),
        labels_gp = gpar(col = "white",fontsize = 7, fontface = 'bold')),
      Season = list(
        nrow = 1, # number of rows across which the legend will be arranged
        title = "Season", #
        title_position = 'topcenter',
        legend_direction = 'vertical',
        title_gp = gpar(col = "white",fontsize = 7, fontface = 'bold'),
        labels_gp = gpar(col = "white",fontsize = 7, fontface = 'bold'))))
      

  #label every 40th gene
   labelseqs<-if (dim(heat)[1] <= 150) { 
    labelseqs<- 1
    } else if (dim(heat)[1] <= 1000) {
    labelseqs<- 10
    } else {
    labelseqs<- 100}
  genelabels <- ComplexHeatmap::rowAnnotation(
    Genes = anno_mark(
      at = seq(1, nrow(heat), labelseqs),                         #Adjust the amount of lables
      labels = rownames(heat)[seq(1, nrow(heat), labelseqs)],
      labels_gp = gpar(col = "white",fontsize = 6, fontface = 'bold'),
      padding = 0.75),
      width = unit(1.0, 'cm') +
      ComplexHeatmap::max_text_width(
        rownames(heat)[seq(1, nrow(heat), 30)],
        gp = gpar(col = "white",fontsize = 6,  fontface = 'bold')))
  #define clusters, read from unclustered heatmap


  pamClusters <- cluster::pam(heat, k = rowclusternum) # pre-select k = 4 centers
  pamClusters$clustering <- paste0('Cluster ', pamClusters$clustering)
  # fix order of the clusters to have 1 to 4, top to bottom
  # fix order of the clusters to have 1 to 4, top to bottom
  pamClusters$clustering <- factor(pamClusters$clustering,
    levels = c('Cluster 1', 'Cluster 2', 'Cluster 3', 'Cluster 4', 'Cluster 5', 'Cluster 6'))
  myCol <- colorRampPalette(c('blue', 'white', 'red'))(100)
  myBreaks <- seq(-3, 3, length.out = 100)
  #create heatmap

    hmap <- Heatmap(heat, #raster_device ="png",
    # split the genes / rows according to the PAM clusters
      split = pamClusters$clustering,
      column_km = columnclusternum,
      cluster_row_slices = FALSE,
    name = 'Taxa\nZ-\nscore',
    col = colorRamp2(myBreaks, myCol),
    # parameters for the colour-bar that represents gradient of expression
      heatmap_legend_param = list(
        color_bar = 'continuous',
        legend_direction = 'vertical',
        legend_width = unit(8, 'cm'),
        legend_height = unit(5.0, 'cm'),
        title_position = 'topcenter',
        title_gp=gpar(col = "white",fontsize = 8, fontface = 'bold'),
        labels_gp=gpar(col = "white",fontsize = 8, fontface = 'bold')),
    # row (gene) parameters
      cluster_rows = TRUE,
      show_row_dend = TRUE,
      #row_title = 'Statistically significant genes',
      row_title_side = 'left',
      row_title_gp = gpar(col = "white",fontsize = 8,  fontface = 'bold'),
      row_title_rot = 90,
      show_row_names = FALSE,
      row_names_gp = gpar(col = "white",fontsize = 8, fontface = 'bold'),
      row_names_side = 'right',
      row_dend_width = unit(25,'mm'),
    # column (sample) parameters
      cluster_columns = FALSE, 
      show_column_dend = FALSE,
      column_title = NULL,
      column_title_side = 'bottom',
      column_title_gp = gpar(col = "white",fontsize = 1, fontface = 'bold'),
      column_title_rot = 0,
      show_column_names = TRUE,
      column_names_gp = gpar(col = "white",fontsize = 8, fontface = 'bold'),
      column_names_max_height = unit(8, 'cm'),
      column_dend_height = unit(25,'mm'),
    # cluster methods for rows and columns
      clustering_distance_columns = function(x) as.dist(1 - cor(t(x))),
      clustering_method_columns = 'ward.D2',
      clustering_distance_rows = function(x) as.dist(1 - cor(t(x))),
      clustering_method_rows = 'ward.D2',
    # specify top and bottom annotations
      top_annotation = colAnn)
      #bottom_annotation = boxplotCol) 
  require(cowplot)
  prow <- cowplot::plot_grid(grid.grabExpr(draw(hmap + genelabels,background = "transparent", 
    heatmap_legend_side = 'left',
    annotation_legend_side = 'bottom', #right
    row_sub_title_side = 'left')), labels = c(""), ncol = 1)
  title <- ggdraw() + TITLE
  subtitle <- ggdraw() + draw_label_themeRKwhite(paste("Heatmap of", " [vst-z-score ", length(genes_of_interest)," tatxa/ ",     dim(Output4)[1],"Basemean >", min_count,"]", sep = " "), 
              element = "plot.subtitle",x = 0.05, hjust = 0, vjust = 1)
  A <- plot_grid(title, subtitle, prow, ncol = 1, rel_heights = c(0.04, 0.05, 0.98)) 
  #Safe the plots in a specified folder <- may have to change the width and height
  plot(A)
  ggsave(A, filename = FILENAME, path = pathPlots, device='png', dpi=300, width = 12,
  height = 8)
  hmap <<- hmap #<<- assigns to workspace
} 



BacteriaHeatPlotRK7 <- function (OmicsData = OmicsData, Species = Species, genes_of_interest = genes_of_interest, Samples = Samples, SAMDF = SAMDF,  TITLE = TITLE, filename= FILENAME, OutlineColor= OutlineColor) {
  paste("Code Raphael Koll raphael.koll@uni-hamburg.de code adapted from https://github.com/kevinblighe/E-MTAB-6141")
  require(RColorBrewer)
  require(ComplexHeatmap)
  require(Cairo)
  require(circlize)
  require(digest)
  require(cluster)
  require(ComplexHeatmap)
  require(grid)
  require(DESeq2)
  require(tidyverse)
  require(ggplot2)
  
  #res <- res[res$baseMean >= 10,] #Select Species with Basemean higher 10
  #Output     <- vst[rownames(vst) %in% ress$rowname,]
  #Output2    <- Output[(rowSums(Output > min_count) >= 3),]
  #Output3    <- vst[rownames(vst) %in% rownames(Output2),]
  Output4    <- OmicsData[rownames(OmicsData) %in% genes_of_interest,]

  #z-Score of vst data
  heat       <- t(scale(t(as.matrix(Output4[, Samples]))))
  #sub uncharacterized for shorter names in heatmap
  rownames(heat) <- gsub("uncharacterized ", "",rownames(heat))
  #make and order metadate fitting to matrix
  metadata   <- SAMDF[SAMDF$SampleID %in% colnames(heat),]
  metadata   <- metadata[order(match(metadata$SampleID, colnames(heat))), , drop = FALSE]
  #create top-annotation

  
  annLoc        <- data.frame(Location = metadata$fLoc)#,stringsAsFactors = FALSE)
  annCruise     <- data.frame(Season   = metadata$fCruise)
  anno_df = data.frame(
    Location = annLoc,
    Season = annCruise)
  
  colAnn <-HeatmapAnnotation(
    annotation_name_side = "left",
    df =   anno_df,
    title = NULL,
    which = 'col', # 'col' (samples) or 'row' (gene) annotation?
    na_col = OutlineColor, # default colour for any NA values in the annotation data-frame, 'ann'
    col = list(Location = col.Palette$col.Palette.Locs,
               Season = col.Palette$col.Palette.Cruises), 
    annotation_height = 0.4,
    annotation_width = unit(0.5, 'cm'),
    gap = unit(1, 'mm'),
    annotation_legend_param = list(
      Location = list(
        nrow = 1, # number of rows across which the legend will be arranged
        title = "Location", #
        title_position = 'topcenter',
        legend_direction = 'vertical',
        title_gp = gpar(col = OutlineColor,fontsize = 7, fontface = 'bold'),
        labels_gp = gpar(col = OutlineColor,fontsize = 7, fontface = 'bold')),
      Season = list(
        nrow = 1, # number of rows across which the legend will be arranged
        title = "Season", #
        title_position = 'topcenter',
        legend_direction = 'vertical',
        title_gp = gpar(col = OutlineColor,fontsize = 7, fontface = 'bold'),
        labels_gp = gpar(col = OutlineColor,fontsize = 7, fontface = 'bold'))))
      

  #label every 40th gene
   labelseqs<-if (dim(heat)[1] <= 150) { 
    labelseqs<- 1
    } else if (dim(heat)[1] <= 300) {
    labelseqs<- 3
    } else {
    labelseqs<- 10}
   
  genelabels <- ComplexHeatmap::rowAnnotation(
    Genes = anno_mark(
      at = seq(1, nrow(heat), labelseqs),                         #Adjust the amount of lables
      labels = rownames(heat)[seq(1, nrow(heat), labelseqs)],
      labels_gp = gpar(col = OutlineColor,fontsize = 6, fontface = 'bold'),
      padding = 0.75),
      width = unit(1.0, 'cm') +
      ComplexHeatmap::max_text_width(
        rownames(heat)[seq(1, nrow(heat), 30)],
        gp = gpar(col = OutlineColor,fontsize = 6,  fontface = 'bold')))
  #define clusters, read from unclustered heatmap


  pamClusters <- cluster::pam(heat, k = rowclusternum) # pre-select k = 4 centers
  pamClusters$clustering <- paste0('Cluster ', pamClusters$clustering)
  # fix order of the clusters to have 1 to 4, top to bottom
  # fix order of the clusters to have 1 to 4, top to bottom
  pamClusters$clustering <- factor(pamClusters$clustering,
    levels = c('Cluster 1', 'Cluster 2', 'Cluster 3', 'Cluster 4', 'Cluster 5', 'Cluster 6'))
  myCol <- colorRampPalette(c('blue', 'white', 'red'))(100)
  myBreaks <- seq(-3, 3, length.out = 100)
  #create heatmap

    hmap <- Heatmap(heat, #raster_device ="png",
    # split the genes / rows according to the PAM clusters
      split = pamClusters$clustering,
      column_km = columnclusternum,
      cluster_row_slices = FALSE,
    name = 'Taxa\nZ-\nscore',
    col = colorRamp2(myBreaks, myCol),
    # parameters for the colour-bar that represents gradient of expression
      heatmap_legend_param = list(
        color_bar = 'continuous',
        legend_direction = 'vertical',
        legend_width = unit(8, 'cm'),
        legend_height = unit(5.0, 'cm'),
        title_position = 'topcenter',
        title_gp=gpar(col = OutlineColor,fontsize = 8, fontface = 'bold'),
        labels_gp=gpar(col = OutlineColor,fontsize = 8, fontface = 'bold')),
    # row (gene) parameters
      cluster_rows = TRUE,
      show_row_dend = TRUE,
      #row_title = 'Statistically significant genes',
      row_title_side = 'left',
      row_title_gp = gpar(col = OutlineColor,fontsize = 8,  fontface = 'bold'),
      row_title_rot = 90,
      show_row_names = FALSE,
      row_names_gp = gpar(col = OutlineColor,fontsize = 8, fontface = 'bold'),
      row_names_side = 'right',
      row_dend_width = unit(25,'mm'),
    # column (sample) parameters
      cluster_columns = FALSE, 
      show_column_dend = FALSE,
      column_title = NULL,
      column_title_side = 'bottom',
      column_title_gp = gpar(col = OutlineColor,fontsize = 1, fontface = 'bold'),
      column_title_rot = 0,
      show_column_names = TRUE,
      column_names_gp = gpar(col = OutlineColor,fontsize = 8, fontface = 'bold'),
      column_names_max_height = unit(8, 'cm'),
      column_dend_height = unit(25,'mm'),
    # cluster methods for rows and columns
      clustering_distance_columns = function(x) as.dist(1 - cor(t(x))),
      clustering_method_columns = 'ward.D2',
      clustering_distance_rows = function(x) as.dist(1 - cor(t(x))),
      clustering_method_rows = 'ward.D2',
    # specify top and bottom annotations
      top_annotation = colAnn)
      #bottom_annotation = boxplotCol) 
  require(cowplot)
  HeatPlot_prow <- cowplot::plot_grid(grid.grabExpr(draw(hmap + genelabels,background = "transparent", 
    heatmap_legend_side = 'left',
    annotation_legend_side = 'bottom', #right
    row_sub_title_side = 'left')), labels = c(""), ncol = 1)
  HeatPlot_prow <<- HeatPlot_prow
  title <- ggdraw() + TITLE
  subtitle <- ggdraw() + draw_label_themeRK(paste("Heatmap of", " [clr-z-score ", length(genes_of_interest)," taxa", sep = " "), 
              element = "plot.subtitle",x = 0.05, hjust = 0, vjust = 1)
  A <- plot_grid(title, subtitle, HeatPlot_prow, ncol = 1, rel_heights = c(0.04, 0.05, 0.98)) 
  #Safe the plots in a specified folder <- may have to change the width and height
  plot(A)
  ggsave(A, filename = FILENAME, path = pathPlots, device='png', dpi=300, width = 12,
  height = 8)
  hmap <<- hmap #<<- assigns to workspace
} 

BacteriaHeatPlotRK7_withCore <- function (OmicsData = OmicsData, Species = Species, genes_of_interest = genes_of_interest, Samples = Samples, SAMDF = SAMDF,  TITLE = TITLE, filename= FILENAME, SHOW_ROW_NAMES = SHOW_ROW_NAMES, SHOW_ROW_NAMES_ALL = SHOW_ROW_NAMES_ALL,  ZScore =  ZScore, OutlineColor=OutlineColor) {
  paste("Code Raphael Koll raphael.koll@uni-hamburg.de code adapted from https://github.com/kevinblighe/E-MTAB-6141")
  require(RColorBrewer)
  require(ComplexHeatmap)
  require(Cairo)
  require(circlize)
  require(digest)
  require(cluster)
  require(ComplexHeatmap)
  require(grid)
  require(DESeq2)
  require(tidyverse)
  require(ggplot2)

  OmicsData  <- OmicsData[names(OmicsData) %in% Samples]
  OmicsData    <- OmicsData[rownames(OmicsData) %in% genes_of_interest,]
  
  #z-Score of vst data
  #heat <- Output4 
  if (ZScore == TRUE) {
    print("provide CLR data")
    heat       <- t(scale(t(as.matrix(OmicsData))))
  } else if (ZScore == FALSE) {
    print("provide relative abundance data")
    heat <- as.matrix(OmicsData)
  }
    heat <<- heat
    
  #sub uncharacterized for shorter names in heatmap
  rownames(heat) <- gsub("uncharacterized ", "",rownames(heat))
  #make and order metadate fitting to matrix
  metadata   <- SAMDF[SAMDF$SampleID %in% colnames(heat),]
  
  metadata   <- metadata[order(match(metadata$SampleID, colnames(heat))), , drop = FALSE]
  
  metadata$SampleID <- factor(metadata$SampleID, levels = SSU_Samples[SSU_Samples %in% metadata$SampleID])
  
  metadata <- metadata[order(metadata$SampleID), ]

  heat <- heat[, match(metadata$SampleID, colnames(heat))]
  
  annLOC        <- data.frame(Location = metadata$fLOC)#,stringsAsFactors = FALSE)
  annSeason     <- data.frame(Season   = metadata$fSeason)
  annSpecies     <- data.frame(Species   = metadata$fSpecies)
  anno_df = data.frame(
    Location = annLOC,
    Season = annSeason, 
    Species = annSpecies)
  
  COL.LOC <- col.Palette$col.Palette.LOC[names(col.Palette$col.Palette.LOC) %in% metadata$fLOC]
  COL.Season <- col.Palette$col.Palette.Season[names(col.Palette$col.Palette.Season) %in% metadata$fSeason]
  COL.Species <- col.Palette$col.Palette.Species[names(col.Palette$col.Palette.Species) %in% metadata$Species]
  
  colAnn <-HeatmapAnnotation(
    annotation_name_side = "left",
    df =   anno_df,
    title = NULL,
    which = 'col', # 'col' (samples) or 'row' (gene) annotation?
    na_col = OutlineColor, # default colour for any NA values in the annotation data-frame, 'ann'
    col = list(Location = COL.LOC,
               Season   = COL.Season, 
               Species  = COL.Species), 
    height = unit(2, "cm"),
    #annotation_width = unit(0.5, 'cm'),
    #gap = unit(0.5, 'mm'),
    annotation_legend_param = list(
      Location = list(
        nrow = 1, # number of rows across which the legend will be arranged
        title = "Location", #
        title_position = 'topcenter',
        legend_direction = 'vertical',
        title_gp = gpar(col = OutlineColor,fontsize = 7, fontface = 'bold'),
        labels_gp = gpar(col = OutlineColor,fontsize = 7, fontface = 'bold')),
      Season = list(
        nrow = 1, # number of rows across which the legend will be arranged
        title = "Season", #
        title_position = 'topcenter',
        legend_direction = 'vertical',
        title_gp = gpar(col = OutlineColor,fontsize = 7, fontface = 'bold'),
        labels_gp = gpar(col = OutlineColor,fontsize = 7, fontface = 'bold')), 
      Species = list(
        nrow = 1, # number of rows across which the legend will be arranged
        title = "Species", #
        title_position = 'topcenter',
        legend_direction = 'vertical',
        title_gp = gpar(col = OutlineColor,fontsize = 7, fontface = 'bold'),
        labels_gp = gpar(col = OutlineColor,fontsize = 7, fontface = 'bold'))
      ))
      

   #############################
    #Create Core Taxa Annotation#
    #############################
    CoreTaxa <- list()
    #numeric(length(IndicatorTaxa))
    for (x in 1:dim(heat)[1]) {
      ps_core <- pslist[[names(pslist)[grepl(paste("Core", CoreSet, sep="_"), names(pslist))]]]
      if (rownames(heat)[x] %in% ps_core[c("ASV", "Phylum", "Order")]$ASV) {
      CoreTaxa[[x]] <- 1
      names(CoreTaxa)[[x]] <- rownames(heat)[x]
    } else {
      CoreTaxa[x] <- 0
      names(CoreTaxa)[[x]] <- rownames(heat)[x]
    }}

    Core_Labels <- names(unlist(CoreTaxa))

  #label every 40th gene
  #  labelseqs<-if (dim(heat)[1] <= 150) { 
  #   labelseqs<- 1
  #   } else if (dim(heat)[1] <= 300) {
  #   labelseqs<- 3
  #   } else {
  #   labelseqs<- 10}
  #  
  # genelabels <- ComplexHeatmap::rowAnnotation(
  #   Genes = anno_mark(
  #     at = seq(1, nrow(heat), labelseqs),                         #Adjust the amount of lables
  #     labels = rownames(heat)[seq(1, nrow(heat), labelseqs)],
  #     labels_gp = gpar(col = OutlineColor,fontsize = 6, fontface = 'bold'),
  #     padding = 0.75),
  #     width = unit(1.0, 'cm') +
  #     ComplexHeatmap::max_text_width(
  #       rownames(heat)[seq(1, nrow(heat), 30)],
  #       gp = gpar(col = OutlineColor,fontsize = 6,  fontface = 'bold')))
  #define clusters, read from unclustered heatmap
  
  #Core_Microbiome_Annotation = rowAnnotation(Core = unlist(CoreTaxa))
    Core_Microbiome_Annotation = rowAnnotation(Core = unlist(CoreTaxa),
    col = list(Core = c("1" = "#FF3399", "0" = "white") ))

    if (SHOW_ROW_NAMES_ALL == F) { 
     ps_core <- pslist[[names(pslist)[grepl(paste("Core", CoreSet, sep="_"), names(pslist))]]]
    genelabels <- ComplexHeatmap::rowAnnotation(
      Genes = anno_mark(
      at = which(rownames(heat) %in% ps_core[c("ASV", "Phylum", "Order")]$ASV),
      labels = rownames(heat)[rownames(heat) %in% ps_core[c("ASV", "Phylum", "Order")]$ASV],
      labels_gp = gpar(col = OutlineColor,fontsize = 6, fontface = 'bold'),
      padding = 0.75),
      width = unit(1.0, 'cm') +
      ComplexHeatmap::max_text_width(
        rownames(heat)[seq(1, nrow(heat), 30)],
        gp = gpar(col = OutlineColor,fontsize = 6,  fontface = 'bold')))
    } else if ( SHOW_ROW_NAMES_ALL == T) {
     #label every 40th gene
    labelseqs<-if (dim(heat)[1] <= 150) { 
      labelseqs<- 1
      } else if (dim(heat)[1] <= 1000) {
      labelseqs<- 10
      } else {
      labelseqs<- 100}
    genelabels <- ComplexHeatmap::rowAnnotation(
      Genes = anno_mark(
        at = seq(1, nrow(heat), labelseqs),                         #Adjust the amount of lables
        labels = rownames(heat)[seq(1, nrow(heat), labelseqs)],
        labels_gp = gpar(col = OutlineColor,fontsize = 6, fontface = 'bold'),
        padding = 0.75),
        width = unit(1.0, 'cm') +
        ComplexHeatmap::max_text_width(
        rownames(heat)[seq(1, nrow(heat), 30)],
        gp = gpar(col = OutlineColor,fontsize = 6,  fontface = 'bold')))
    }
    
  pamClusters <- cluster::pam(heat, k = rowclusternum) # pre-select k = 4 centers
  pamClusters$clustering <- paste0('Cluster ', pamClusters$clustering)
  # fix order of the clusters to have 1 to 4, top to bottom
  # fix order of the clusters to have 1 to 4, top to bottom
  pamClusters$clustering <- factor(pamClusters$clustering,
    levels = c('Cluster 1', 'Cluster 2', 'Cluster 3', 'Cluster 4', 'Cluster 5', 'Cluster 6'))
  
   if (ZScore == TRUE) {
      myCol <- colorRampPalette(c('white', 'ivory', 'red'))(100)
      myBreaks <- seq(-3, 3, length.out = 100)
      NAME <- 'Taxa\nZ-\nscore'
    } else if (ZScore == FALSE) {
      myCol <- colorRampPalette(c('white', 'ivory', 'ivory', 'red'))(100)
      myBreaks <- seq(0, 0.5, length.out = 100)
      NAME <- 'Taxa\nRel\nAbund'
    }
  
   hmap <- Heatmap(heat, #raster_device ="png",
    # split the genes / rows according to the PAM clusters
      right_annotation = Core_Microbiome_Annotation, #Inc
      split = pamClusters$clustering,
      column_km = columnclusternum,
      cluster_row_slices = FALSE,
    name = NAME,
    col = colorRamp2(myBreaks, myCol),
    # parameters for the colour-bar that represents gradient of expression
      heatmap_legend_param = list(
        color_bar = 'continuous',
        legend_direction = 'vertical',
        legend_width = unit(8, 'cm'),
        legend_height = unit(5.0, 'cm'),
        title_position = 'topcenter',
        title_gp=gpar(col = OutlineColor,fontsize = 8, fontface = 'bold'),
        labels_gp=gpar(col = OutlineColor,fontsize = 8, fontface = 'bold')),
    # row (gene) parameters
      cluster_rows = TRUE,
      show_row_dend = TRUE,
      #row_title = 'Statistically significant genes',
      row_title_side = 'left',
      row_title_gp = gpar(col = OutlineColor,fontsize = 8,  fontface = 'bold'),
      row_title_rot = 90,
      show_row_names = TRUE,
      row_names_gp = gpar(col = OutlineColor,fontsize = 8, fontface = 'bold'),
      row_names_side = 'right',
      row_dend_width = unit(25,'mm'),
    # column (sample) parameters
      cluster_columns = FALSE, 
      show_column_dend = FALSE,
      column_title = NULL,
      column_title_side = 'bottom',
      column_title_gp = gpar(col = OutlineColor,fontsize = 1, fontface = 'bold'),
      column_title_rot = 0,
      show_column_names = FALSE,
      column_names_gp = gpar(col = OutlineColor,fontsize = 8, fontface = 'bold'),
      column_names_max_height = unit(8, 'cm'),
      column_dend_height = unit(25,'mm'),
    # cluster methods for rows and columns
      clustering_distance_columns = function(x) as.dist(1 - cor(t(x))),
      clustering_method_columns = 'ward.D2',
      clustering_distance_rows = function(x) as.dist(1 - cor(t(x))),
      clustering_method_rows = 'ward.D2',
    # specify top and bottom annotations
      top_annotation = colAnn)
      #bottom_annotation = boxplotCol) 
   
    require(cowplot)
    if ( SHOW_ROW_NAMES_ALL == F) {
    HeatPlot_prow <- cowplot::plot_grid(grid.grabExpr(ComplexHeatmap::draw(hmap + genelabels, 
        background = "transparent", 
        heatmap_legend_side = 'left',
        annotation_legend_side = 'bottom', #right
        row_sub_title_side = 'left')), labels = c(""), ncol = 1)
    } else if ( SHOW_ROW_NAMES_ALL == T) {
    HeatPlot_prow <- cowplot::plot_grid(grid.grabExpr(ComplexHeatmap::draw(hmap, 
      background = "transparent", 
      heatmap_legend_side = 'left',
      annotation_legend_side = 'bottom', #right
      row_sub_title_side = 'left')), labels = c(""), ncol = 1)
      }
  HeatPlot_prow <<- HeatPlot_prow
  title <- ggdraw() + TITLE
  subtitle <- ggdraw() + draw_label_themeRK(paste("Heatmap of", " [clr-z-score ", length(genes_of_interest)," taxa ]", sep = " "),  #draw_label_themeRKwhite
              element = "plot.subtitle",x = 0.05, hjust = 0, vjust = 1)
  A <- plot_grid(title, subtitle, HeatPlot_prow, ncol = 1, rel_heights = c(0.04, 0.05, 0.98)) 
  #Safe the plots in a specified folder <- may have to change the width and height
  plot(A)
  ggsave(A, filename = FILENAME, path = pathPlots, device='png', dpi=300, width = WIDTH,
  height = HEIGHT)
  hmap <<- hmap #<<- assigns to workspace
} 












BacteriaHeatPlotRK7_withCore_pure <- function (OmicsData = OmicsData, Species = Species, genes_of_interest = genes_of_interest, Samples = Samples, SAMDF = SAMDF,  TITLE = TITLE, filename= FILENAME, OutlineColor=OutlineColor) {
  paste("Code Raphael Koll raphael.koll@uni-hamburg.de code adapted from https://github.com/kevinblighe/E-MTAB-6141")
  require(RColorBrewer)
  require(ComplexHeatmap)
  require(Cairo)
  require(circlize)
  require(digest)
  require(cluster)
  require(ComplexHeatmap)
  require(grid)
  require(DESeq2)
  require(tidyverse)
  require(ggplot2)
  
  #res <- res[res$baseMean >= 10,] #Select Species with Basemean higher 10
  #Output     <- vst[rownames(vst) %in% ress$rowname,]
  #Output2    <- Output[(rowSums(Output > min_count) >= 3),]
  #Output3    <- vst[rownames(vst) %in% rownames(Output2),]
  OmicsData <- OmicsData[names(OmicsData) %in% Samples]
  Output4    <- OmicsData[rownames(OmicsData) %in% genes_of_interest,]
  

  #z-Score of vst data
  #heat <- Output4 
  heat       <- t(scale(t(as.matrix(Output4))))
  heat <<- heat
  #sub uncharacterized for shorter names in heatmap
  rownames(heat) <- gsub("uncharacterized ", "",rownames(heat))
  #make and order metadate fitting to matrix
  metadata   <- SAMDF[SAMDF$SampleID %in% colnames(heat),]
  
  metadata   <- metadata[order(match(metadata$SampleID, colnames(heat))), , drop = FALSE]
  
  metadata$SampleID <- factor(metadata$SampleID, levels = SSU_Samples[SSU_Samples %in% metadata$SampleID])
  
  metadata <- metadata[order(metadata$SampleID), ]

  heat <- heat[, match(metadata$SampleID, colnames(heat))]
  
  annLOC        <- data.frame(Location = metadata$fLOC)#,stringsAsFactors = FALSE)
  annSeason     <- data.frame(Season   = metadata$fSeason)
  annSpecies     <- data.frame(Species   = metadata$fSpecies)
  anno_df = data.frame(
    Location = annLOC,
    Season = annSeason, 
    Species = annSpecies)
  
  COL.LOC <- col.Palette$col.Palette.LOC[names(col.Palette$col.Palette.LOC) %in% metadata$fLOC]
  COL.Season <- col.Palette$col.Palette.Season[names(col.Palette$col.Palette.Season) %in% metadata$fSeason]
  COL.Species <- col.Palette$col.Palette.Species[names(col.Palette$col.Palette.Species) %in% metadata$Species]
  
  colAnn <-HeatmapAnnotation(
    annotation_name_side = "left",
    df =   anno_df,
    title = NULL,
    which = 'col', # 'col' (samples) or 'row' (gene) annotation?
    na_col = OutlineColor, # default colour for any NA values in the annotation data-frame, 'ann'
    col = list(Location = COL.LOC,
               Season   = COL.Season, 
               Species  = COL.Species), 
    height = unit(2, "cm"),
    #annotation_width = unit(0.5, 'cm'),
    #gap = unit(0.5, 'mm'),
    annotation_legend_param = list(
      Location = list(
        nrow = 1, # number of rows across which the legend will be arranged
        title = "Location", #
        title_position = 'topcenter',
        legend_direction = 'vertical',
        title_gp = gpar(col = OutlineColor,fontsize = 7, fontface = 'bold'),
        labels_gp = gpar(col = OutlineColor,fontsize = 7, fontface = 'bold')),
      Season = list(
        nrow = 1, # number of rows across which the legend will be arranged
        title = "Season", #
        title_position = 'topcenter',
        legend_direction = 'vertical',
        title_gp = gpar(col = OutlineColor,fontsize = 7, fontface = 'bold'),
        labels_gp = gpar(col = OutlineColor,fontsize = 7, fontface = 'bold')), 
      Species = list(
        nrow = 1, # number of rows across which the legend will be arranged
        title = "Species", #
        title_position = 'topcenter',
        legend_direction = 'vertical',
        title_gp = gpar(col = OutlineColor,fontsize = 7, fontface = 'bold'),
        labels_gp = gpar(col = OutlineColor,fontsize = 7, fontface = 'bold'))
      ))
      

   #############################
    #Create Core Taxa Annotation#
    #############################
    CoreTaxa <- list()
    #numeric(length(IndicatorTaxa))
    for (x in 1:dim(heat)[1]) {
      ps_core <- pslist[[names(pslist)[grepl(paste("Core", CoreSet, sep="_"), names(pslist))]]]
      if (rownames(heat)[x] %in% ps_core[c("ASV", "Phylum", "Order")]$ASV) {
      CoreTaxa[[x]] <- 1
      names(CoreTaxa)[[x]] <- rownames(heat)[x]
    } else {
      CoreTaxa[x] <- 0
      names(CoreTaxa)[[x]] <- rownames(heat)[x]
    }}

    Core_Labels <- names(unlist(CoreTaxa))

  #label every 40th gene
  #  labelseqs<-if (dim(heat)[1] <= 150) { 
  #   labelseqs<- 1
  #   } else if (dim(heat)[1] <= 300) {
  #   labelseqs<- 3
  #   } else {
  #   labelseqs<- 10}
  #  
  # genelabels <- ComplexHeatmap::rowAnnotation(
  #   Genes = anno_mark(
  #     at = seq(1, nrow(heat), labelseqs),                         #Adjust the amount of lables
  #     labels = rownames(heat)[seq(1, nrow(heat), labelseqs)],
  #     labels_gp = gpar(col = OutlineColor,fontsize = 6, fontface = 'bold'),
  #     padding = 0.75),
  #     width = unit(1.0, 'cm') +
  #     ComplexHeatmap::max_text_width(
  #       rownames(heat)[seq(1, nrow(heat), 30)],
  #       gp = gpar(col = OutlineColor,fontsize = 6,  fontface = 'bold')))
  #define clusters, read from unclustered heatmap
  
  #Core_Microbiome_Annotation = rowAnnotation(Core = unlist(CoreTaxa))
    Core_Microbiome_Annotation = rowAnnotation(Core = unlist(CoreTaxa),
    col = list(Core = c("1" = "#FF3399", "0" = "white") ))

    genelabels <- ComplexHeatmap::rowAnnotation(
      Genes = anno_mark(
      at = which(rownames(heat) %in% pslist$Core[c("ASV", "Phylum", "Order")]$ASV),
      labels = rownames(heat)[rownames(heat) %in% pslist$Core[c("ASV", "Phylum", "Order")]$ASV],
      labels_gp = gpar(col = OutlineColor,fontsize = 6, fontface = 'bold'),
      padding = 0.75),
      width = unit(1.0, 'cm') +
      ComplexHeatmap::max_text_width(
        rownames(heat)[seq(1, nrow(heat), 30)],
        gp = gpar(col = OutlineColor,fontsize = 6,  fontface = 'bold')))


  pamClusters <- cluster::pam(heat, k = rowclusternum) # pre-select k = 4 centers
  pamClusters$clustering <- paste0('Cluster ', pamClusters$clustering)
  # fix order of the clusters to have 1 to 4, top to bottom
  # fix order of the clusters to have 1 to 4, top to bottom
  pamClusters$clustering <- factor(pamClusters$clustering,
    levels = c('Cluster 1', 'Cluster 2', 'Cluster 3', 'Cluster 4', 'Cluster 5', 'Cluster 6'))
  myCol <- colorRampPalette(c('white', 'ivory', 'red'))(100)
  myBreaks <- seq(-3, 3, length.out = 100)
  #create heatmap

   hmap <- Heatmap(heat, #raster_device ="png",
    # split the genes / rows according to the PAM clusters
      right_annotation = Core_Microbiome_Annotation, #Inc
      split = pamClusters$clustering,
      column_km = columnclusternum,
      cluster_row_slices = FALSE,
      heatmap_height = unit(0.01, "cm")*nrow(heat), 
    name = 'Taxa\nZ-\nscore',
    col = colorRamp2(myBreaks, myCol),
    # parameters for the colour-bar that represents gradient of expression
      heatmap_legend_param = list(
        color_bar = 'continuous',
        legend_direction = 'vertical',
        legend_width = unit(8, 'cm'),
        legend_height = unit(5.0, 'cm'),
        title_position = 'topcenter',
        title_gp=gpar(col = OutlineColor,fontsize = 8, fontface = 'bold'),
        labels_gp=gpar(col = OutlineColor,fontsize = 8, fontface = 'bold')),
    # row (gene) parameters
      cluster_rows = TRUE,
      show_row_dend = TRUE,
      #row_title = 'Statistically significant genes',
      row_title_side = 'left',
      row_title_gp = gpar(col = OutlineColor,fontsize = 8,  fontface = 'bold'),
      row_title_rot = 90,
      show_row_names = FALSE,
      row_names_gp = gpar(col = OutlineColor,fontsize = 8, fontface = 'bold'),
      row_names_side = 'right',
      row_dend_width = unit(25,'mm'),
    # column (sample) parameters
      cluster_columns = FALSE, 
      show_column_dend = FALSE,
      column_title = NULL,
      column_title_side = 'bottom',
      column_title_gp = gpar(col = OutlineColor,fontsize = 1, fontface = 'bold'),
      column_title_rot = 0,
      show_column_names = FALSE,
      column_names_gp = gpar(col = OutlineColor,fontsize = 8, fontface = 'bold'),
      column_names_max_height = unit(8, 'cm'),
      column_dend_height = unit(25,'mm'),
    # cluster methods for rows and columns
      clustering_distance_columns = function(x) as.dist(1 - cor(t(x))),
      clustering_method_columns = 'ward.D2',
      clustering_distance_rows = function(x) as.dist(1 - cor(t(x))),
      clustering_method_rows = 'ward.D2')
    # specify top and bottom annotations
      #top_annotation = colAnn)
      #bottom_annotation = boxplotCol) 
   
  require(cowplot)
  HeatPlot_prow <- cowplot::plot_grid(grid.grabExpr(ComplexHeatmap::draw(hmap + genelabels,background = "transparent", 
    heatmap_legend_side = 'left',
    annotation_legend_side = 'bottom', #right
    row_sub_title_side = 'left')), labels = c(""), ncol = 1)
  HeatPlot_prow <<- HeatPlot_prow
  title <- ggdraw() + TITLE
  subtitle <- ggdraw() + draw_label_themeRK(paste("Heatmap of", " [clr-z-score ", length(genes_of_interest)," taxa ]", sep = " "),  #draw_label_themeRKwhite
              element = "plot.subtitle",x = 0.05, hjust = 0, vjust = 1)
  A <- plot_grid(title, subtitle, HeatPlot_prow, ncol = 1, rel_heights = c(0.04, 0.05, 0.98)) 
  #Safe the plots in a specified folder <- may have to change the width and height
  plot(A)
  ggsave(A, filename = FILENAME, path = pathPlots, device='png', dpi=300, width = WIDTH,
  height = 8)
  hmap <<- hmap #<<- assigns to workspace
} 



BacteriaHeatPlotRK7_withCore_RelAbund <- function (OmicsData = OmicsData, Species = Species, genes_of_interest = genes_of_interest, Samples = Samples, SAMDF = SAMDF,  TITLE = TITLE, filename= FILENAME, OutlineColor=OutlineColor) {
  paste("Code Raphael Koll raphael.koll@uni-hamburg.de code adapted from https://github.com/kevinblighe/E-MTAB-6141")
  require(RColorBrewer)
  require(ComplexHeatmap)
  require(Cairo)
  require(circlize)
  require(digest)
  require(cluster)
  require(ComplexHeatmap)
  require(grid)
  require(DESeq2)
  require(tidyverse)
  require(ggplot2)
  
  #res <- res[res$baseMean >= 10,] #Select Species with Basemean higher 10
  #Output     <- vst[rownames(vst) %in% ress$rowname,]
  #Output2    <- Output[(rowSums(Output > min_count) >= 3),]
  #Output3    <- vst[rownames(vst) %in% rownames(Output2),]
  OmicsData <- OmicsData[names(OmicsData) %in% Samples]
  Output4    <- OmicsData[rownames(OmicsData) %in% genes_of_interest,]
  

  #z-Score of vst data
  heat <- Output4 
  #heat       <- t(scale(t(as.matrix(Output4))))
  heat <<- heat
  #sub uncharacterized for shorter names in heatmap
  rownames(heat) <- gsub("uncharacterized ", "",rownames(heat))
  #make and order metadate fitting to matrix
  metadata   <- SAMDF[SAMDF$SampleID %in% colnames(heat),]
  
  metadata   <- metadata[order(match(metadata$SampleID, colnames(heat))), , drop = FALSE]
  
  metadata$SampleID <- factor(metadata$SampleID, levels = SSU_Samples[SSU_Samples %in% metadata$SampleID])
  
  metadata <- metadata[order(metadata$SampleID), ]

  heat <- heat[, match(metadata$SampleID, colnames(heat))]
  
  annLOC        <- data.frame(Location = metadata$fLOC)#,stringsAsFactors = FALSE)
  annSeason     <- data.frame(Season   = metadata$fSeason)
  annSpecies     <- data.frame(Species   = metadata$fSpecies)
  anno_df = data.frame(
    Location = annLOC,
    Season = annSeason, 
    Species = annSpecies)
  
  COL.LOC <- col.Palette$col.Palette.LOC[names(col.Palette$col.Palette.LOC) %in% metadata$fLOC]
  COL.Season <- col.Palette$col.Palette.Season[names(col.Palette$col.Palette.Season) %in% metadata$fSeason]
  COL.Species <- col.Palette$col.Palette.Species[names(col.Palette$col.Palette.Species) %in% metadata$Species]
  
  colAnn <-HeatmapAnnotation(
    annotation_name_side = "left",
    df =   anno_df,
    title = NULL,
    which = 'col', # 'col' (samples) or 'row' (gene) annotation?
    na_col = OutlineColor, # default colour for any NA values in the annotation data-frame, 'ann'
    col = list(Location = COL.LOC,
               Season   = COL.Season, 
               Species  = COL.Species), 
    height = unit(2, "cm"),
    #annotation_width = unit(0.5, 'cm'),
    #gap = unit(0.5, 'mm'),
    annotation_legend_param = list(
      Location = list(
        nrow = 1, # number of rows across which the legend will be arranged
        title = "Location", #
        title_position = 'topcenter',
        legend_direction = 'vertical',
        title_gp = gpar(col = OutlineColor,fontsize = 7, fontface = 'bold'),
        labels_gp = gpar(col = OutlineColor,fontsize = 7, fontface = 'bold')),
      Season = list(
        nrow = 1, # number of rows across which the legend will be arranged
        title = "Season", #
        title_position = 'topcenter',
        legend_direction = 'vertical',
        title_gp = gpar(col = OutlineColor,fontsize = 7, fontface = 'bold'),
        labels_gp = gpar(col = OutlineColor,fontsize = 7, fontface = 'bold')), 
      Species = list(
        nrow = 1, # number of rows across which the legend will be arranged
        title = "Species", #
        title_position = 'topcenter',
        legend_direction = 'vertical',
        title_gp = gpar(col = OutlineColor,fontsize = 7, fontface = 'bold'),
        labels_gp = gpar(col = OutlineColor,fontsize = 7, fontface = 'bold'))
      ))
      

   #############################
    #Create Core Taxa Annotation#
    #############################
    CoreTaxa <- list()
    #numeric(length(IndicatorTaxa))
    for (x in 1:dim(heat)[1]) {
      ps_core <- pslist[[names(pslist)[grepl(paste("Core", CoreSet, sep="_"), names(pslist))]]]
      if (rownames(heat)[x] %in% ps_core[c("ASV", "Phylum", "Order")]$ASV) {
      CoreTaxa[[x]] <- 1
      names(CoreTaxa)[[x]] <- rownames(heat)[x]
    } else {
      CoreTaxa[x] <- 0
      names(CoreTaxa)[[x]] <- rownames(heat)[x]
    }}

    Core_Labels <- names(unlist(CoreTaxa))

  #label every 40th gene
  #  labelseqs<-if (dim(heat)[1] <= 150) { 
  #   labelseqs<- 1
  #   } else if (dim(heat)[1] <= 300) {
  #   labelseqs<- 3
  #   } else {
  #   labelseqs<- 10}
  #  
  # genelabels <- ComplexHeatmap::rowAnnotation(
  #   Genes = anno_mark(
  #     at = seq(1, nrow(heat), labelseqs),                         #Adjust the amount of lables
  #     labels = rownames(heat)[seq(1, nrow(heat), labelseqs)],
  #     labels_gp = gpar(col = OutlineColor,fontsize = 6, fontface = 'bold'),
  #     padding = 0.75),
  #     width = unit(1.0, 'cm') +
  #     ComplexHeatmap::max_text_width(
  #       rownames(heat)[seq(1, nrow(heat), 30)],
  #       gp = gpar(col = OutlineColor,fontsize = 6,  fontface = 'bold')))
  #define clusters, read from unclustered heatmap
  
  #Core_Microbiome_Annotation = rowAnnotation(Core = unlist(CoreTaxa))
    Core_Microbiome_Annotation = rowAnnotation(Core = unlist(CoreTaxa),
    col = list(Core = c("1" = "#FF3399", "0" = "white") ))

    genelabels <- ComplexHeatmap::rowAnnotation(
      Genes = anno_mark(
      at = which(rownames(heat) %in% pslist$Core[c("ASV", "Phylum", "Order")]$ASV),
      labels = rownames(heat)[rownames(heat) %in% pslist$Core[c("ASV", "Phylum", "Order")]$ASV],
      labels_gp = gpar(col = OutlineColor,fontsize = 6, fontface = 'bold'),
      padding = 0.75),
      width = unit(1.0, 'cm') +
      ComplexHeatmap::max_text_width(
        rownames(heat)[seq(1, nrow(heat), 30)],
        gp = gpar(col = OutlineColor,fontsize = 6,  fontface = 'bold')))


  pamClusters <- cluster::pam(heat, k = rowclusternum) # pre-select k = 4 centers
  pamClusters$clustering <- paste0('Cluster ', pamClusters$clustering)
  # fix order of the clusters to have 1 to 4, top to bottom
  # fix order of the clusters to have 1 to 4, top to bottom
  pamClusters$clustering <- factor(pamClusters$clustering,
    levels = c('Cluster 1', 'Cluster 2', 'Cluster 3', 'Cluster 4', 'Cluster 5', 'Cluster 6'))
  myCol <- colorRampPalette(c('ivory', 'red', 'red'))(100)
  myBreaks <- seq(0, 3, length.out = 100)
  #create heatmap

  
   hmap <- Heatmap(heat, #raster_device ="png",
    # split the genes / rows according to the PAM clusters
      right_annotation = Core_Microbiome_Annotation, #Inc
      split = pamClusters$clustering,
      column_km = columnclusternum,
      cluster_row_slices = FALSE,
    name = 'Taxa\nZ-\nscore',
    col = colorRamp2(myBreaks, myCol),
    # parameters for the colour-bar that represents gradient of expression
      heatmap_legend_param = list(
        color_bar = 'continuous',
        legend_direction = 'vertical',
        legend_width = unit(8, 'cm'),
        legend_height = unit(5.0, 'cm'),
        title_position = 'topcenter',
        title_gp=gpar(col = OutlineColor,fontsize = 8, fontface = 'bold'),
        labels_gp=gpar(col = OutlineColor,fontsize = 8, fontface = 'bold')),
    # row (gene) parameters
      cluster_rows = TRUE,
      show_row_dend = TRUE,
      #row_title = 'Statistically significant genes',
      row_title_side = 'left',
      row_title_gp = gpar(col = OutlineColor,fontsize = 8,  fontface = 'bold'),
      row_title_rot = 90,
      show_row_names = FALSE,
      row_names_gp = gpar(col = OutlineColor,fontsize = 8, fontface = 'bold'),
      row_names_side = 'right',
      row_dend_width = unit(25,'mm'),
    # column (sample) parameters
      cluster_columns = FALSE, 
      show_column_dend = FALSE,
      column_title = NULL,
      column_title_side = 'bottom',
      column_title_gp = gpar(col = OutlineColor,fontsize = 1, fontface = 'bold'),
      column_title_rot = 0,
      show_column_names = FALSE,
      column_names_gp = gpar(col = OutlineColor,fontsize = 8, fontface = 'bold'),
      column_names_max_height = unit(8, 'cm'),
      column_dend_height = unit(25,'mm'),
    # cluster methods for rows and columns
      clustering_distance_columns = function(x) as.dist(1 - cor(t(x))),
      clustering_method_columns = 'ward.D2',
      clustering_distance_rows = function(x) as.dist(1 - cor(t(x))),
      clustering_method_rows = 'ward.D2',
    # specify top and bottom annotations
      top_annotation = colAnn)
      #bottom_annotation = boxplotCol) 
   
  require(cowplot)
  HeatPlot_prow <- cowplot::plot_grid(grid.grabExpr(ComplexHeatmap::draw(hmap + genelabels,background = "transparent", 
    heatmap_legend_side = 'left',
    annotation_legend_side = 'bottom', #right
    row_sub_title_side = 'left')), labels = c(""), ncol = 1)
  HeatPlot_prow <<- HeatPlot_prow
  title <- ggdraw() + TITLE
  subtitle <- ggdraw() + draw_label_themeRK(paste("Heatmap of", " [clr-z-score ", length(genes_of_interest)," taxa ]", sep = " "),  #draw_label_themeRKwhite
              element = "plot.subtitle",x = 0.05, hjust = 0, vjust = 1)
  A <- plot_grid(title, subtitle, HeatPlot_prow, ncol = 1, rel_heights = c(0.04, 0.05, 0.98)) 
  #Safe the plots in a specified folder <- may have to change the width and height
  plot(A)
  ggsave(A, filename = FILENAME, path = pathPlots, device='png', dpi=300, width = WIDTH,
  height = 8)
  hmap <<- hmap #<<- assigns to workspace
} 

```


```{r}
print("modified rcorr.adjust from Compute Pearson or Spearman Correlations with p-Values to return numeric correction instead of characters https://rdrr.io/cran/RcmdrMisc/man/rcorr.adjust.html from 
John Fox [aut, cre], Manuel Marquez [aut], Robert Muenchen [ctb], Dan Putler [ctb]"
)

rcorr.adjust_RK <- 
function (x, type = c("pearson", "spearman"), use = c("complete.obs", 
    "pairwise.complete.obs")) 
{
    opt <- options(scipen = 5)
    on.exit(options(opt))
    type <- match.arg(type)
    use <- match.arg(use)
    x <- if (use == "complete.obs") 
        as.matrix(na.omit(x))
    else as.matrix(x)
    R <- rcorr(x, type = type)
    P <- P.unadj <- R$P
    p <- P[lower.tri(P)]
    adj.p <- p.adjust(p, method = "holm")
    P[lower.tri(P)] <- adj.p
    P[upper.tri(P)] <- 0
    P <- P + t(P)
    result <- list(R = R, P = P, P.unadj = P.unadj, type = type)
    class(result) <- "rcorr.adjust"
    result
}
```

#-

# 4 RNA


## 4.1 TMP

```{r}
rpkm <- function(counts, lengths) {
  rate <- counts / lengths
  rate / sum(counts) * 1e9}

tpm <- function(counts, lengths) {
  rate <- counts / lengths
  rate / sum(rate) * 1e6}

library(dplyr)
library(tidyr)
```


## 4.2 GSEA

```{r include = FALSE}
#https://advaitabio.com/ipathwayguide/pathway-analysis-vs-gene-set-analysis/
#To some, pathway analysis and gene set analysis are synonyms. However, there are important distinctions between these two groups of methods, and they provide different results. This is part of a series of articles on pathway analysis methods.

#Pathway analysis provides superior results to gene set analysis for many purposes. Of the gene set analysis methods, gene set enrichment analysis (GSEA) is the most unbiased.

GeneGSEAPlotKEGGandWikiRK_Kegg_Online <- function (tpm = tpm, vst = vst, Species = Species, tpm_value = 1, Samples = Samples, SAMDF = SAMDF,  TITLE = TITLE, filename= FILENAME, Tissue = Tissue, Comparisons = Comparisons) {
  
  tryCatch({
  #https://github.com/kevinblighe/E-MTAB-6141
  require(grid)
  require(DESeq2)
  require(tidyverse)
  #######################################
  #GSE Analysis for Pairwise Comparisons#
  #######################################
    
  #############TPM Filter#############
  keep <- rowSums(tpm > tpm_value) >= 3
  tpmFilter <- tpm[keep,]
  sigFilter    <- lapply(Comparisons, function(x) {x<-x[x$Geneid %in% rownames(tpmFilter),];return(x)}) 
  
  ####################################
  print(paste("genes input", sep =""))
  print(sapply(Comparisons,dim)[1,])
  print(paste("genes lost by TPM Filter", sep =""))
  print((sapply(sigFilter,dim)[1,]-sapply(Comparisons,dim)[1,]))

  #sig    <- lapply(sigFilter, function(x) {x$GeneSymbols <- x$rowname;return(x)}) 
  
  sig_GO <- lapply(sigFilter, function(x) {x[!duplicated(x$GeneSymbols),] }) #Remove duplicated
  sig_GO <- lapply(sig_GO, function(x){
      x$GeneSymbols <- gsub("TRINITY.*", NA, x$GeneSymbols)
      return(x)})
  sig_GO <- lapply(sig_GO, function(x) {x[!is.na(x$GeneSymbols),] }) 

  #print(paste("genes left removing Human duplicates", sep =""))
  #print(sapply(sig_GO,dim)[1,])
  
  #################
  #KEGG Annotation#
  #################
  
  lapply(sig_GO, function(x) head(x,2))
  lapply(sig_GO, function(x) dim(x))
  
  require(org.Hs.eg.db)
  
  tryCatch({
  HS <- lapply(sig_GO, function(x) {AnnotationDbi::select(org.Hs.eg.db, x$GeneSymbols, "ENTREZID","SYMBOL")})
  }, error=function(e){cat("ERROR :",conditionMessage(e), "\n")})
  
  #CHECK!#
  #print(sapply(HS ,dim))
  sig_KEGG <- list()
  for (x in 1:length(sig_GO)){
    Output<- dplyr::left_join(sig_GO[[x]], HS[[x]], by=c("GeneSymbols" = "SYMBOL"))
    sig_KEGG[[x]] <- Output  
    names(sig_KEGG)[[x]] <- names(sig_GO)[[x]]}
    # remove duplicate IDS (here we use "SYMBOL", but it should be whatever was selected as keyType)
  dedup_ids<- lapply(sig_KEGG, function(x) {x[!duplicated(sig_KEGG[c("ENTREZID.y")]),] }) 
  dedup_ids<- lapply(dedup_ids, function(x) {x[!is.na(x$ENTREZID.y),] }) 
  #Differences show genes that cannot be mapped to NCBI
  #print(paste("genes lost in conversion", sep =""))
  #print(sapply(dedup_ids,dim)[1,])
  
  #kegg_gene_list <- lapply(dedup_ids, "[", , "log2FoldChange")
  kegg_gene_list <- lapply(dedup_ids, function(x) x$log2FoldChange)

  
  for(i in 1:length(kegg_gene_list)) {
  kegg_gene_list[[i]] <- setNames(kegg_gene_list[[i]], dedup_ids[[i]]$ENTREZID.y)}
  kegg_gene_list <- lapply(kegg_gene_list, function(x) {sort(x, decreasing = TRUE)}) 
  #print(paste("genes left", sep =""))
  #print(lengths(kegg_gene_list))
  
  # for(i in names(kegg_gene_list)) {
  #   write.csv2(kegg_gene_list[[i]], file.path(path_SL, paste(i, "human.csv", sep="_")))
  # }
  
  ##########################
  #Enrichment analysis GSEA#
  ##########################
    # Gene set enrichment analysis (GSEA) (also called functional enrichment analysis or pathway enrichment analysis) is a method to           identify classes of genes or proteins that are over-represented in a large set of genes or proteins, and may have an association with     disease phenotypes. The method uses statistical approaches to identify significantly enriched or depleted groups of genes.         
   #Transcriptomics technologies and proteomics results often identify thousands of genes which are used for the analysis.[1]  
    # BONUS: What we just did is also refered to as Over-representation Analysis (ORA). Another approach is Gene Set Enrichment Analysis       (GSEA). One advantage of GSEA is that you don’t have to pick an arbitrary log2FC cutoff to define gene sets. Instead you provide a        named list of ranked values (e.g., -log10(pvalue)*sign(FC)) and then let the GSEA do the work. Here are the steps, see if you can follow     along:
  tryCatch({
        library(clusterProfiler)
        packageVersion("clusterProfiler")
        packageVersion("DOSE")
        #remove.packages("clusterProfiler")
        #install.packages("remotes")
        #remotes::install_github("GuangchuangYu/clusterProfiler")
        #######################    
        #KEGG Pathway Analysis#
        #######################
        #https://github.com/YuLab-SMU/clusterProfiler/issues/561
        #print("KEGG Pathway Analysis")
        tryCatch({
        #Gene Ratio -> (count of core enrichment genes) / (count of pathway genes) 
          gseKEGGres <- list()
           for (x in names(kegg_gene_list)){ 
             a <- length(gseKEGGres)
             print(x)
             gseKEGGres[[x]] <- gseKEGG(geneList= kegg_gene_list[[x]],
               organism     = "hsa",
               minGSSize    = 3,
               maxGSSize    = 800,
               pvalueCutoff = 0.05,
               pAdjustMethod = "BH",
               keyType       = "ncbi-geneid" # use_internal_data=TRUE
              )
             names(gseKEGGres)[[a+1]] <- x
           }
  
          gseKEGGresReadable<- lapply(gseKEGGres, function(x) {setReadable(x, OrgDb = org.Hs.eg.db, keyType="ENTREZID")}) 
          

        for (x in 1:length(gseKEGGres)){ 
          gseKEGGres[[x]] <- as.data.frame(gseKEGGres[[x]])}
        
        library(stringr)
        gseKEGGres<- Filter(function(x) nrow(x) > 0, gseKEGGres)

        resProcessRK <- function(dat){
              require(stringr)
              require(sjmisc)
              #dat <- lapply(dat, function(x) {as.data.frame(x);return(x)}) 
                  for (x in 1:length(dat)){dat[[x]] <- as.data.frame(dat[[x]])}
              dat2 <- list() 
              for (x in 1:length(dat)){ 
              tryCatch({
              GeneRatio <- as.numeric((as.data.frame(lengths(str_split(dat[[x]]$core_enrichment, "/"))) / 
                                         as.data.frame(dat[[x]]$setSize))[,1])
              Output<-cbind(dat[[x]], as.data.frame(GeneRatio))
              dat2[[x]] <- Output  
              names(dat2)[[x]] <- names(dat)[[x]]
              }, error=function(e){cat("ERROR :",conditionMessage(e), "\n")})}
              dat2<-dat2[lapply(dat2,length)>0]
              dat2<- lapply(dat2, function(x) {x$DescriptionWrap <-word_wrap(x$Description, 40);return(x)})
              dat2<- lapply(dat2, function(x) {x$sign <-ifelse(sign(x$NES) > 0, "activated", "suppressed");return(x)})
              dat2}
        
        gseKEGGres2 <- resProcessRK(gseKEGGres)
        print(paste("Comparisons with significant gene set enrichment", sep =""))
        print(names(gseKEGGres2))

         gseKEGGres2 ->> gseKEGGres2

        }, error=function(e){cat("ERROR :",conditionMessage(e), "\n")})
       
  
    
        Order <- c("activated", "suppressed")
    for (x in 1:length(gseKEGGres2)){ 
        tryCatch({
        
        p <- ggplot(gseKEGGres2[[x]], aes(NES, fct_reorder(DescriptionWrap, NES))) + 
        geom_point(aes(size = GeneRatio, color = p.adjust)) + 
        scale_colour_gradient(limits=c(0, 0.06), low="red") + 
        facet_wrap(~factor(sign, levels=Order), scales = "free", nrow = 1) + atheme + 
        theme(axis.text.y = element_text(size = 10), strip.text.x = element_text(size = 10),
          legend.title =   element_text( size=10), legend.text=element_text(size=10), 
          axis.title = element_text(size = 10), 
          panel.background = element_rect(fill='transparent'),
          plot.background = element_rect(fill='transparent', color=NA), 
          legend.background = element_rect(fill='transparent'), #transparent legend bg
    legend.box.background = element_rect(fill='transparent')) + 
          
        ylab("") + xlab("Normalized Enrichtment Score (NES)") + scale_size_area()
        g <- ggplot_gtable(ggplot_build(p))
        stripr <- which(grepl('strip-t', g$layout$name))
        fills <- alpha(c("red", "blue"), 0.4)
        k <- 1
        for (i in stripr) {
        j <- which(grepl('rect', g$grobs[[i]]$grobs[[1]]$childrenOrder))
        g$grobs[[i]]$grobs[[1]]$children[[j]]$gp$fill <- fills[k]
        k <- k+1}
     
        prow <- cowplot::plot_grid(g, labels = c(""), ncol = 1)
             
        title <- cowplot::ggdraw() +
        draw_label_themeRKwhite(paste(TITLE, Species, Tissue, Type, names(gseKEGGres2)[[x]]), 
                       element = "plot.title",x = 0.05, hjust     = 0, vjust = 1)
        subtitle <- cowplot::ggdraw() + 
        draw_label_themeRKwhite(paste("GSEA.KEGG-Pathways ", "with", lengths(kegg_gene_list[paste(names(kegg_gene_list)[names(kegg_gene_list)
                %in% names(gseKEGGres2)[[x]]])]),"DEGs after TPM-Filter (1 in 3)",
                sep = " "), element = "plot.subtitle",x = 0.05, hjust = 0, vjust = 1)
        if (OperatingSystem == "Mac" ) {quartz()}
        AA<- print(cowplot::plot_grid(title, subtitle, prow, ncol = 1, rel_heights = c(0.04, 0.05, 0.98)))
        ggsave(AA, filename = paste(paste(save_name, Type, Tissue, paste("GSEA.KEGG",FILENAME, names(gseKEGGres2)[[x]], sep="_"), sep="_") ,".png", sep=""), path = pathPlots , 
        device='png', dpi=300, width = 10,height = 10)},
    
      error=function(e){cat("ERROR :",conditionMessage(e), "\n")})}

      
    
      
        #######################    
        #WIKI Pathway Analysis#
        #######################
        print("WIKI Pathway Analysis")
        #http://www.bioconductor.org/packages/devel/bioc/vignettes/rWikiPathways/inst/doc/Pathway-Analysis.html
      tryCatch({
        gseWPres <- lapply(kegg_gene_list, function(x) {gseWP(geneList= x,
               pvalueCutoff = 0.05,
               pAdjustMethod = "fdr",
               organism = "Homo sapiens")}) 
        gseWPresReadable<- lapply(gseWPres, function(x) {setReadable(x, OrgDb = org.Hs.eg.db, keyType="ENTREZID")}) 
        
        gseWPres2 <- resProcessRK(gseWPres)
        gseWPres2<- Filter(function(x) nrow(x) > 0, gseWPres2)
        print(paste("Comparisons with significant gene set enrichment", sep =""))
        print(names(gseWPres2))
      
        gseWPres2 ->> gseWPres2
        
        }, error=function(e){cat("ERROR :",conditionMessage(e), "\n")})
        
       
        
        Order <- c("activated", "suppressed")
        require(forcats)
        for (xx in 1:length(gseWPres2)){ 
          tryCatch({
          p <- ggplot(gseWPres2[[xx]], aes(NES, fct_reorder(DescriptionWrap, NES))) + 
          geom_point(aes(size = GeneRatio, color = p.adjust)) + 
          scale_colour_gradient(limits=c(0, 0.06), low="green") + 
          facet_wrap(~factor(sign, levels=Order), scales = "free", nrow = 1) + atheme + 
        theme(axis.text.y = element_text(size = 10), strip.text.x = element_text(size = 10),
          legend.title =   element_text( size=10), legend.text=element_text(size=10), 
          axis.title = element_text(size = 10), 
          panel.background = element_rect(fill='transparent'),
          plot.background = element_rect(fill='transparent', color=NA), 
          legend.background = element_rect(fill='transparent'), #transparent legend bg
    legend.box.background = element_rect(fill='transparent')) + ylab("") + xlab("Normalized Enrichtment Score (NES)") 
          g <- ggplot_gtable(ggplot_build(p))
          stripr <- which(grepl('strip-t', g$layout$name))
          fills <- alpha(c("red", "blue"), 0.4)
          k <- 1
            for (i in stripr) {
            j <- which(grepl('rect', g$grobs[[i]]$grobs[[1]]$childrenOrder))
            g$grobs[[i]]$grobs[[1]]$children[[j]]$gp$fill <- fills[k]
            k <- k+1}
         prow <- cowplot::plot_grid(g, labels = c(""), ncol = 1)
        title <- cowplot::ggdraw() +
        draw_label_themeRKwhite(paste(TITLE, Species, Tissue, Type, names(gseWPres2)[[xx]]), 
                       element = "plot.title",x = 0.05, hjust     = 0, vjust = 1)
        subtitle <- cowplot::ggdraw() + 
        draw_label_themeRKwhite(paste("GSEA-WIKI-Pathways ", "with", lengths(kegg_gene_list[paste(names(kegg_gene_list)[names(kegg_gene_list)
                %in% names(gseWPres2)[[xx]]])]),"DEGs after TPM-Filter (1 in 3)",
                sep = " "), element = "plot.subtitle",x = 0.05, hjust = 0, vjust = 1)
        if (OperatingSystem == "Mac" ) {quartz()}
        AA<- print(cowplot::plot_grid(title, subtitle, prow, ncol = 1, rel_heights = c(0.04, 0.05, 0.98)))
        ggsave(AA, filename =    paste(paste(save_name, Type, Tissue, paste("GSEA.WIKI",FILENAME, names(gseWPres2)[[xx]], sep="_"), sep="_") ,".png", sep=""), path = pathPlots , 
               device='png', dpi=300, width = 10,height = 10)},
    
        error=function(e){cat("ERROR :",conditionMessage(e), "\n")})}
        
      #######################################
      #Combine KEGG and WIKI Pathway Outputs#
      #######################################  
    #   print(paste("Combined KEGG and WIKI gene set enrichment", sep =""))
    #   gseRES<-c(gseWPres2, gseKEGGres2)
    # 
    #   gseRES<- Filter(function(x) nrow(x) > 0, gseRES)
    #   lapply(gseRES, dim)
    # 
    #   gseRES<- tapply(gseRES, names(gseRES), dplyr::bind_rows)
    # 
    #   gseRES<- lapply(gseRES, function(x) {x$PathwayDescription <- paste(x$ID, x$DescriptionWrap,sep= "# ");return(x)})
    #   Order <- c("activated", "suppressed")
    #   for (xxx in 1:length(gseRES)){
    #   tryCatch({
    #     p <- ggplot(head(gseRES[[xxx]], 40), aes(NES, fct_reorder(PathwayDescription, NES))) +
    #     geom_point(aes(size = GeneRatio, color = p.adjust)) +
    #     scale_colour_gradient(limits=c(0, 0.06), low="red") +
    #     facet_wrap(~factor(sign, levels=Order), scales = "free", nrow = 1) + scale_size_area() + atheme +
    #     theme(axis.text.y = element_text(size = 10), strip.text.x = element_text(size = 10),
    #       legend.title =   element_text( size=10), legend.text=element_text(size=10),
    #       axis.title = element_text(size = 10),
    #       panel.background = element_rect(fill='transparent'),
    #       plot.background = element_rect(fill='transparent', color=NA),
    #       legend.background = element_rect(fill='transparent'), #transparent legend bg
    # legend.box.background = element_rect(fill='transparent')) + ylab("") + xlab("Normalized Enrichtment Score (NES)")
    #     g <- ggplot_gtable(ggplot_build(p))
    #     stripr <- which(grepl('strip-t', g$layout$name))
    #     fills <- alpha(c("red", "blue"), 0.4)
    #     k <- 1
    #     for (i in stripr) {
    #     j <- which(grepl('rect', g$grobs[[i]]$grobs[[1]]$childrenOrder))
    #     g$grobs[[i]]$grobs[[1]]$children[[j]]$gp$fill <- fills[k]
    #     k <- k+1}
    #     prow <- cowplot::plot_grid(g, labels = c(""), ncol = 1)
    #     title <- cowplot::ggdraw() +
    #     draw_label_themeRKwhite(paste(TITLE, Species, Tissue, Type, names(gseRES)[[xxx]]),
    #                    element = "plot.title",x = 0.05, hjust     = 0, vjust = 1)
    #     subtitle <- cowplot::ggdraw() +
    #     draw_label_themeRKwhite(paste("top 40 GSEA-KEGGandWIKI-Pathways", "of", paste(dim(gseRES[[xxx]])[1]), "regulated pathways",
    #                              "with", lengths(kegg_gene_list[paste(names(kegg_gene_list)[names(kegg_gene_list)
    #             %in% names(gseRES)[[xxx]]])]),"DEGs after TPM-Filter (1 in 3)",
    #             sep = " "), element = "plot.subtitle",x = 0.05, hjust = 0, vjust = 1)
    #     if (OperatingSystem == "Mac" ) {quartz()}
    #     AA<- print(cowplot::plot_grid(title, subtitle, prow, ncol = 1, rel_heights = c(0.04, 0.05, 0.98)))
    #     ggsave(AA, filename =          paste(paste(save_name, Type, Tissue, paste("KEGGandWIKI.GSEA",FILENAME, names(gseRES)[[xxx]], sep="_"), sep="_") ,".png", sep=""), path = pathPlots ,
    #            device='png', dpi=300, width = 10,height = 10)},
    # 
    #     error=function(e){cat("ERROR :",conditionMessage(e), "\n")})}

      # gseWPresReadableDat<-resProcessRK(gseWPresReadable)
      # gseKEGGresReadableDat<- resProcessRK(gseKEGGresReadable)
      # gseResReadable<-c(gseWPresReadableDat, gseKEGGresReadableDat)
      # 
      # gseResReadable<- Filter(function(x) nrow(x) > 0, gseResReadable)
      # lapply(gseResReadable, dim)
      # 
      # gseResReadable<- tapply(gseResReadable, names(gseResReadable), dplyr::bind_rows)
      # gseResReadable<- lapply(gseResReadable, function(x) {x$PathwayDescription <- paste(x$ID, x$DescriptionWrap,sep= "# ");return(x)})
      
  }, error=function(e){cat("ERROR :",conditionMessage(e), "\n")})

      # gseKEGGandWIKI <- list("gseKEGGandWIKI.Liver" = gseResReadable[names(gseResReadable)[grepl("Liver", names(gseResReadable))]],
      #            "gseKEGGandWIKI.Gill" = gseResReadable[names(gseResReadable)[grepl("Gill", names(gseResReadable))]])
   
  }, error=function(e){cat("ERROR :",conditionMessage(e), "\n")})
}

  
```

## 4.3 ORA

```{r}
# from:
# https://github.com/GuanSLhuangYu/clusterProfiler/blob/master/R/simplify.R
# I added `packagename::` in front of some function names, since this code is outside the package
# and does not "see" some of the packages/package functions imported 
# to the package environment
# but basically this is the unchanged `simplify_internal` function definition.

simplify_internal <- function(res, cutoff=0.7, by="p.adjust", select_fun=min, measure="Rel", ontology, semData) {
  if (missing(semData) || is.null(semData)) {
    if (measure == "Wang") {
      semData <- GOSemSim::godata(ont = ontology)
    } else {
      stop("godata should be provided for IC-based methods...")
    }
  } else {
    if (ontology != semData@ont) {
      msg <- paste("semData is for", semData@ont, "ontology, while enrichment result is for", ontology)
      stop(msg)
    }
  }
  
  sim <- GOSemSim::mgoSim(res$ID, res$ID,
                semData = semData,
                measure=measure,
                combine=NULL)
  
  ## to satisfy codetools for calling gather
  go1 <- go2 <- similarity <- NULL
  
  sim.df <- as.data.frame(sim)
  sim.df$go1 <- row.names(sim.df)
  sim.df <- tidyr::gather(sim.df, go2, similarity, -go1)
  
  sim.df <- sim.df[!is.na(sim.df$similarity),]
  
  ## feature 'by' is attached to 'go1'
  sim.df <- merge(sim.df, res[, c("ID", by)], by.x="go1", by.y="ID")
  sim.df$go2 <- as.character(sim.df$go2)
  
  ID <- res$ID
  
  GO_to_remove <- character()
  for (i in seq_along(ID)) {
    ii <- which(sim.df$go2 == ID[i] & sim.df$similarity > cutoff)
    ## if length(ii) == 1, then go1 == go2
    if (length(ii) < 2)
      next
    
    sim_subset <- sim.df[ii,]
    
    jj <- which(sim_subset[, by] == select_fun(sim_subset[, by]))
    
    ## sim.df <- sim.df[-ii[-jj]]
    GO_to_remove <- c(GO_to_remove, sim_subset$go1[-jj]) %>% unique
  }
  
  res[!res$ID %in% GO_to_remove, ]
}



WGCNAORAPlotRKwhite6SLUC_Publication <- function (TPM = TPM, vst = vst, Species = Species, TPM_value = 1, Samples = Samples, SAMDF = SAMDF,  TITLE = TITLE, filename= FILENAME , dedup_ids = dedup_ids, OutlineColor = OutlineColor) {
  tryCatch({
  #https://github.com/kevinblighe/E-MTAB-6141
  require(grid)
  require(DESeq2)
  require(tidyverse)
  require(cowplot)
  library(org.Hs.eg.db)
    
    #############TPM Filter#############
    tryCatch({
    #print("tpm")
    #print(dim(TPM))
    keep <- rowSums(TPM > TPM_value) >= 3
    
    TPMFilter<- TPM[keep,]
    #print(dim(TPMFilter))
    
    #print(paste("Genes before TPM Filter:", dim(dedup_ids)[1]))
    dedup_ids_tpm <- dedup_ids[dedup_ids$Geneid %in% rownames(TPMFilter),]
    #print(paste("Genes after TPM Filter:", dim(dedup_ids)[1]))
    }, error=function(e){cat("ERROR :",conditionMessage(e), "\n")})
    
    ########################################
    #Add annotated Gene-Names to omics data#
    ########################################
    ###############
    #Gene Ontology#
    ###############
      ####################################
      #Over-representation Analysis (ORA)#
      ####################################
        ####
        #GO#
        ####
      
        tryCatch({
        ######
        #KEGG#
        ######   
        KEGGUp <-enrichKEGG(
          dedup_ids_tpm$ENTREZID,
          organism = "hsa",
          keyType = "kegg",
          pvalueCutoff = 0.05,
          pAdjustMethod = "BH",
          use_internal_data = FALSE) #use_internal_data = FALSE
        
        KEGGUp <<- as.data.frame(KEGGUp)
        
        BB<-  as.data.frame(KEGGUp)  %>% arrange(p.adjust, desc(p.adjust)) %>%
        dplyr::slice_head(n = 10) 
        
        BBB <- ggplot(BB, aes(x=reorder(Description, -pvalue), y=Count, fill=-p.adjust)) +
        geom_bar(stat = "identity") +
        coord_flip() +
        scale_fill_continuous(low="deepskyblue3", high="#b11226") +
        labs(x = "", y = "", fill = "p.adjust") + #guides(fill="none") +
        theme(axis.text=element_text(size=7)) + 
        theme(plot.title = element_text( size = 7)) + theme_minimal() + atheme + 
          theme(axis.title.x = element_blank())
        prow <- cowplot::plot_grid(BBB, labels = c(""), ncol = 1)
        title <- ggdraw() + draw_label_themeRK(paste(TITLE), 
                            element = "plot.title",x = 0.05, hjust     = 0, vjust = 1)
        subtitle <- cowplot::ggdraw() + 
        draw_label_themeRK(paste("ORA KEGG top 10 of", length(KEGGUp$Description), "Pathways from", 
                                 nrow(dedup_ids),"regulated genes",sep = " "), 
                         element = "plot.subtitle",x = 0.05, hjust = 0, vjust = 1)
        BBB <- print(cowplot::plot_grid(title, subtitle, prow, ncol = 1, rel_heights = c(0.04, 0.05, 0.98)))
        ggsave(BBB, filename = paste(paste(save_name, paste(FILENAME, "KEGG", sep="_"), sep="_") ,".png", sep=""), path = pathPlots,
               device='png',        dpi=300, width = 6,height = 4)
        
        OraKeggPlot <<- BBB
        }, error=function(e){cat("ERROR :",conditionMessage(e), "\n")})
    }, error=function(e){cat("ERROR :",conditionMessage(e), "\n")})
}


WGCNAORAPlotRKwhite6SLUC <- function (TPM = TPM, vst = vst, Species = Species, TPM_value = 1, Samples = Samples, SAMDF = SAMDF,  TITLE = TITLE, filename= FILENAME , dedup_ids = dedup_ids, module = MODULE) {
  tryCatch({
  #https://github.com/kevinblighe/E-MTAB-6141
  require(grid)
  require(DESeq2)
  require(tidyverse)
  library(org.Hs.eg.db)
    
    #############TPM Filter#############
    tryCatch({
    #print("tpm")
    #print(dim(TPM))
    keep <- rowSums(TPM > TPM_value) >= 3
    
    TPMFilter<- TPM[keep,]
    #print(dim(TPMFilter))
    
    #print(paste("Genes before TPM Filter:", dim(dedup_ids)[1]))
    dedup_ids_tpm <- dedup_ids[dedup_ids$Geneid %in% rownames(TPMFilter),]
    #print(paste("Genes after TPM Filter:", dim(dedup_ids)[1]))
    }, error=function(e){cat("ERROR :",conditionMessage(e), "\n")})
    
    ########################################
    #Add annotated Gene-Names to omics data#
    ########################################
    ###############
    #Gene Ontology#
    ###############
      ####################################
      #Over-representation Analysis (ORA)#
      ####################################
        ####
        #GO#
        ####
        tryCatch({
        require(clusterProfiler)
        egoUp <- clusterProfiler::enrichGO(
        gene     = dedup_ids_tpm$ENTREZID,
        #universe = sig_KEGG$ENTREZID[!is.na(sig_KEGG$ENTREZID)],
        OrgDb    = org.Hs.eg.db,
        ont      = "BP", #Biological procress, CC
        pAdjustMethod = "BH",
        pvalueCutoff = 0.05, #p.adjust cutoff (https://github.com/GuangchuangYu/clusterProfiler/issues/104)
        readable = TRUE)
        #egoUP <- clusterProfiler::simplify(egoUp, cutoff=0.7, by="p.adjust", select_fun=min)
        
        egoUp <<- egoUp
        
        A <- as.data.frame(egoUp)  %>% arrange(p.adjust, desc(p.adjust)) %>%
        dplyr::slice_head(n = 50) 
          
        AA <- ggplot(A, aes(x=reorder(Description, -pvalue), y=Count, fill=-p.adjust)) +
        geom_bar(stat = "identity") +
        coord_flip() +
        scale_fill_continuous(low="blue", high="red") +
        labs(x = "", y = "", fill = "p.adjust") + #guides(fill="none") +
        theme(axis.text=element_text(size=7)) + 
        theme(plot.title = element_text( size = 7)) + theme_minimal() + atheme + 
        theme(axis.title.x = element_blank())
        
        prow <- cowplot::plot_grid(AA, labels = c(""), ncol = 1)
        
        title <- ggdraw() + draw_label_themeRKwhite(paste(FILENAME, "GO", module, sep="_"), 
                            element = "plot.title",x = 0.05, hjust     = 0, vjust = 1)

        subtitle <- cowplot::ggdraw() + 
        draw_label_themeRKwhite(paste("ORA top 50 GO BP", "with", nrow(dedup_ids_tpm),
                                 "regulated genes of", nrow(dedup_ids), "(TPM < 1)", sep = " "), 
                         element = "plot.subtitle",x = 0.05, hjust = 0, vjust = 1)
        AA<- cowplot::plot_grid(title, subtitle, prow, ncol = 1, rel_heights = c(0.04, 0.05, 0.98))
        ggsave(AA, filename = paste(paste(FILENAME, "GO", module, sep="_"), ".png", sep=""), path = pathPlots, 
               device='png', dpi=300, width = 8,height = 5)
        }, error=function(e){cat("ERROR :",conditionMessage(e), "\n")})
        
        tryCatch({
        ######
        #KEGG#
        ######   
        KEGGUp <-enrichKEGG(
          dedup_ids_tpm$ENTREZID,
          organism = "hsa",
          keyType = "kegg",
          pvalueCutoff = 0.05,
          pAdjustMethod = "BH",
          use_internal_data = FALSE) #use_internal_data = FALSE
        
        KEGGUp <<- KEGGUp
        
        KEGG_50 <-  as.data.frame(KEGGUp)  %>% arrange(p.adjust, desc(p.adjust)) %>%
        dplyr::slice_head(n = 50) 
        
        KEGG_plot <- ggplot(KEGG_50, aes(x=reorder(Description, -pvalue), y=Count, fill=-p.adjust)) +
        geom_bar(stat = "identity") +
        coord_flip() +
        scale_fill_continuous(low="blue", high="red") +
        labs(x = "", y = "", fill = "p.adjust") + #guides(fill="none") +
        theme(axis.text=element_text(size=7)) + 
        theme(plot.title = element_text( size = 7)) + theme_minimal() + atheme + 
          theme(axis.title.x = element_blank())
        prow <- cowplot::plot_grid(KEGG_plot, labels = c(""), ncol = 1)  
        title <- ggdraw() + draw_label_themeRKwhite(paste(FILENAME, "KEGG", module, sep="_"), 
                            element = "plot.title",x = 0.05, hjust     = 0, vjust = 1)
        subtitle <- cowplot::ggdraw() + 
        draw_label_themeRKwhite(paste("ORA KEGG top 50 of", length(rownames(BB)), "Pathways from", 
                                 nrow(dedup_ids),"regulated genes",sep = " "), 
                         element = "plot.subtitle",x = 0.05, hjust = 0, vjust = 1)
        KEGG_plot <- cowplot::plot_grid(title, subtitle, prow, ncol = 1, rel_heights = c(0.04, 0.05, 0.98))
        ggsave(KEGG_plot, filename = paste(paste(FILENAME, "KEGG", module, sep="_"), ".png", sep=""), path = pathPlots,device='png',        dpi=300, width = 8,height = 5)
        
        KEGG_plot <<- KEGG_plot
        
        
        
        }, error=function(e){cat("ERROR :",conditionMessage(e), "\n")})
  }, error=function(e){cat("ERROR :",conditionMessage(e), "\n")})
}

```


## 4.4 GeneHeatPlot

```{r include = FALSE}
GeneHeatPlotRK5_SL <- function (res = res, vst = vst, Species = Species, genes_of_interest = genes_of_interest, tpm = tpm, tpm_value = tpm_value, Samples = Samples, SAMDF = SAMDF,  TITLE = TITLE, filename= FILENAME, cluster_columns = CLUSTER_COLUMNS) {
  paste("Code Raphael Koll raphael.koll@uni-hamburg.de code adapted by https://github.com/kevinblighe/E-MTAB-6141")
  require(RColorBrewer)
  require(ComplexHeatmap)
  require(Cairo)
  require(circlize)
  require(digest)
  require(cluster)
  require(ComplexHeatmap)
  require(grid)
  require(DESeq2)
  require(tidyverse)
  require(ggplot2)
  

  
  Output     <- tpm[rownames(tpm) %in% vst$Symbol.sander,]
  Output2    <- Output[(rowSums(Output > tpm_value) >= 3),]
  Output3    <- vst[vst$Symbol.sander %in% rownames(Output2),]
  
  Output4    <- Output3[Output3$Human_SYMBOL_Manual_unique %in% genes_of_interest,]
  rownames(Output4) <- Output4$Human_SYMBOL_Manual_unique
  
  
  columnclusternum <-  if (gg == "Gill" ) {
      columnclusternum <- columnGillClusterNumber } else {
      columnclusternum <- columnLiverClusterNumber }
   rowclusternum <-  if (gg == "Gill" ) {
      rowclusternum <- rowGillClusterNumber } else {
      rownclusternum <- rowLiverClusterNumber }

  #z-Score of vst data
  heat       <- t(scale(t(as.matrix(Output4[, Samples]))))
  
  #make and order metadate fitting to matrix
  metadata   <- SAMDF[SAMDF$SampleID %in% colnames(heat),]
  metadata   <- metadata[order(match(metadata$SampleID, colnames(heat))), , drop = FALSE]
  
  annLoc        <- data.frame(Location = metadata$fLoc) #,stringsAsFactors = FALSE)
  annSeason    <- data.frame(Season   = metadata$fSeason)
  anno_df = data.frame(
    Location = annLoc,
    Season = annSeason)
  
  colAnn <-HeatmapAnnotation(
    annotation_name_side = "left",
    df =   anno_df,
    title = NULL,
    which = 'col', # 'col' (samples) or 'row' (gene) annotation?
    na_col = 'white', # default colour for any NA values in the annotation data-frame, 'ann'
    col = list(Location = col.Palette$col.Palette.Locs, Season = col.Palette$col.Palette.Season), 
    annotation_height = 0.4,
    annotation_width = unit(0.5, 'cm'),
    gap = unit(1, 'mm'),
    annotation_legend_param = list(
      Location = list(
        nrow = 1, # number of rows across which the legend will be arranged
        title = "Location", #
        title_position = 'topcenter',
        legend_direction = 'vertical',
        title_gp = gpar(col = "white",fontsize = 7, fontface = 'bold'),
        labels_gp = gpar(col = "white",fontsize = 7, fontface = 'bold')),
      Season = list(
        nrow = 1, # number of rows across which the legend will be arranged
        title = "Season", #
        title_position = 'topcenter',
        legend_direction = 'vertical',
        title_gp = gpar(col = "white",fontsize = 7, fontface = 'bold'),
        labels_gp = gpar(col = "white",fontsize = 7, fontface = 'bold'))))
      
  #label every 40th gene
   labelseqs<-if (dim(heat)[1] <= 100) { 
    labelseqs<- 1
    } else if (dim(heat)[1] <= 1000) {
    labelseqs<- 10
    } else {
    labelseqs<- 300}
  
   genelabels <- ComplexHeatmap::rowAnnotation(
    Genes = anno_mark(
      at = seq(1, nrow(heat), labelseqs),                         #Adjust the amount of lables
      labels = rownames(heat)[seq(1, nrow(heat), labelseqs)],
      labels_gp = gpar(col = "white",fontsize = 6, fontface = 'bold'),
      padding = 0.75),
      width = unit(1.0, 'cm') +
      ComplexHeatmap::max_text_width(
        rownames(heat)[seq(1, nrow(heat), 30)],
        gp = gpar(col = "white",fontsize = 6,  fontface = 'bold')))
  
  #define clusters, read from unclustered heatmap
  pamClusters <- cluster::pam(heat, k = rowclusternum) # pre-select k = 4 centers
  pamClusters$clustering <- paste0('Cluster ', pamClusters$clustering)
  # fix order of the clusters to have 1 to 4, top to bottom
  # fix order of the clusters to have 1 to 4, top to bottom
  pamClusters$clustering <- factor(pamClusters$clustering,
    levels = c('Cluster 1', 'Cluster 2', 'Cluster 3', 'Cluster 4', 'Cluster 5', 'Cluster 6'
               , 'Cluster 7', 'Cluster 8', 'Cluster 9', 'Cluster 10', 'Cluster 11', 'Cluster 12'))
  myCol <- colorRampPalette(c('blue', 'white', 'red'))(100)
  myBreaks <- seq(-3, 3, length.out = 100)
  #create heatmap

    hmap <- Heatmap(heat, #raster_device ="png",
    # split the genes / rows according to the PAM clusters
      split = pamClusters$clustering,
      column_km = columnclusternum,
      cluster_row_slices = FALSE,
    name = 'Taxa\nZ-\nscore',
    col = colorRamp2(myBreaks, myCol),
    # parameters for the colour-bar that represents gradient of expression
      heatmap_legend_param = list(
        color_bar = 'continuous',
        legend_direction = 'vertical',
        legend_width = unit(8, 'cm'),
        legend_height = unit(5.0, 'cm'),
        title_position = 'topcenter',
        title_gp=gpar(col = "white",fontsize = 8, fontface = 'bold'),
        labels_gp=gpar(col = "white",fontsize = 8, fontface = 'bold')),
    # row (gene) parameters
      cluster_rows = TRUE,
      show_row_dend = TRUE,
      #row_title = 'Statistically significant genes',
      row_title_side = 'left',
      row_title_gp = gpar(col = "white",fontsize = 8,  fontface = 'bold'),
      row_title_rot = 90,
      show_row_names = FALSE,
      row_names_gp = gpar(col = "white",fontsize = 8, fontface = 'bold'),
      row_names_side = 'right',
      row_dend_width = unit(25,'mm'),
    # column (sample) parameters
      cluster_columns = CLUSTER_COLUMNS, 
      show_column_dend = TRUE,
      column_title = NULL,
      column_title_side = 'bottom',
      column_title_gp = gpar(col = "white",fontsize = 1, fontface = 'bold'),
      column_title_rot = 0,
      show_column_names = TRUE,
      column_names_gp = gpar(col = "white",fontsize = 8, fontface = 'bold'),
      column_names_max_height = unit(8, 'cm'),
      column_dend_height = unit(25,'mm'),
    # cluster methods for rows and columns
      clustering_distance_columns = function(x) as.dist(1 - cor(t(x))),
      clustering_method_columns = 'ward.D2',
      clustering_distance_rows = function(x) as.dist(1 - cor(t(x))),
      clustering_method_rows = 'ward.D2',
    # specify top and bottom annotations
      top_annotation = colAnn
    )
      #bottom_annotation = boxplotCol) 
  require(cowplot)
  prow <- cowplot::plot_grid(grid.grabExpr(ComplexHeatmap::draw(hmap + genelabels,background = "transparent", 
    heatmap_legend_side = 'left',
    annotation_legend_side = 'bottom', #right
    row_sub_title_side = 'left')), labels = c(""), ncol = 1)
  title <- ggdraw() + TITLE
  subtitle <- ggdraw() + draw_label_themeRKwhite(paste("Heatmap of", " [vst-z-score ", length(genes_of_interest)," genes/ ",     dim(Output4)[1]," tpm >", tpm_value," in 3]", sep = " "), 
              element = "plot.subtitle",x = 0.05, hjust = 0, vjust = 1)
  A <- plot_grid(title, subtitle, prow, ncol = 1, rel_heights = c(0.04, 0.05, 0.98)) 
  #Safe the plots in a specified folder <- may have to change the width and height
  ggsave(A, filename = FILENAME, path = pathPlots , device='png', dpi=300, width = 10,
  height = 8)
  hmap <<- hmap #<<- assigns to workspace
} 

GeneHeatPlotRKnoClust_SL <- function (res = res, vst = vst, Species = Species, genes_of_interest = genes_of_interest, tpm = tpm, tpm_value = tpm_value, Samples = Samples, SAMDF = SAMDF,  TITLE = TITLE, filename= FILENAME2) {
  paste("Code Raphael Koll raphael.koll@uni-hamburg.de code adapted by https://github.com/kevinblighe/E-MTAB-6141")
  require(RColorBrewer)
  require(ComplexHeatmap)
  require(Cairo)
  require(circlize)
  require(digest)
  require(cluster)
  require(ComplexHeatmap)
  require(grid)
  require(DESeq2)
  require(tidyverse)
  require(ggplot2)
  
  Output     <- tpm[rownames(tpm) %in% vst$Symbol.sander,]
  Output2    <- Output[(rowSums(Output > tpm_value) >= 3),]
  Output3    <- vst[vst$Symbol.sander %in% rownames(Output2),]
  Output4    <- Output3[Output3$Human_SYMBOL_Manual_unique %in% genes_of_interest,]
  rownames(Output4) <- Output4$Human_SYMBOL_Manual_unique
  
  columnclusternum <-  if (gg == "Gill" ) {
      columnclusternum <- columnGillClusterNumber } else {
      columnclusternum <- columnLiverClusterNumber }
   rowclusternum <-  if (gg == "Gill" ) {
      rowclusternum <- rowGillClusterNumber } else {
      rownclusternum <- rowLiverClusterNumber }

  #z-Score of vst data
  heat       <- t(scale(t(as.matrix(Output4[, Samples]))))
  #sub uncharacterized for shorter names in heatmap
  rownames(heat) <- gsub("uncharacterized ", "",rownames(heat))
  #make and order metadate fitting to matrix
  metadata   <- SAMDF[SAMDF$SampleID %in% colnames(heat),]
  metadata   <- metadata[order(match(metadata$SampleID, colnames(heat))), , drop = FALSE]
  #create top-annotation
  
  
  annLoc        <- data.frame(Location = metadata$fLoc)#,stringsAsFactors = FALSE)
  annSeason    <- data.frame(Season   = metadata$fSeason)
  anno_df = data.frame(
    Location = annLoc,
    Season = annSeason)
  
  colAnn <-HeatmapAnnotation(
    annotation_name_side = "left",
    df =   anno_df,
    title = NULL,
    which = 'col', # 'col' (samples) or 'row' (gene) annotation?
    na_col = 'white', # default colour for any NA values in the annotation data-frame, 'ann'
    col = list(Location = col.Palette$col.Palette.Locs, Season = col.Palette$col.Palette.Season), 
    annotation_height = 0.4,
    annotation_width = unit(0.5, 'cm'),
    gap = unit(1, 'mm'),
    annotation_legend_param = list(
      Location = list(
        nrow = 1, # number of rows across which the legend will be arranged
        title = "Location", #
        title_position = 'topcenter',
        legend_direction = 'vertical',
        title_gp = gpar(col = "white",fontsize = 7, fontface = 'bold'),
        labels_gp = gpar(col = "white",fontsize = 7, fontface = 'bold')),
      Season = list(
        nrow = 1, # number of rows across which the legend will be arranged
        title = "Season", #
        title_position = 'topcenter',
        legend_direction = 'vertical',
        title_gp = gpar(col = "white",fontsize = 7, fontface = 'bold'),
        labels_gp = gpar(col = "white",fontsize = 7, fontface = 'bold'))))
      
  #label every 40th gene
   labelseqs<-if (dim(heat)[1] <= 100) { 
    labelseqs<- 1
    } else if (dim(heat)[1] <= 1000) {
    labelseqs<- 2
    } else {
    labelseqs<- 300}
  genelabels <- ComplexHeatmap::rowAnnotation(
    Genes = anno_mark(
      at = seq(1, nrow(heat), labelseqs),                         #Adjust the amount of lables
      labels = rownames(heat)[seq(1, nrow(heat), labelseqs)],
      labels_gp = gpar(col = "white",fontsize = 6, fontface = 'bold'),
      padding = 0.75),
      width = unit(1.0, 'cm') +
      ComplexHeatmap::max_text_width(
        rownames(heat)[seq(1, nrow(heat), 30)],
        gp = gpar(col = "white",fontsize = 6,  fontface = 'bold')))
  
  #define clusters, read from unclustered heatmap
  pamClusters <- cluster::pam(heat, k = rowclusternum) # pre-select k = 4 centers
  pamClusters$clustering <- paste0('Cluster ', pamClusters$clustering)
  # fix order of the clusters to have 1 to 4, top to bottom
  # fix order of the clusters to have 1 to 4, top to bottom
  pamClusters$clustering <- factor(pamClusters$clustering,
    levels = c('Cluster 1', 'Cluster 2', 'Cluster 3', 'Cluster 4', 'Cluster 5', 'Cluster 6'
               , 'Cluster 7', 'Cluster 8', 'Cluster 9', 'Cluster 10', 'Cluster 11', 'Cluster 12'))
  myCol <- colorRampPalette(c('blue', 'white', 'red'))(100)
  #myBreaks <- seq(-3, 3, length.out = 100)
  myBreaks <- seq(-1.5, 1.5, length.out = 100)
  #create heatmap
  
    #myCol <- colorRampPalette(c('dodgerblue', 'black', 'yellow'))(100)
    #myBreaks <- seq(-1.5, 1.5, length.out = 100)
  
    #myCol <- colorRampPalette(c('royalblue', 'white', 'red3'))(100)
    #myBreaks <- seq(-1.5, 1.5, length.out = 100)
  
    hmap <- Heatmap(heat, #raster_device ="png",
    # split the genes / rows according to the PAM clusters
      split = pamClusters$clustering,
      column_km = columnclusternum,
      cluster_row_slices = FALSE,
    name = 'Taxa\nZ-\nscore',
    col = colorRamp2(myBreaks, myCol),
    # parameters for the colour-bar that represents gradient of expression
      heatmap_legend_param = list(
        color_bar = 'continuous',
        legend_direction = 'vertical',
        legend_width = unit(8, 'cm'),
        legend_height = unit(5.0, 'cm'),
        title_position = 'topcenter',
        title_gp=gpar(col = "white",fontsize = 8, fontface = 'bold'),
        labels_gp=gpar(col = "white",fontsize = 8, fontface = 'bold')),
    # row (gene) parameters
      cluster_rows = TRUE,
      show_row_dend = TRUE,
      #row_title = 'Statistically significant genes',
      row_title_side = 'left',
      row_title_gp = gpar(col = "white",fontsize = 8,  fontface = 'bold'),
      row_title_rot = 90,
      show_row_names = FALSE,
      row_names_gp = gpar(col = "white",fontsize = 8, fontface = 'bold'),
      row_names_side = 'right',
      row_dend_width = unit(25,'mm'),
    # column (sample) parameters
      cluster_columns = F, 
      show_column_dend = F,
      column_title = NULL,
      column_title_side = 'bottom',
      column_title_gp = gpar(col = "white",fontsize = 1, fontface = 'bold'),
      column_title_rot = 0,
      show_column_names = TRUE,
      column_names_gp = gpar(col = "white",fontsize = 8, fontface = 'bold'),
      column_names_max_height = unit(8, 'cm'),
      column_dend_height = unit(25,'mm'),
    # cluster methods for rows and columns
      clustering_distance_columns = function(x) as.dist(1 - cor(t(x))),
      clustering_method_columns = 'ward.D2',
      clustering_distance_rows = function(x) as.dist(1 - cor(t(x))),
      clustering_method_rows = 'ward.D2',
    # specify top and bottom annotations
      top_annotation = colAnn)
      #bottom_annotation = boxplotCol) 
  require(cowplot)
  prow <- cowplot::plot_grid(grid.grabExpr(ComplexHeatmap::draw(hmap + genelabels, background = "transparent", 
    heatmap_legend_side = 'left',
    annotation_legend_side = 'bottom', #right
    row_sub_title_side = 'left')), labels = c(""), ncol = 1)
  title <- ggdraw() + TITLE
  subtitle <- ggdraw() + draw_label_themeRKwhite(paste("Heatmap of", " [vst-z-score ", length(genes_of_interest)," genes/ ",     dim(Output4)[1]," tpm >", tpm_value," in 3]", sep = " "), 
              element = "plot.subtitle",x = 0.05, hjust = 0, vjust = 1)
  b <- plot_grid(title, subtitle, prow, ncol = 1, rel_heights = c(0.04, 0.05, 0.98)) 
  #Safe the plots in a specified folder <- may have to change the width and height
  ggsave(b, filename = FILENAME2, path = pathPlots , device='png', dpi=300, width = 13,
  height = 8)
  hmap <<- hmap #<<- assigns to workspace
}

GeneHeatPlotRKnoClust_SL_tpm <- function (Species = Species, Input = Input, Samples = Samples, SAMDF = SAMDF,  TITLE = TITLE, filename= FILENAME2) {
  paste("Code Raphael Koll raphael.koll@uni-hamburg.de code adapted by https://github.com/kevinblighe/E-MTAB-6141")
  require(RColorBrewer)
  require(ComplexHeatmap)
  require(Cairo)
  require(circlize)
  require(digest)
  require(cluster)
  require(ComplexHeatmap)
  require(grid)
  require(DESeq2)
  require(tidyverse)
  require(ggplot2)
  
  columnclusternum <-  1
  rowclusternum <- 1
  #z-Score of vst data
  heat       <- t(scale(t(as.matrix(Input[, names(Input) %in% Samples]))))
  #heat       <- log2(Input[, Samples]+1)
  #sub uncharacterized for shorter names in heatmap
  rownames(heat) <- gsub("uncharacterized ", "",rownames(heat))
  #make and order metadate fitting to matrix
  metadata   <- SAMDF[SAMDF$SampleID %in% colnames(heat),]
  metadata   <- metadata[order(match(metadata$SampleID, colnames(heat))), , drop = FALSE]
  #create top-annotation

  
  annLoc        <- data.frame(Location = metadata$fLoc)
  annSeason    <- data.frame(Season   = metadata$fSeason)
  anno_df = data.frame(
    Location = annLoc,
    Season = annSeason)
  
  colAnn <-HeatmapAnnotation(
    annotation_name_side = "left",
    df =   anno_df,
    title = NULL,
    which = 'col', # 'col' (samples) or 'row' (gene) annotation?
    na_col = 'white', # default colour for any NA values in the annotation data-frame, 'ann'
    col = list(Location = col.Palette$col.Palette.Locs, Season = col.Palette$col.Palette.Season), 
    annotation_height = 0.4,
    annotation_width = unit(0.5, 'cm'),
    gap = unit(1, 'mm'),
    annotation_legend_param = list(
      Location = list(
        nrow = 1, # number of rows across which the legend will be arranged
        title = "Location", #
        title_position = 'topcenter',
        legend_direction = 'vertical',
        title_gp = gpar(col = OutlineColor,fontsize = 7, fontface = 'bold'),
        labels_gp = gpar(col = OutlineColor,fontsize = 7, fontface = 'bold')),
      Season = list(
        nrow = 1, # number of rows across which the legend will be arranged
        title = "Season", #
        title_position = 'topcenter',
        legend_direction = 'vertical',
        title_gp = gpar(col = OutlineColor,fontsize = 7, fontface = 'bold'),
        labels_gp = gpar(col = OutlineColor,fontsize = 7, fontface = 'bold')))
    )
      
  #label every 40th gene
   labelseqs<-if (dim(heat)[1] <= 100) { 
    labelseqs<- 1
    } else if (dim(heat)[1] <= 1000) {
    labelseqs<- 2
    } else {
    labelseqs<- 300}
  genelabels <- ComplexHeatmap::rowAnnotation(
    Genes = anno_mark(
      at = seq(1, nrow(heat), labelseqs),                         #Adjust the amount of lables
      labels = rownames(heat)[seq(1, nrow(heat), labelseqs)],
      labels_gp = gpar(col = OutlineColor,fontsize = 6, fontface = 'bold'),
      padding = 0.75),
      width = unit(1.0, 'cm') +
      ComplexHeatmap::max_text_width(
        rownames(heat)[seq(1, nrow(heat), 30)],
        gp = gpar(col = OutlineColor,fontsize = 6,  fontface = 'bold')))
  
  #define clusters, read from unclustered heatmap
  pamClusters <- cluster::pam(heat, k = rowclusternum) # pre-select k = 4 centers
  pamClusters$clustering <- paste0('Cluster ', pamClusters$clustering)
  # fix order of the clusters to have 1 to 4, top to bottom
  # fix order of the clusters to have 1 to 4, top to bottom
  pamClusters$clustering <- factor(pamClusters$clustering,
    levels = c('Cluster 1', 'Cluster 2', 'Cluster 3', 'Cluster 4', 'Cluster 5', 'Cluster 6'
               , 'Cluster 7', 'Cluster 8', 'Cluster 9', 'Cluster 10', 'Cluster 11', 'Cluster 12'))
  myCol <- colorRampPalette(c("deepskyblue3", 'white', "#b11226"))(100)
  #myBreaks <- seq(0, 1, length.out = 100)
  myBreaks <- seq(-2, 2, length.out = 100)
  #create heatmap
  
    #myCol <- colorRampPalette(c('dodgerblue', 'black', 'yellow'))(100)
    #myBreaks <- seq(-1.5, 1.5, length.out = 100)
  
    #myCol <- colorRampPalette(c('royalblue', 'white', 'red3'))(100)
    #myBreaks <- seq(-1.5, 1.5, length.out = 100)
  
    hmap <- Heatmap(heat, #raster_device ="png",
    # split the genes / rows according to the PAM clusters
      split = pamClusters$clustering,
      column_km = columnclusternum,
      cluster_row_slices = FALSE,
    name = 'Taxa\nZ-\nscore',
    col = colorRamp2(myBreaks, myCol),
    # parameters for the colour-bar that represents gradient of expression
      heatmap_legend_param = list(
        color_bar = 'continuous',
        legend_direction = 'vertical',
        legend_width = unit(8, 'cm'),
        legend_height = unit(5.0, 'cm'),
        title_position = 'topcenter',
        title_gp=gpar(col = OutlineColor,fontsize = 8, fontface = 'bold'),
        labels_gp=gpar(col = OutlineColor,fontsize = 8, fontface = 'bold')),
    # row (gene) parameters
      cluster_rows = TRUE,
      show_row_dend = TRUE,
      #row_title = 'Statistically significant genes',
      row_title_side = 'left',
      row_title_gp = gpar(col = OutlineColor,fontsize = 8,  fontface = 'bold'),
      row_title_rot = 90,
      show_row_names = FALSE,
      row_names_gp = gpar(col = OutlineColor,fontsize = 8, fontface = 'bold'),
      row_names_side = 'right',
      row_dend_width = unit(25,'mm'),
    # column (sample) parameters
      cluster_columns = F, 
      show_column_dend = F,
      column_title = NULL,
      column_title_side = 'bottom',
      column_title_gp = gpar(col = OutlineColor,fontsize = 1, fontface = 'bold'),
      column_title_rot = 0,
      show_column_names = TRUE,
      column_names_gp = gpar(col = OutlineColor,fontsize = 8, fontface = 'bold'),
      column_names_max_height = unit(8, 'cm'),
      column_dend_height = unit(25,'mm'),
    # cluster methods for rows and columns
      clustering_distance_columns = function(x) as.dist(1 - cor(t(x))),
      clustering_method_columns = 'ward.D2',
      clustering_distance_rows = function(x) as.dist(1 - cor(t(x))),
      clustering_method_rows = 'ward.D2',
    # specify top and bottom annotations
      top_annotation = colAnn)
      #bottom_annotation = boxplotCol) 
  require(cowplot)
  prow <- cowplot::plot_grid(grid.grabExpr(ComplexHeatmap::draw(hmap + genelabels, background = "transparent", 
    heatmap_legend_side = 'left',
    annotation_legend_side = 'bottom', #right
    row_sub_title_side = 'left')), labels = c(""), ncol = 1)
  title <- ggdraw() + TITLE
  subtitle <- ggdraw() + draw_label_themeRKwhite(paste("Heatmap of", " [tpm-z-score ", dim(Input)[1], " genes/ ",     " tpm >", tpm_value," in 3]", sep = " "), 
              element = "plot.subtitle",x = 0.05, hjust = 0, vjust = 1)
  GeneHeatPlotRKnoClust_SL_tpm_plot <- plot_grid(title, subtitle, prow, ncol = 1, rel_heights = c(0.04, 0.05, 0.98)) 
  #Safe the plots in a specified folder <- may have to change the width and height
  ggsave(GeneHeatPlotRKnoClust_SL_tpm_plot, filename = FILENAME2, path = pathPlots, device='png', dpi=300, width = 10,
  height = 10)
  hmap <<- hmap #<<- assigns to workspace
  GeneHeatPlotRKnoClust_SL_tpm_plot <<- GeneHeatPlotRKnoClust_SL_tpm_plot
}

GeneHeatPlotRK_Clust_SL_tpm_core <- function (Species = Species, Input = Input, Samples = Samples, SAMDF = SAMDF,  TITLE = TITLE, filename= FILENAME2, OutlineColor = OutlineColor) {
    paste("Code Raphael Koll raphael.koll@uni-hamburg.de code adapted by https://github.com/kevinblighe/E-MTAB-6141")
    require(RColorBrewer)
    require(ComplexHeatmap)
    require(Cairo)
    require(circlize)
    require(digest)
    require(cluster)
    require(ComplexHeatmap)
    require(grid)
    require(DESeq2)
    require(tidyverse)
    require(ggplot2)
    
    columnclusternum <-  if (Tissue == "Gill" ) {
        columnclusternum <- columnGillClusterNumber } else {
            columnclusternum <- columnLiverClusterNumber }
    rowclusternum <-  if (Tissue == "Gill" ) {
        rowclusternum <- rowGillClusterNumber } else {
            rownclusternum <- rowLiverClusterNumber }
    
    #z-Score of vst data
    heat       <- t(scale(t(as.matrix(Input[, Samples]))))
    rownames(heat) <- gsub("uncharacterized ", "",rownames(heat))
    
    
    #############################
    #Create Core Gene Annotation#
    #############################
    CoreTaxa <- list()
    #numeric(length(IndicatorTaxa))
    for (x in 1:dim(heat)[1]) {
        if (rownames(heat)[x] %in% Core) {
            CoreTaxa[[x]] <- 1
            names(CoreTaxa)[[x]] <- rownames(heat)[x]
        } else {
            CoreTaxa[x] <- 0.05
            names(CoreTaxa)[[x]] <- rownames(heat)[x]
        }}
    
    #Core_Microbiome_Annotation = rowAnnotation(Core = unlist(CoreTaxa))
    Core_Labels <- names(unlist(CoreTaxa))
    
    
    row_ha = rowAnnotation(
        
        "LFC" = unlist(CoreTaxa),
        col = list("LFC" = c("1" = "#FF3399", "0.05" = "#FFFFF0")),
        
        Genes = anno_mark(
            at = which(rownames(heat) %in% Core),
            labels = rownames(heat)[rownames(heat) %in% Core],
            labels_gp = gpar(col = OutlineColor,fontsize = 6, fontface = 'bold'),
            padding = 0.75),
        width = unit(1.0, 'cm') +
            ComplexHeatmap::max_text_width(
                rownames(heat)[seq(1, nrow(heat), 30)],
                gp = gpar(col = OutlineColor,fontsize = 6,  fontface = 'bold')))
    
    #make and order metadate fitting to matrix
    metadata   <- SAMDF[SAMDF$SampleID %in% colnames(heat),]
    metadata   <- metadata[order(match(metadata$SampleID, colnames(heat))), , drop = FALSE]
    #create top-annotation

    
    annLoc        <- data.frame(Location = metadata$fLoc)#,stringsAsFactors = FALSE)
    annSeason    <- data.frame(Season   = metadata$fSeason)
    anno_df = data.frame(
        Location = annLoc,
        Season = annSeason)
    
    colAnn <-HeatmapAnnotation(
        annotation_name_side = "left",
        df =   anno_df,
        title = NULL,
        which = 'col', # 'col' (samples) or 'row' (gene) annotation?
        na_col = 'white', # default colour for any NA values in the annotation data-frame, 'ann'
        col = list(Location = col.Palette$col.Palette.LOC, Season = col.Palette$col.Palette.Season, 
        annotation_height = 0.4,
        annotation_width = unit(0.5, 'cm'),
        gap = unit(1, 'mm'),
        annotation_legend_param = list(
            Location = list(
                nrow = 1, # number of rows across which the legend will be arranged
                title = "Location", #
                title_position = 'topcenter',
                legend_direction = 'vertical',
                title_gp = gpar(col = OutlineColor,fontsize = 7, fontface = 'bold'),
                labels_gp = gpar(col = OutlineColor,fontsize = 7, fontface = 'bold')),
            Season = list(
                nrow = 1, # number of rows across which the legend will be arranged
                title = "Season", #
                title_position = 'topcenter',
                legend_direction = 'vertical',
                title_gp = gpar(col = OutlineColor,fontsize = 7, fontface = 'bold'),
                labels_gp = gpar(col = OutlineColor,fontsize = 7, fontface = 'bold')))
    ))
    
    # #label every 40th gene
    #  labelseqs<-if (dim(heat)[1] <= 100) { 
    #   labelseqs<- 1
    #   } else if (dim(heat)[1] <= 1000) {
    #   labelseqs<- 2
    #   } else {
    #   labelseqs<- 300}
    # genelabels <- ComplexHeatmap::rowAnnotation(
    #   Genes = anno_mark(
    #     at = seq(1, nrow(heat), labelseqs),                         #Adjust the amount of lables
    #     labels = rownames(heat)[seq(1, nrow(heat), labelseqs)],
    #     labels_gp = gpar(col = "white",fontsize = 6, fontface = 'bold'),
    #     padding = 0.75),
    #     width = unit(1.0, 'cm') +
    #     ComplexHeatmap::max_text_width(
    #       rownames(heat)[seq(1, nrow(heat), 30)],
    #       gp = gpar(col = "white",fontsize = 6,  fontface = 'bold')))
    
    pamClusters <- cluster::pam(heat, k = rowclusternum) # pre-select k = 4 centers
    pamClusters$clustering <- paste0('Cluster ', pamClusters$clustering)
    # fix order of the clusters to have 1 to 4, top to bottom
    # fix order of the clusters to have 1 to 4, top to bottom
    pamClusters$clustering <- factor(pamClusters$clustering,
                                     levels = c('Cluster 1', 'Cluster 2', 'Cluster 3', 'Cluster 4', 'Cluster 5', 'Cluster 6'
                                                , 'Cluster 7', 'Cluster 8', 'Cluster 9', 'Cluster 10', 'Cluster 11', 'Cluster 12'))
    myCol <- colorRampPalette(c("deepskyblue3", "#FFFFF0", "#b11226"))(100)
    #myBreaks <- seq(0, 1, length.out = 100)
    myBreaks <- seq(-2, 2, length.out = 100)
    #create heatmap
    
    
    hmap <- Heatmap(use_raster = TRUE, 
                    heat, #raster_device ="png",
                    # split the genes / rows according to the PAM clusters
                    right_annotation = row_ha,
                    #left_annotation = Core_Microbiome_Annotation,
                    split = pamClusters$clustering,
                    column_km = columnclusternum,
                    cluster_row_slices = FALSE,
                    name = 'Genes\ntpm-Z-\nscore',
                    col = colorRamp2(myBreaks, myCol),
                    # parameters for the colour-bar that represents gradient of expression
                    heatmap_legend_param = list(
                        color_bar = 'continuous',
                        legend_direction = 'vertical',
                        legend_width = unit(8, 'cm'),
                        legend_height = unit(5.0, 'cm'),
                        title_position = 'topcenter',
                        title_gp=gpar(col = OutlineColor,fontsize = 8, fontface = 'bold'),
                        labels_gp=gpar(col = OutlineColor,fontsize = 8, fontface = 'bold')),
                    # row (gene) parameters
                    cluster_rows = TRUE,
                    show_row_dend = TRUE,
                    #row_title = 'Statistically significant genes',
                    row_title_side = 'left',
                    row_title_gp = gpar(col = OutlineColor,fontsize = 8,  fontface = 'bold'),
                    row_title_rot = 90,
                    show_row_names = FALSE,
                    row_names_gp = gpar(col = OutlineColor,fontsize = 8, fontface = 'bold'),
                    row_names_side = 'right',
                    row_dend_width = unit(25,'mm'),
                    # column (sample) parameters
                    cluster_columns = F, 
                    show_column_dend = F,
                    column_title = NULL,
                    column_title_side = 'bottom',
                    column_title_gp = gpar(col = OutlineColor,fontsize = 1, fontface = 'bold'),
                    column_title_rot = 0,
                    show_column_names = TRUE,
                    column_names_gp = gpar(col = OutlineColor,fontsize = 8, fontface = 'bold'),
                    column_names_max_height = unit(8, 'cm'),
                    column_dend_height = unit(25,'mm'),
                    # cluster methods for rows and columns
                    clustering_distance_columns = function(x) as.dist(1 - cor(t(x))),
                    clustering_method_columns = 'ward.D2',
                    clustering_distance_rows = function(x) as.dist(1 - cor(t(x))),
                    clustering_method_rows = 'ward.D2',
                    # specify top and bottom annotations
                    top_annotation = colAnn,
                    #bottom_annotation = boxplotCol
                    width = unit(WidthValue, "cm"), height = unit(HeightValue, "cm")) 
    
    
    hmap <<- hmap #<<- assigns to workspace
    cowplot::plot_grid(grid.grabExpr(
        ComplexHeatmap::draw(hmap, background = "transparent", 
                             heatmap_legend_side = 'left',
                             annotation_legend_side = 'bottom',
                             row_sub_title_side = 'left', 
                             column_title = paste(Species, Tissue, Type, "Heatmap of", " [tpm-z-score ", dim(Input)[1], " genes/ ",     " tpm >", tpm_value," in 3]", sep = " "), 
                             column_title_gp = gpar(fontsize = 10))
    ), labels = c(""), ncol = 1) -> part_1
    
    
    ggsave(part_1, filename = FILENAME2, path = pathPlots, device='png', dpi=300, 
           width = WidthValue,
           height = HeightValue)
}
```

#-

# 5 WGCNA 

## 5.1  HeatPlot

```{r}
BacteriaHeatPlotRKnoClust <- function (clr = clr, Species = Species, min_count = 10, genes_of_interest = genes_of_interest, Samples = Samples, SAMDF = SAMDF,  TITLE = TITLE, filename= FILENAME, OutlineColor = OutlineColor) {
  paste("Code Raphael Koll raphael.koll@uni-hamburg.de code adapted by https://github.com/kevinblighe/E-MTAB-6141")
  require(RColorBrewer)
  require(ComplexHeatmap)
  require(Cairo)
  require(circlize)
  require(digest)
  require(cluster)
  require(ComplexHeatmap)
  require(grid)
  require(DESeq2)
  require(tidyverse)
  require(ggplot2)
  
  #res <- res[res$baseMean >= 10,] #Select Species with Basemean higher 10
  #Output     <- vst[rownames(vst) %in% ress$rowname,]
  #Output2    <- Output[(rowSums(Output > min_count) >= 3),]
  #Output3    <- vst[rownames(vst) %in% rownames(Output2),]
  
  Output4    <- clr[names(clr) %in% genes_of_interest]
  Output4    <- na.omit(Output4)
  Output4    <- as.data.frame(t(Output4))
  
  Output4 <- Output4[, match(Samples, colnames(Output4))]

  #z-Score of vst data
  heat       <- t(as.matrix(scale(t(Output4), center = TRUE, scale = TRUE)))

  #heat       <- t(scale(t(as.matrix(Output4))))
  #make and order metadate fitting to matrix
  metadata   <- SAMDF[SAMDF$SampleID %in% colnames(heat),]
  metadata   <- metadata[order(match(metadata$SampleID, colnames(heat))), , drop = FALSE]
  
  annLOC        <- data.frame(Location = metadata$fLOC)#,stringsAsFactors = FALSE)
  annSeason     <- data.frame(Season   = metadata$fSeason)
  anno_df = data.frame(
    Location = annLOC,
    Season = annSeason)
  
  COL.LOC <- col.Palette$col.Palette.LOC[names(col.Palette$col.Palette.LOC) %in% metadata$fLOC]
  COL.Season <- col.Palette$col.Palette.Season[names(col.Palette$col.Palette.Season) %in% metadata$fSeason]
  
  colAnn <-HeatmapAnnotation(
    annotation_name_side = "left",
    df =   anno_df,
    title = NULL,
    which = 'col', # 'col' (samples) or 'row' (gene) annotation?
    na_col = OutlineColor, # default colour for any NA values in the annotation data-frame, 'ann'
    col = list(Location = COL.LOC,
               Season   = COL.Season), 
    height = unit(2, "cm"),
    #annotation_width = unit(0.5, 'cm'),
    #gap = unit(0.5, 'mm'),
    annotation_legend_param = list(
      Location = list(
        nrow = 1, # number of rows across which the legend will be arranged
        title = "Location", #
        title_position = 'topcenter',
        legend_direction = 'vertical',
        title_gp = gpar(col = OutlineColor,fontsize = 7, fontface = 'bold'),
        labels_gp = gpar(col = OutlineColor,fontsize = 7, fontface = 'bold')),
      Season = list(
        nrow = 1, # number of rows across which the legend will be arranged
        title = "Season", #
        title_position = 'topcenter',
        legend_direction = 'vertical',
        title_gp = gpar(col = OutlineColor,fontsize = 7, fontface = 'bold'),
        labels_gp = gpar(col = OutlineColor,fontsize = 7, fontface = 'bold'))
      ))
  
  
    #############################
    #Create Core Taxa Annotation#
    #############################
    CoreTaxa <- list()
    #numeric(length(IndicatorTaxa))
    for (x in 1:dim(heat)[1]) {
      if (rownames(heat)[x] %in%  pslist[[names(pslist)[grepl(paste("Core", Datasetname, sep="_"), names(pslist))]]]$ASV) {
      CoreTaxa[[x]] <- 1
      names(CoreTaxa)[[x]] <- rownames(heat)[x]
    } else {
    CoreTaxa[x] <- 0
      names(CoreTaxa)[[x]] <- rownames(heat)[x]
    }}

    #Core_Microbiome_Annotation = rowAnnotation(Core = unlist(CoreTaxa))
    Core_Labels <- names(unlist(CoreTaxa))
    Core_Microbiome_Annotation = rowAnnotation(Core = unlist(CoreTaxa),
    col = list(Core = c("1" = "#FF3399", "0" = "white") ))
  

  #label every 40th gene
   labelseqs<-if (dim(heat)[1] <= 150) { 
    labelseqs<- 1
    } else if (dim(heat)[1] <= 1000) {
    labelseqs<- 10
    } else {
    labelseqs<- 100}
  genelabels <- ComplexHeatmap::rowAnnotation(
    Genes = anno_mark(
      at = seq(1, nrow(heat), labelseqs),                         #Adjust the amount of lables
      labels = rownames(heat)[seq(1, nrow(heat), labelseqs)],
      labels_gp = gpar(col = OutlineColor,fontsize = 6, fontface = 'bold'),
      padding = 0.75),
      width = unit(1.0, 'cm') +
      ComplexHeatmap::max_text_width(
        rownames(heat)[seq(1, nrow(heat), 30)],
        gp = gpar(col = OutlineColor,fontsize = 6,  fontface = 'bold')))
  #define clusters, read from unclustered heatmap


  pamClusters <- cluster::pam(heat, k = rowclusternum) # pre-select k = 4 centers
  pamClusters$clustering <- paste0('Cluster ', pamClusters$clustering)
  # fix order of the clusters to have 1 to 4, top to bottom
  # fix order of the clusters to have 1 to 4, top to bottom
  pamClusters$clustering <- factor(pamClusters$clustering,
    levels = c('Cluster 1', 'Cluster 2', 'Cluster 3', 'Cluster 4', 'Cluster 5', 'Cluster 6'))
  myCol <- colorRampPalette(c('blue', 'white', 'red'))(100)
  myBreaks <- seq(-3, 3, length.out = 100)
  #create heatmap

    hmap <- Heatmap(heat, #raster_device ="png",
            right_annotation = Core_Microbiome_Annotation,
    # split the genes / rows according to the PAM clusters
      #split = pamClusters$clustering,
      #column_km = columnclusternum,
      cluster_row_slices = FALSE,
    name = 'Taxa\nZ-\nscore',
    col = colorRamp2(myBreaks, myCol),
    # parameters for the colour-bar that represents gradient of expression
      heatmap_legend_param = list(
        color_bar = 'continuous',
        legend_direction = 'vertical',
        legend_width = unit(8, 'cm'),
        legend_height = unit(5.0, 'cm'),
        title_position = 'topcenter',
        title_gp=gpar(col = OutlineColor,fontsize = 8, fontface = 'bold'),
        labels_gp=gpar(col = OutlineColor,fontsize = 8, fontface = 'bold')),
    # row (gene) parameters
      cluster_rows = TRUE,
      show_row_dend = TRUE,
      #row_title = 'Statistically significant genes',
      row_title_side = 'left',
      row_title_gp = gpar(col = OutlineColor,fontsize = 8,  fontface = 'bold'),
      row_title_rot = 90,
      show_row_names = FALSE,
      row_names_gp = gpar(col = OutlineColor,fontsize = 8, fontface = 'bold'),
      row_names_side = 'right',
      row_dend_width = unit(25,'mm'),
    # column (sample) parameters
      cluster_columns = FALSE, 
      show_column_dend = FALSE,
      column_title = NULL,
      column_title_side = 'bottom',
      column_title_gp = gpar(col = OutlineColor,fontsize = 1, fontface = 'bold'),
      column_title_rot = 0,
      show_column_names = TRUE,
      column_names_gp = gpar(col = OutlineColor,fontsize = 8, fontface = 'bold'),
      column_names_max_height = unit(8, 'cm'),
      column_dend_height = unit(25,'mm'),
    # cluster methods for rows and columns
      clustering_distance_columns = function(x) as.dist(1 - cor(t(x))),
      clustering_method_columns = 'ward.D2',
      clustering_distance_rows = function(x) as.dist(1 - cor(t(x))),
      clustering_method_rows = 'ward.D2',
    # specify top and bottom annotations
      top_annotation = colAnn)
      #bottom_annotation = boxplotCol) 
  require(cowplot)
  prow <- cowplot::plot_grid(grid.grabExpr(draw(hmap + genelabels,background = "transparent", 
    heatmap_legend_side = 'left',
    annotation_legend_side = 'bottom', #right
    row_sub_title_side = 'left')), labels = c(""), ncol = 1)
  title <- ggdraw() + TITLE
  subtitle <- ggdraw() + draw_label_themeRKwhite(paste("Heatmap of", " [vst-z-score ", length(genes_of_interest)," tatxa/ ",     dim(Output4)[1],"Basemean >", min_count,"]", sep = " "), 
              element = "plot.subtitle",x = 0.05, hjust = 0, vjust = 1)
  A <- plot_grid(title, subtitle, prow, ncol = 1, rel_heights = c(0.04, 0.05, 0.98)) 
  #Safe the plots in a specified folder <- may have to change the width and height
  #plot(A)
  ggsave(A, filename = FILENAME, path = pathPlots, device='png', dpi=300, width = 12,
  height = 8)
  hmap <<- hmap #<<- assigns to workspace
}

```

## 5.2 Integrated_WGCNA_Heatmap

### 5.2 RNA

```{r,  message=FALSE,warning=FALSE}
WGCNA_IntegratedHeatmap_RNA_RK <- function (
  SAM_MEs = SAM_MEs,
  SSU_MEs = SSU_MEs,
  RNA_MEs = RNA_MEs,
  WIDTH = WIDTH,
  HEIGHT = HEIGHT,
  OutlineColor = OutlineColor,
  traitData = traitData) {
  tryCatch({
  ########################
  #Transcriptomes Heatmap#
  ########################
  require(RColorBrewer)
  require(ComplexHeatmap)
  require(Cairo)
  require(circlize)
  require(digest)
  require(cluster)
  require(ComplexHeatmap)
  require(grid)
  require(DESeq2)
  require(tidyverse)
  require(ggplot2)
  require(cowplot)
  #print("Transcriptomes Heatmap")
  columnclusternum <- 1
  rowclusternum    <- 1
  heat       <- t(as.matrix(scale(RNA_MEs, center = TRUE, scale = TRUE)))
  metadata   <- SAM_MEs[SAM_MEs$SampleID %in% colnames(heat),]
  metadata   <- metadata[order(match(rownames(metadata), colnames(heat))), , drop = FALSE]
  #create top-annotation

  annLoc        <- data.frame(Location = metadata$fLOC)#,stringsAsFactors = FALSE)
  annSeason    <- data.frame(Season   = metadata$fSeason)
  anno_df = data.frame(Location = annLoc,Season = annSeason)
  
  COL.LOC <- col.Palette$col.Palette.LOC[names(col.Palette$col.Palette.LOC) %in% metadata$fLOC]
  COL.Season <- col.Palette$col.Palette.Season[names(col.Palette$col.Palette.Season) %in% metadata$fSeason]
  
  colAnn <-HeatmapAnnotation(
    show_legend = c(FALSE, FALSE, FALSE),
    show_annotation_name = FALSE, 
    annotation_name_side = "left",
    df =   anno_df,
    title = NULL,
    which = 'col', # 'col' (samples) or 'row' (gene) annotation?
    na_col = 'white', # default colour for any NA values in the annotation data-frame, 'ann'
    col = list(Location = COL.LOC , Season = COL.Season), 
    annotation_height = 0.4,
    annotation_width = unit(0.5, 'cm'),
    gap = unit(1, 'mm'),
    annotation_legend_param = list(
      Location = list(
        nrow = 1, # number of rows across which the legend will be arranged
        title = "Location", #
        title_position = 'topcenter',
        legend_direction = 'vertical',
        title_gp = gpar(col = OutlineColor,fontsize = 12, fontface = 'bold'),
        labels_gp = gpar(col = OutlineColor,fontsize = 12, fontface = 'bold')),
      Season = list(
        nrow = 1, # number of rows across which the legend will be arranged
        title = "Season", #
        title_position = 'topcenter',
        legend_direction = 'vertical',
        title_gp = gpar(col = OutlineColor,fontsize = 12, fontface = 'bold'),
        labels_gp = gpar(col = OutlineColor,fontsize = 12, fontface = 'bold'))))
    
    #label every 40th gene
    labelseqs <-if (dim(heat)[1] <= 100) { 
    labelseqs <- 1
    } else if (dim(heat)[1] <= 1000) {
    labelseqs<- 2
    } else {
    labelseqs<- 300}
  genelabels <- ComplexHeatmap::rowAnnotation(
    Genes = anno_mark(
      at = seq(1, nrow(heat), labelseqs),                         #Adjust the amount of lables
      labels = rownames(heat)[seq(1, nrow(heat), labelseqs)],
      labels_gp = gpar(col = OutlineColor,fontsize = 12, fontface = 'bold'),
      padding = 0.75),
      width = unit(1.0, 'cm') +
      ComplexHeatmap::max_text_width(
        rownames(heat)[seq(1, nrow(heat), 30)],
        gp = gpar(col = OutlineColor,fontsize = 12,  fontface = 'bold')))
  #myCol <- colorRampPalette(c('blue', 'white', 'red'))(100)
  myCol <- colorRampPalette(c("#18b29f","#FFFFFF", "#ac6721"))(100)
  #myBreaks <- seq(-3, 3, length.out = 100)
  myBreaks <- seq(-2.5, 2.5, length.out = 100)
  #create heatmap
  
  
  Heatmap(heat, #raster_device ="png",
    # split the genes / rows according to the PAM clusters
      #split = pamClusters$clustering,
      column_km = columnclusternum,
      cluster_row_slices = FALSE,
      name = 'Z-\nscore',
    col = colorRamp2(myBreaks, myCol),
    # parameters for the colour-bar that represents gradient of expression
      heatmap_legend_param = list(
        color_bar = 'continuous',
        legend_direction = 'vertical',
        legend_width = unit(8, 'cm'),
        legend_height = unit(5.0, 'cm'),
        title_position = 'topcenter',
        title_gp=gpar(col = OutlineColor,fontsize = 12, fontface = 'bold'),
        labels_gp=gpar(col = OutlineColor,fontsize = 12, fontface = 'bold')),
    
    # row (gene) parameters
      cluster_rows = FALSE,
      show_row_dend = TRUE,

      row_title_side = 'left',
      row_title_gp = gpar(col = OutlineColor,fontsize = 12,  fontface = 'bold'),
      row_title_rot = 90,
      show_row_names = TRUE,
      row_names_gp = gpar(col = OutlineColor,fontsize = 12, fontface = 'bold'),
      row_names_side = 'right',
      row_dend_width = unit(25,'mm'),

      cluster_columns = FALSE, 
      show_column_dend = FALSE,
    
      column_title = NULL,
      column_title_side = 'bottom',
      column_title_gp = gpar(col = OutlineColor,fontsize = 1, fontface = 'bold'),
      column_title_rot = 0,
      show_column_names = FALSE,
      column_names_gp = gpar(col = OutlineColor,fontsize = 12, fontface = 'bold'),
      column_names_max_height = unit(12, 'cm'),
      column_dend_height = unit(25,'mm'),

      clustering_distance_columns = function(x) as.dist(1 - cor(t(x))),
      clustering_method_columns = 'ward.D2',
      clustering_distance_rows = function(x) as.dist(1 - cor(t(x))),
      clustering_method_rows = 'ward.D2',
  
      # specify top and bottom annotations
      top_annotation = colAnn, 
      show_heatmap_legend = TRUE, 
  
      width = unit(length(colnames(heat))*0.11, "cm")) -> RNA_hmap
      #bottom_annotation = boxplotCol) 

  #################
  #Cor-Mat RNA-SSU#
  #################
  #print("Cor-Mat RNA-SSU")
  p.value_matr <- corr.value_matr <- matrix(ncol = ncol(SSU_MEs), nrow = ncol(RNA_MEs), 
                                          dimnames = list(colnames(RNA_MEs), colnames(SSU_MEs)))
  for(ii in 1:ncol(RNA_MEs)){
    for(j in 1:ncol(SSU_MEs)){
      cor.res <- cor.test(RNA_MEs[,ii], SSU_MEs[,j])
      p.value_matr[ii, j] <- cor.res$p.value
      corr.value_matr[ii, j] <- cor.res$estimate
      }
    }
  
  # Correct for number of tests
  p.value_matr.adjust <- p.adjust(p.value_matr, method = "fdr")
  dim(p.value_matr.adjust) <- dim(p.value_matr)
  dimnames(p.value_matr.adjust) <- list(colnames(RNA_MEs), colnames(SSU_MEs))

  # Collect all results into a list.
  SSU_corr_RNA <- list(p_value = p.value_matr, 
                 p_value_adj = p.value_matr.adjust,
                 correlation = corr.value_matr)
  
  myCol <- colorRampPalette(c("#18b29f","#FFFFFF", "#ac6721"))(100)
  myBreaks <- seq(-1, 1, length.out = 100)
  
  ComplexHeatmap::Heatmap(
    # SSU_corr_RNA$correlation, cell_fun = function(j, ii, x, y, w, h, fill) {
    # if(SSU_corr_RNA$p_value_adj[ii, j] < 0.001) {
    #     grid.text("***", x, y)
    # } else if(SSU_corr_RNA$p_value_adj[ii, j] < 0.01 & (SSU_corr_RNA$p_value_adj[ii, j] > 0.001)) {
    #     grid.text("**", x, y)
    # } else if(SSU_corr_RNA$p_value_adj[ii, j] < 0.05 & (SSU_corr_RNA$p_value_adj[ii, j] > 0.01)) {
    #     grid.text("*", x, y)
    # }}, 
    
    # SSU_corr_RNA$correlation, cell_fun = function(j, ii, x, y, w, h, fill) {
    # if(SSU_corr_RNA$p_value_adj[ii, j] < 0.001 & SSU_corr_RNA$correlation[ii, j] > 0.3) {
    #     grid.text("***", x, y)
    # } else if(SSU_corr_RNA$p_value_adj[ii, j] < 0.01 & SSU_corr_RNA$p_value_adj[ii, j] > 0.001 & SSU_corr_RNA$correlation[ii, j] > 0.3) {
    #     grid.text("**", x, y)
    # } else if(SSU_corr_RNA$p_value_adj[ii, j] < 0.05 & SSU_corr_RNA$p_value_adj[ii, j] > 0.01 & SSU_corr_RNA$correlation[ii, j] > 0.3) {
    #     grid.text("*", x, y)
    # }},
    
    SSU_corr_RNA$correlation, cell_fun = function(j, ii, x, y, w, h, fill) {
    if (abs(SSU_corr_RNA$correlation[ii, j]) > 0.3) {
        if (SSU_corr_RNA$p_value_adj[ii, j] < 0.001) {
            grid.text("***", x, y)
        } else if (SSU_corr_RNA$p_value_adj[ii, j] < 0.01 & SSU_corr_RNA$p_value_adj[ii, j] > 0.001) {
            grid.text("**", x, y)
        } else if (SSU_corr_RNA$p_value_adj[ii, j] < 0.05 & SSU_corr_RNA$p_value_adj[ii, j] > 0.01) {
            grid.text("*", x, y)
        }
    }},
    
    col = colorRamp2(myBreaks, myCol),
      cluster_rows = FALSE,
      cluster_columns = FALSE, 
      show_row_dend = TRUE,
      show_row_names = FALSE,
      show_heatmap_legend = TRUE, 
    
    name = 'Corr',
    heatmap_legend_param = list(
      color_bar = 'continuous',
      legend_direction = 'vertical',
      legend_width = unit(8, 'cm'),
      legend_height = unit(5.0, 'cm'),
      title_position = 'topcenter',
      title_gp=gpar(col = OutlineColor,fontsize = 12, fontface = 'bold'),
      labels_gp=gpar(col = OutlineColor,fontsize = 12, fontface = 'bold')),

      row_title_side = 'left',
      row_title_gp = gpar(col = OutlineColor,fontsize = 12,  fontface = 'bold'),
      row_title_rot = 90,
      row_names_gp = gpar(col = OutlineColor,fontsize = 12, fontface = 'bold'),
      row_names_side = 'right',
      row_dend_width = unit(25,'mm'),

      column_title = NULL,
      column_title_side = 'bottom',
      column_title_gp = gpar(col = OutlineColor,fontsize = 1, fontface = 'bold'),
      column_title_rot = 0,
      show_column_names = TRUE,
      column_names_gp = gpar(col = OutlineColor,fontsize = 12, fontface = 'bold'),
      column_names_max_height = unit(8, 'cm'),
      column_dend_height = unit(25,'mm'),

      clustering_distance_columns = function(x) as.dist(1 - cor(t(x))),
      clustering_method_columns = 'ward.D2',
      clustering_distance_rows = function(x) as.dist(1 - cor(t(x))),
      clustering_method_rows = 'ward.D2', 
    
    width = unit(length(colnames(SSU_corr_RNA$correlation))*0.5, "cm")) -> SSU_corr_RNA_plot
  
  #####################
  # Cor-Mat RNA-Traits#
  #####################

  SAM_MEs_traits <- SAM_MEs[names(SAM_MEs) %in% traitData]
  SAM_MEs_traits <- SAM_MEs_traits[, traitData]
  p.value_matr <- corr.value_matr <- matrix(ncol = ncol(SAM_MEs_traits), 
                nrow = ncol(RNA_MEs), dimnames = list(colnames(RNA_MEs), 
                colnames(SAM_MEs_traits)))
  
  for(iii in 1:ncol(RNA_MEs)){
    for(jj in 1:ncol(SAM_MEs_traits)){
      if(colnames(SAM_MEs_traits)[jj] == "Day"){
        cor.res <- cor.test(RNA_MEs[,ii], SAM_MEs_traits[,jj], method = "spearman", exact = FALSE)
        p.value_matr[iii, jj] <- cor.res$p.value
        corr.value_matr[iii, jj] <- cor.res$estimate
      } else{
      cor.res <- cor.test(RNA_MEs[,iii], SAM_MEs_traits[,jj])
      p.value_matr[iii, jj] <- cor.res$p.value
      corr.value_matr[iii, jj] <- cor.res$estimate
      }
    }
  }
  
  # Correct for number of tests
  p.value_matr.adjust <- p.adjust(p.value_matr, method = "fdr")
  dim(p.value_matr.adjust) <- dim(p.value_matr)
  dimnames(p.value_matr.adjust) <- list(colnames(RNA_MEs), colnames(SAM_MEs_traits))
  # Collect all results into a list.
  Traits_corr_RNA <- list(p_value = p.value_matr, 
                 p_value_adj = p.value_matr.adjust,
                 correlation = corr.value_matr)
  myCol <- colorRampPalette(c("#18b29f","#FFFFFF", "#ac6721"))(100)
  myBreaks <- seq(-1, 1, length.out = 100)
  
  ComplexHeatmap::Heatmap(
    
  #   Traits_corr_RNA$correlation, cell_fun = function(jjj, iiii, x, y, w, h, fill) {
  #   if(Traits_corr_RNA$p_value_adj[iiii, jjj] < 0.001) {
  #       grid.text("***", x, y)
  #   } else if(Traits_corr_RNA$p_value_adj[iiii, jjj] < 0.01 & (Traits_corr_RNA$p_value_adj[iiii, jjj] > 0.001)) {
  #       grid.text("**", x, y)
  #   } else if(Traits_corr_RNA$p_value_adj[iiii, jjj] < 0.05 & (Traits_corr_RNA$p_value_adj[iiii, jjj] > 0.01)) {
  #       grid.text("*", x, y)
  #   }
  # }, 
  
  Traits_corr_RNA$correlation, cell_fun = function(j, ii, x, y, w, h, fill) {
    if (abs(Traits_corr_RNA$correlation[ii, j]) > 0.3) {
        if (Traits_corr_RNA$p_value_adj[ii, j] < 0.001) {
            grid.text("***", x, y)
        } else if (Traits_corr_RNA$p_value_adj[ii, j] < 0.01 & Traits_corr_RNA$p_value_adj[ii, j] > 0.001) {
            grid.text("**", x, y)
        } else if (Traits_corr_RNA$p_value_adj[ii, j] < 0.05 & Traits_corr_RNA$p_value_adj[ii, j] > 0.01) {
            grid.text("*", x, y)
        }
    }},
  
  
    col = colorRamp2(myBreaks, myCol),
      cluster_rows = FALSE,
      cluster_columns = FALSE,
      show_row_dend = TRUE,
      show_row_names = FALSE,
      show_heatmap_legend = FALSE,
    
    heatmap_legend_param = list(
      color_bar = 'continuous',
      legend_direction = 'vertical',
      legend_width = unit(8, 'cm'),
      legend_height = unit(5.0, 'cm'),
      title_position = 'topcenter',
      title_gp=gpar(col = OutlineColor,fontsize = 12, fontface = 'bold'),
      labels_gp=gpar(col = OutlineColor,fontsize = 12, fontface = 'bold')),

      row_title_side = 'left',
      row_title_gp = gpar(col = OutlineColor,fontsize = 12,  fontface = 'bold'),
      row_title_rot = 90,
      row_names_gp = gpar(col = OutlineColor,fontsize = 12, fontface = 'bold'),
      row_names_side = 'right',
      row_dend_width = unit(25,'mm'),

      column_title = NULL,
      column_title_side = 'bottom',
      column_title_gp = gpar(col = OutlineColor,fontsize = 1, fontface = 'bold'),
      column_title_rot = 0,
      show_column_names = TRUE,
      column_names_gp = gpar(col = OutlineColor,fontsize = 12, fontface = 'bold'),
      column_names_max_height = unit(8, 'cm'),
      column_dend_height = unit(25,'mm'),

      clustering_distance_columns = function(x) as.dist(1 - cor(t(x))),
      clustering_method_columns = 'ward.D2',
      clustering_distance_rows = function(x) as.dist(1 - cor(t(x))),
      clustering_method_rows = 'ward.D2', 
  
      width = unit(  length(colnames(Traits_corr_RNA$correlation))*0.5, "cm")) -> Traits_corr_RNA_plot

    ######################
    # Integreated Heatmap#
    ######################
    #print("Integreated Heatmap")
    ht_list = Traits_corr_RNA_plot + RNA_hmap +  SSU_corr_RNA_plot
    prow <- cowplot::plot_grid(grid.grabExpr(ComplexHeatmap::draw(ht_list, auto_adjust = FALSE, 
                    background = "transparent",
                   heatmap_legend_side = "left", annotation_legend_side = "bottom")))
    title <- ggdraw() 
    subtitle <- ggdraw() + draw_label_themeRKwhite(paste("Heatmap MEs", sep = " "), 
              element = "plot.subtitle",x = 0.05, hjust = 0, vjust = 1)
    b <- plot_grid(title, subtitle, prow, ncol = 1, rel_heights = c(0.04, 0.05, 0.98)) 
    #Safe the plots in a specified folder <- may have to change the width and height
    ggsave(prow, filename = FILENAME, path = pathPlots , device='png', dpi=300, width = WIDTH,
    height = HEIGHT)
  
    ht_list <<- ht_list
  
    }, error=function(e){cat("ERROR :",conditionMessage(e), "\n")})
  }
```


### 5.3 SSU 

#### 5.3.1 WGCNA_IntegratedHeatmap_RK

```{r}
WGCNA_IntegratedHeatmap_RK <- function (
  SAM_MEs = SAM_MEs,
  SSU_MEs = SSU_MEs,
  RNA_MEs = RNA_MEs,
  WIDTH = WIDTH,
  HEIGHT = HEIGHT,
  OutlineColor = OutlineColor,
  traitData = traitData) {
  tryCatch({
  ########################
  #Transcriptomes Heatmap#
  ########################
  require(RColorBrewer)
  require(ComplexHeatmap)
  require(Cairo)
  require(circlize)
  require(digest)
  require(cluster)
  require(ComplexHeatmap)
  require(grid)
  require(DESeq2)
  require(tidyverse)
  require(ggplot2)
  require(cowplot)
    
  #print("Transcriptomes Heatmap")
  columnclusternum <- 1
  rowclusternum    <- 1
  heat       <- t(as.matrix(scale(RNA_MEs, center = TRUE, scale = TRUE)))
  metadata   <- SAM_MEs[rownames(SAM_MEs) %in% colnames(heat),]
  metadata   <- metadata[order(match(rownames(metadata), colnames(heat))), , drop = FALSE]
  #create top-annotation

  annLoc        <- data.frame(Location = metadata$fLOC)#,stringsAsFactors = FALSE)
  annSeason    <- data.frame(Season   = metadata$fSeason)
  anno_df = data.frame(Location = annLoc,Season = annSeason)
  
  COL.LOC <- col.Palette$col.Palette.LOC[names(col.Palette$col.Palette.LOC) %in% metadata$fLOC]
  COL.Season <- col.Palette$col.Palette.Season[names(col.Palette$col.Palette.Season) %in% metadata$fSeason]
  
  colAnn <-HeatmapAnnotation(
    show_legend = c(FALSE, FALSE, FALSE),
    show_annotation_name = FALSE, 
    annotation_name_side = "left",
    df =   anno_df,
    title = NULL,
    which = 'col', # 'col' (samples) or 'row' (gene) annotation?
    na_col = 'white', # default colour for any NA values in the annotation data-frame, 'ann'
    col = list(Location = COL.LOC , Season = COL.Season), 
    annotation_height = 0.4,
    annotation_width = unit(0.5, 'cm'),
    gap = unit(1, 'mm'),
    annotation_legend_param = list(
      Location = list(
        nrow = 1, # number of rows across which the legend will be arranged
        title = "Location", #
        title_position = 'topcenter',
        legend_direction = 'vertical',
        title_gp = gpar(col = OutlineColor,fontsize = 12, fontface = 'bold'),
        labels_gp = gpar(col = OutlineColor,fontsize = 12, fontface = 'bold')),
      Season = list(
        nrow = 1, # number of rows across which the legend will be arranged
        title = "Season", #
        title_position = 'topcenter',
        legend_direction = 'vertical',
        title_gp = gpar(col = OutlineColor,fontsize = 12, fontface = 'bold'),
        labels_gp = gpar(col = OutlineColor,fontsize = 12, fontface = 'bold'))))
    
    #label every 40th gene
    labelseqs <-if (dim(heat)[1] <= 100) { 
    labelseqs <- 1
    } else if (dim(heat)[1] <= 1000) {
    labelseqs<- 2
    } else {
    labelseqs<- 300}
  genelabels <- ComplexHeatmap::rowAnnotation(
    Genes = anno_mark(
      at = seq(1, nrow(heat), labelseqs),                         #Adjust the amount of lables
      labels = rownames(heat)[seq(1, nrow(heat), labelseqs)],
      labels_gp = gpar(col = OutlineColor,fontsize = 12, fontface = 'bold'),
      padding = 0.75),
      width = unit(1.0, 'cm') +
      ComplexHeatmap::max_text_width(
        rownames(heat)[seq(1, nrow(heat), 30)],
        gp = gpar(col = OutlineColor,fontsize = 12,  fontface = 'bold')))
  #myCol <- colorRampPalette(c('blue', 'white', 'red'))(100)
  myCol <- colorRampPalette(c("#18b29f","#FFFFFF", "#ac6721"))(100)
  #myBreaks <- seq(-3, 3, length.out = 100)
  myBreaks <- seq(-2.5, 2.5, length.out = 100)
  #create heatmap

  #Insert the Module Abundance as row-Annotation
  ASVsums <- ASVsums[match(rownames(heat), ASVsums$Module), ]
  row_ha = ComplexHeatmap::rowAnnotation(o.Abund = anno_barplot(ASVsums$ASVsum))

  Heatmap(heat, #raster_device ="png",
    # split the genes / rows according to the PAM clusters
      #split = pamClusters$clustering,
      column_km = columnclusternum,
      cluster_row_slices = FALSE,
      name = 'Z-\nscore',
    col = colorRamp2(myBreaks, myCol),
    # parameters for the colour-bar that represents gradient of expression
      heatmap_legend_param = list(
        color_bar = 'continuous',
        legend_direction = 'vertical',
        legend_width = unit(8, 'cm'),
        legend_height = unit(5.0, 'cm'),
        title_position = 'topcenter',
        title_gp=gpar(col = OutlineColor,fontsize = 12, fontface = 'bold'),
        labels_gp=gpar(col = OutlineColor,fontsize = 12, fontface = 'bold')),
    
    # row (gene) parameters
      cluster_rows = FALSE,
      show_row_dend = TRUE,

      row_title_side = 'left',
      row_title_gp = gpar(col = OutlineColor,fontsize = 12,  fontface = 'bold'),
      row_title_rot = 90,
      show_row_names = TRUE,
      row_names_gp = gpar(col = OutlineColor,fontsize = 12, fontface = 'bold'),
      row_names_side = 'right',
      row_dend_width = unit(25,'mm'),

      cluster_columns = FALSE, 
      show_column_dend = FALSE,
    
      column_title = NULL,
      column_title_side = 'bottom',
      column_title_gp = gpar(col = OutlineColor,fontsize = 1, fontface = 'bold'),
      column_title_rot = 0,
      show_column_names = FALSE,
      column_names_gp = gpar(col = OutlineColor,fontsize = 12, fontface = 'bold'),
      column_names_max_height = unit(12, 'cm'),
      column_dend_height = unit(25,'mm'),

      clustering_distance_columns = function(x) as.dist(1 - cor(t(x))),
      clustering_method_columns = 'ward.D2',
      clustering_distance_rows = function(x) as.dist(1 - cor(t(x))),
      clustering_method_rows = 'ward.D2',
  
      # specify top and bottom annotations
      top_annotation = colAnn, 
      show_heatmap_legend = TRUE, 
  
      width = unit(length(colnames(heat))*0.11, "cm"), 
    
    left_annotation = row_ha) -> RNA_hmap
      #bottom_annotation = boxplotCol) 

  #################
  #Cor-Mat RNA-SSU#
  #################
  #print("Cor-Mat RNA-SSU")
  p.value_matr <- corr.value_matr <- matrix(ncol = ncol(SSU_MEs), nrow = ncol(RNA_MEs), 
                                          dimnames = list(colnames(RNA_MEs), colnames(SSU_MEs)))
  for(ii in 1:ncol(RNA_MEs)){
    for(j in 1:ncol(SSU_MEs)){
      cor.res <- cor.test(RNA_MEs[,ii], SSU_MEs[,j])
      p.value_matr[ii, j] <- cor.res$p.value
      corr.value_matr[ii, j] <- cor.res$estimate
      }
    }
  
  # Correct for number of tests
  p.value_matr.adjust <- p.adjust(p.value_matr, method = "fdr")
  dim(p.value_matr.adjust) <- dim(p.value_matr)
  dimnames(p.value_matr.adjust) <- list(colnames(RNA_MEs), colnames(SSU_MEs))

  # Collect all results into a list.
  SSU_corr_RNA <- list(p_value = p.value_matr, 
                 p_value_adj = p.value_matr.adjust,
                 correlation = corr.value_matr)
  
  myCol <- colorRampPalette(c("#18b29f","#FFFFFF", "#ac6721"))(100)
  myBreaks <- seq(-1, 1, length.out = 100)
  
  ComplexHeatmap::Heatmap(
    # SSU_corr_RNA$correlation, cell_fun = function(j, ii, x, y, w, h, fill) {
    # if(SSU_corr_RNA$p_value_adj[ii, j] < 0.001) {
    #     grid.text("***", x, y)
    # } else if(SSU_corr_RNA$p_value_adj[ii, j] < 0.01 & (SSU_corr_RNA$p_value_adj[ii, j] > 0.001)) {
    #     grid.text("**", x, y)
    # } else if(SSU_corr_RNA$p_value_adj[ii, j] < 0.05 & (SSU_corr_RNA$p_value_adj[ii, j] > 0.01)) {
    #     grid.text("*", x, y)
    # }}, 
    
    # SSU_corr_RNA$correlation, cell_fun = function(j, ii, x, y, w, h, fill) {
    # if(SSU_corr_RNA$p_value_adj[ii, j] < 0.001 & SSU_corr_RNA$correlation[ii, j] > 0.3) {
    #     grid.text("***", x, y)
    # } else if(SSU_corr_RNA$p_value_adj[ii, j] < 0.01 & SSU_corr_RNA$p_value_adj[ii, j] > 0.001 & SSU_corr_RNA$correlation[ii, j] > 0.3) {
    #     grid.text("**", x, y)
    # } else if(SSU_corr_RNA$p_value_adj[ii, j] < 0.05 & SSU_corr_RNA$p_value_adj[ii, j] > 0.01 & SSU_corr_RNA$correlation[ii, j] > 0.3) {
    #     grid.text("*", x, y)
    # }},
    
    SSU_corr_RNA$correlation, cell_fun = function(j, ii, x, y, w, h, fill) {
    if (abs(SSU_corr_RNA$correlation[ii, j]) > 0.5) {
        if (SSU_corr_RNA$p_value_adj[ii, j] < 0.001) {
            grid.text("***", x, y)
        } else if (SSU_corr_RNA$p_value_adj[ii, j] < 0.01 & SSU_corr_RNA$p_value_adj[ii, j] > 0.001) {
            grid.text("**", x, y)
        } else if (SSU_corr_RNA$p_value_adj[ii, j] < 0.05 & SSU_corr_RNA$p_value_adj[ii, j] > 0.01) {
            grid.text("*", x, y)
        }
    }},
    
    col = colorRamp2(myBreaks, myCol),
      cluster_rows = FALSE,
      cluster_columns = FALSE, 
      show_row_dend = TRUE,
      show_row_names = FALSE,
      show_heatmap_legend = TRUE, 
    
    name = 'Corr',
    heatmap_legend_param = list(
      color_bar = 'continuous',
      legend_direction = 'vertical',
      legend_width = unit(8, 'cm'),
      legend_height = unit(5.0, 'cm'),
      title_position = 'topcenter',
      title_gp=gpar(col = OutlineColor,fontsize = 12, fontface = 'bold'),
      labels_gp=gpar(col = OutlineColor,fontsize = 12, fontface = 'bold')),

      row_title_side = 'left',
      row_title_gp = gpar(col = OutlineColor,fontsize = 12,  fontface = 'bold'),
      row_title_rot = 90,
      row_names_gp = gpar(col = OutlineColor,fontsize = 12, fontface = 'bold'),
      row_names_side = 'right',
      row_dend_width = unit(25,'mm'),

      column_title = NULL,
      column_title_side = 'bottom',
      column_title_gp = gpar(col = OutlineColor,fontsize = 1, fontface = 'bold'),
      column_title_rot = 0,
      show_column_names = TRUE,
      column_names_gp = gpar(col = OutlineColor,fontsize = 12, fontface = 'bold'),
      column_names_max_height = unit(8, 'cm'),
      column_dend_height = unit(25,'mm'),

      clustering_distance_columns = function(x) as.dist(1 - cor(t(x))),
      clustering_method_columns = 'ward.D2',
      clustering_distance_rows = function(x) as.dist(1 - cor(t(x))),
      clustering_method_rows = 'ward.D2', 
    
    width = unit(length(colnames(SSU_corr_RNA$correlation))*0.5, "cm")) -> SSU_corr_RNA_plot
  
  #####################
  # Cor-Mat RNA-Traits#
  #####################

  SAM_MEs_traits <- SAM_MEs[names(SAM_MEs) %in% traitData]
  SAM_MEs_traits <- SAM_MEs_traits[, traitData]
  p.value_matr <- corr.value_matr <- matrix(ncol = ncol(SAM_MEs_traits), 
                nrow = ncol(RNA_MEs), dimnames = list(colnames(RNA_MEs), 
                colnames(SAM_MEs_traits)))
  
  for(iii in 1:ncol(RNA_MEs)){
    for(jj in 1:ncol(SAM_MEs_traits)){
      if(colnames(SAM_MEs_traits)[jj] == "Day"){
        cor.res <- cor.test(RNA_MEs[,ii], SAM_MEs_traits[,jj], method = "spearman", exact = FALSE)
        p.value_matr[iii, jj] <- cor.res$p.value
        corr.value_matr[iii, jj] <- cor.res$estimate
      } else{
      cor.res <- cor.test(RNA_MEs[,iii], SAM_MEs_traits[,jj])
      p.value_matr[iii, jj] <- cor.res$p.value
      corr.value_matr[iii, jj] <- cor.res$estimate
      }
    }
  }
  
  
  # Correct for number of tests
  p.value_matr.adjust <- p.adjust(p.value_matr, method = "fdr")
  dim(p.value_matr.adjust) <- dim(p.value_matr)
  dimnames(p.value_matr.adjust) <- list(colnames(RNA_MEs), colnames(SAM_MEs_traits))
  # Collect all results into a list.
  Traits_corr_RNA <- list(p_value = p.value_matr, 
                 p_value_adj = p.value_matr.adjust,
                 correlation = corr.value_matr)
  myCol <- colorRampPalette(c("#18b29f","#FFFFFF", "#ac6721"))(100)
  myBreaks <- seq(-1, 1, length.out = 100)
  
  ComplexHeatmap::Heatmap(
    
  #   Traits_corr_RNA$correlation, cell_fun = function(jjj, iiii, x, y, w, h, fill) {
  #   if(Traits_corr_RNA$p_value_adj[iiii, jjj] < 0.001) {
  #       grid.text("***", x, y)
  #   } else if(Traits_corr_RNA$p_value_adj[iiii, jjj] < 0.01 & (Traits_corr_RNA$p_value_adj[iiii, jjj] > 0.001)) {
  #       grid.text("**", x, y)
  #   } else if(Traits_corr_RNA$p_value_adj[iiii, jjj] < 0.05 & (Traits_corr_RNA$p_value_adj[iiii, jjj] > 0.01)) {
  #       grid.text("*", x, y)
  #   }
  # }, 
  
  Traits_corr_RNA$correlation, cell_fun = function(j, ii, x, y, w, h, fill) {
    if (abs(Traits_corr_RNA$correlation[ii, j]) > 0.3) {
        if (Traits_corr_RNA$p_value_adj[ii, j] < 0.001) {
            grid.text("***", x, y)
        } else if (Traits_corr_RNA$p_value_adj[ii, j] < 0.01 & Traits_corr_RNA$p_value_adj[ii, j] > 0.001) {
            grid.text("**", x, y)
        } else if (Traits_corr_RNA$p_value_adj[ii, j] < 0.05 & Traits_corr_RNA$p_value_adj[ii, j] > 0.01) {
            grid.text("*", x, y)
        }
    }},
  
  
    col = colorRamp2(myBreaks, myCol),
      cluster_rows = FALSE,
      cluster_columns = FALSE,
      show_row_dend = TRUE,
      show_row_names = FALSE,
      show_heatmap_legend = FALSE,
    
    heatmap_legend_param = list(
      color_bar = 'continuous',
      legend_direction = 'vertical',
      legend_width = unit(8, 'cm'),
      legend_height = unit(5.0, 'cm'),
      title_position = 'topcenter',
      title_gp=gpar(col = OutlineColor,fontsize = 12, fontface = 'bold'),
      labels_gp=gpar(col = OutlineColor,fontsize = 12, fontface = 'bold')),

      row_title_side = 'left',
      row_title_gp = gpar(col = OutlineColor,fontsize = 12,  fontface = 'bold'),
      row_title_rot = 90,
      row_names_gp = gpar(col = OutlineColor,fontsize = 12, fontface = 'bold'),
      row_names_side = 'right',
      row_dend_width = unit(25,'mm'),

      column_title = NULL,
      column_title_side = 'bottom',
      column_title_gp = gpar(col = OutlineColor,fontsize = 1, fontface = 'bold'),
      column_title_rot = 0,
      show_column_names = TRUE,
      column_names_gp = gpar(col = OutlineColor,fontsize = 12, fontface = 'bold'),
      column_names_max_height = unit(8, 'cm'),
      column_dend_height = unit(25,'mm'),

      clustering_distance_columns = function(x) as.dist(1 - cor(t(x))),
      clustering_method_columns = 'ward.D2',
      clustering_distance_rows = function(x) as.dist(1 - cor(t(x))),
      clustering_method_rows = 'ward.D2', 
  
      width = unit(  length(colnames(Traits_corr_RNA$correlation))*0.5, "cm")) -> Traits_corr_RNA_plot

    ######################
    # Integreated Heatmap#
    ######################
    #print("Integreated Heatmap")
    ht_list = Traits_corr_RNA_plot + RNA_hmap +  SSU_corr_RNA_plot
    prow <- cowplot::plot_grid(grid.grabExpr(ComplexHeatmap::draw(ht_list, auto_adjust = FALSE, 
                    background = "transparent",
                   heatmap_legend_side = "left", annotation_legend_side = "bottom")))
    title <- ggdraw() 
    subtitle <- ggdraw() + draw_label_themeRKwhite(paste("Heatmap MEs", sep = " "), 
              element = "plot.subtitle",x = 0.05, hjust = 0, vjust = 1)
    b <- plot_grid(title, subtitle, prow, ncol = 1, rel_heights = c(0.04, 0.05, 0.98)) 
    #Safe the plots in a specified folder <- may have to change the width and height
    ggsave(prow, filename = FILENAME, path = pathPlots , device='png', dpi=300, width = WIDTH,
    height = HEIGHT)
  
    ht_list <<- ht_list
  
    }, error=function(e){cat("ERROR :",conditionMessage(e), "\n")})
  }
```


#### 5.4.2 Bakterioplankton

```{r,  message=FALSE,warning=FALSE}
WGCNA_IntegratedHeatmap_Bakterioplankton_RK <- function (
  SAM_MEs = SAM_MEs,
  RNA_MEs = RNA_MEs,
  WIDTH = WIDTH,
  HEIGHT = HEIGHT,
  OutlineColor = OutlineColor,
  traitData = traitData) {
  tryCatch({
  ########################
  #Transcriptomes Heatmap#
  ########################
  require(RColorBrewer)
  require(ComplexHeatmap)
  require(Cairo)
  require(circlize)
  require(digest)
  require(cluster)
  require(ComplexHeatmap)
  require(grid)
  require(DESeq2)
  require(tidyverse)
  require(ggplot2)
  require(cowplot)
  #print("Transcriptomes Heatmap")
  columnclusternum <- 1
  rowclusternum    <- 1
  heat       <- t(as.matrix(scale(RNA_MEs, center = TRUE, scale = TRUE)))
  metadata   <- SAM_MEs[rownames(SAM_MEs) %in% colnames(heat),]
  metadata   <- metadata[order(match(rownames(metadata), colnames(heat))), , drop = FALSE]
  #create top-annotation

  annLoc        <- data.frame(Location = metadata$fLOC)#,stringsAsFactors = FALSE)
  annSeason    <- data.frame(Season   = metadata$fSeason)
  anno_df = data.frame(Location = annLoc,Season = annSeason)
  
  COL.LOC <- col.Palette$col.Palette.LOC[names(col.Palette$col.Palette.LOC) %in% metadata$fLOC]
  COL.Season <- col.Palette$col.Palette.Season[names(col.Palette$col.Palette.Season) %in% metadata$fSeason]
  
  colAnn <-HeatmapAnnotation(
    show_legend = c(FALSE, FALSE, FALSE),
    show_annotation_name = FALSE, 
    annotation_name_side = "left",
    df =   anno_df,
    title = NULL,
    which = 'col', # 'col' (samples) or 'row' (gene) annotation?
    na_col = 'white', # default colour for any NA values in the annotation data-frame, 'ann'
    col = list(Location = COL.LOC , Season = COL.Season), 
    annotation_height = 0.4,
    annotation_width = unit(0.5, 'cm'),
    gap = unit(1, 'mm'),
    annotation_legend_param = list(
      Location = list(
        nrow = 1, # number of rows across which the legend will be arranged
        title = "Location", #
        title_position = 'topcenter',
        legend_direction = 'vertical',
        title_gp = gpar(col = OutlineColor,fontsize = 7, fontface = 'bold'),
        labels_gp = gpar(col = OutlineColor,fontsize = 7, fontface = 'bold')),
      Season = list(
        nrow = 1, # number of rows across which the legend will be arranged
        title = "Season", #
        title_position = 'topcenter',
        legend_direction = 'vertical',
        title_gp = gpar(col = OutlineColor,fontsize = 7, fontface = 'bold'),
        labels_gp = gpar(col = OutlineColor,fontsize = 7, fontface = 'bold'))))
    
    #label every 40th gene
    labelseqs <-if (dim(heat)[1] <= 100) { 
    labelseqs <- 1
    } else if (dim(heat)[1] <= 1000) {
    labelseqs<- 2
    } else {
    labelseqs<- 300}
  genelabels <- ComplexHeatmap::rowAnnotation(
    Genes = anno_mark(
      at = seq(1, nrow(heat), labelseqs),                         #Adjust the amount of lables
      labels = rownames(heat)[seq(1, nrow(heat), labelseqs)],
      labels_gp = gpar(col = OutlineColor,fontsize = 6, fontface = 'bold'),
      padding = 0.75),
      width = unit(1.0, 'cm') +
      ComplexHeatmap::max_text_width(
        rownames(heat)[seq(1, nrow(heat), 30)],
        gp = gpar(col = OutlineColor,fontsize = 6,  fontface = 'bold')))
  #myCol <- colorRampPalette(c('blue', 'white', 'red'))(100)
  myCol <- colorRampPalette(c("#18b29f","#FFFFFF", "#ac6721"))(100)
  #myBreaks <- seq(-3, 3, length.out = 100)
  myBreaks <- seq(-2.5, 2.5, length.out = 100)
  
  #Insert the Module Abundance as row-Annotation
  ASVsums <- ASVsums[match(rownames(heat), ASVsums$Module), ]
  row_ha = ComplexHeatmap::rowAnnotation(o.Abund = anno_barplot(ASVsums$ASVsum))
  
  #create heatmap
  Heatmap(heat, #raster_device ="png",
    # split the genes / rows according to the PAM clusters
      #split = pamClusters$clustering,
      column_km = columnclusternum,
      cluster_row_slices = FALSE,
      name = 'Z-\nscore',
    col = colorRamp2(myBreaks, myCol),
    # parameters for the colour-bar that represents gradient of expression
      heatmap_legend_param = list(
        color_bar = 'continuous',
        legend_direction = 'vertical',
        legend_width = unit(8, 'cm'),
        legend_height = unit(5.0, 'cm'),
        title_position = 'topcenter',
        title_gp=gpar(col = OutlineColor,fontsize = 8, fontface = 'bold'),
        labels_gp=gpar(col = OutlineColor,fontsize = 8, fontface = 'bold')),
    
    # row (gene) parameters
      cluster_rows = FALSE,
      show_row_dend = TRUE,

      row_title_side = 'left',
      row_title_gp = gpar(col = OutlineColor,fontsize = 8,  fontface = 'bold'),
      row_title_rot = 90,
      show_row_names = TRUE,
      row_names_gp = gpar(col = OutlineColor,fontsize = 8, fontface = 'bold'),
      row_names_side = 'right',
      row_dend_width = unit(25,'mm'),

      cluster_columns = FALSE, 
      show_column_dend = FALSE,
    
      column_title = NULL,
      column_title_side = 'bottom',
      column_title_gp = gpar(col = OutlineColor,fontsize = 1, fontface = 'bold'),
      column_title_rot = 0,
      show_column_names = FALSE,
      column_names_gp = gpar(col = OutlineColor,fontsize = 8, fontface = 'bold'),
      column_names_max_height = unit(8, 'cm'),
      column_dend_height = unit(25,'mm'),

      clustering_distance_columns = function(x) as.dist(1 - cor(t(x))),
      clustering_method_columns = 'ward.D2',
      clustering_distance_rows = function(x) as.dist(1 - cor(t(x))),
      clustering_method_rows = 'ward.D2',
  
      # specify top and bottom annotations
      top_annotation = colAnn, 
      show_heatmap_legend = TRUE, 
  
      width = unit(5.5+length(colnames(heat))*0.11, "cm"), 
      left_annotation = row_ha) -> RNA_hmap
      #bottom_annotation = boxplotCol) 

  #####################
  # Cor-Mat RNA-Traits#
  #####################

  SAM_MEs_traits <- SAM_MEs[names(SAM_MEs) %in% traitData]
  SAM_MEs_traits <- SAM_MEs_traits[, traitData]
  p.value_matr <- corr.value_matr <- matrix(ncol = ncol(SAM_MEs_traits), 
                nrow = ncol(RNA_MEs), dimnames = list(colnames(RNA_MEs), 
                colnames(SAM_MEs_traits)))
  
  for(iii in 1:ncol(RNA_MEs)){
    for(jj in 1:ncol(SAM_MEs_traits)){
      if(colnames(SAM_MEs_traits)[jj] == "Day"){
        cor.res <- cor.test(RNA_MEs[,ii], SAM_MEs_traits[,jj], method = "spearman", exact = FALSE)
        p.value_matr[iii, jj] <- cor.res$p.value
        corr.value_matr[iii, jj] <- cor.res$estimate
      } else{
      cor.res <- cor.test(RNA_MEs[,iii], SAM_MEs_traits[,jj])
      p.value_matr[iii, jj] <- cor.res$p.value
      corr.value_matr[iii, jj] <- cor.res$estimate
      }
    }
  }
  
  # Correct for number of tests
  p.value_matr.adjust <- p.adjust(p.value_matr, method = "fdr")
  dim(p.value_matr.adjust) <- dim(p.value_matr)
  dimnames(p.value_matr.adjust) <- list(colnames(RNA_MEs), colnames(SAM_MEs_traits))
  # Collect all results into a list.
  Traits_corr_RNA <- list(p_value = p.value_matr, 
                 p_value_adj = p.value_matr.adjust,
                 correlation = corr.value_matr)
  myCol <- colorRampPalette(c("#18b29f","#FFFFFF", "#ac6721"))(100)
  myBreaks <- seq(-1, 1, length.out = 100)
  
  ComplexHeatmap::Heatmap(
     Traits_corr_RNA$correlation, cell_fun = function(j, ii, x, y, w, h, fill) {
    if (abs(Traits_corr_RNA$correlation[ii, j]) > 0.3) {
        if (Traits_corr_RNA$p_value_adj[ii, j] < 0.001) {
            grid.text("***", x, y)
        } else if (Traits_corr_RNA$p_value_adj[ii, j] < 0.01 & Traits_corr_RNA$p_value_adj[ii, j] > 0.001) {
            grid.text("**", x, y)
        } else if (Traits_corr_RNA$p_value_adj[ii, j] < 0.05 & Traits_corr_RNA$p_value_adj[ii, j] > 0.01) {
            grid.text("*", x, y)
        }
    }},
    col = colorRamp2(myBreaks, myCol),
      cluster_rows = FALSE,
      cluster_columns = FALSE,
      show_row_dend = TRUE,
      show_row_names = FALSE,
      show_heatmap_legend = FALSE,
    
    heatmap_legend_param = list(
      color_bar = 'continuous',
      legend_direction = 'vertical',
      legend_width = unit(8, 'cm'),
      legend_height = unit(5.0, 'cm'),
      title_position = 'topcenter',
      title_gp=gpar(col = OutlineColor,fontsize = 8, fontface = 'bold'),
      labels_gp=gpar(col = OutlineColor,fontsize = 8, fontface = 'bold')),

      row_title_side = 'left',
      row_title_gp = gpar(col = OutlineColor,fontsize = 8,  fontface = 'bold'),
      row_title_rot = 90,
      row_names_gp = gpar(col = OutlineColor,fontsize = 8, fontface = 'bold'),
      row_names_side = 'right',
      row_dend_width = unit(25,'mm'),

      column_title = NULL,
      column_title_side = 'bottom',
      column_title_gp = gpar(col = OutlineColor,fontsize = 1, fontface = 'bold'),
      column_title_rot = 0,
      show_column_names = TRUE,
      column_names_gp = gpar(col = OutlineColor,fontsize = 8, fontface = 'bold'),
      column_names_max_height = unit(8, 'cm'),
      column_dend_height = unit(25,'mm'),

      clustering_distance_columns = function(x) as.dist(1 - cor(t(x))),
      clustering_method_columns = 'ward.D2',
      clustering_distance_rows = function(x) as.dist(1 - cor(t(x))),
      clustering_method_rows = 'ward.D2', 
  
      width = unit(  length(colnames(Traits_corr_RNA$correlation))*0.5, "cm")) -> Traits_corr_RNA_plot


  
    ######################
    # Integreated Heatmap#
    ######################
    #print("Integreated Heatmap")
    ht_list = Traits_corr_RNA_plot + RNA_hmap 
    prow <- cowplot::plot_grid(grid.grabExpr(ComplexHeatmap::draw(ht_list, auto_adjust = FALSE, 
                    background = "transparent",
                   heatmap_legend_side = "left", annotation_legend_side = "bottom")))
    title <- ggdraw() 
    subtitle <- ggdraw() + draw_label_themeRKwhite(paste("Heatmap MEs", sep = " "), 
              element = "plot.subtitle",x = 0.05, hjust = 0, vjust = 1)
    b <- plot_grid(title, subtitle, prow, ncol = 1, rel_heights = c(0.04, 0.05, 0.98)) 
    #Safe the plots in a specified folder <- may have to change the width and height
    ggsave(prow, filename = FILENAME, path = pathPlots , device='png', dpi=300, width = WIDTH,
    height = HEIGHT)
  
    ht_list <<- ht_list
  
    }, error=function(e){cat("ERROR :",conditionMessage(e), "\n")})
  }
```


### 5.4 WGCNA_NormalHeatmap

```{r,  message=FALSE,warning=FALSE}
WGCNA_NormalHeatmap_RK <- function (
  SAM_MEs = SAM_MEs,
  SSU_MEs = SSU_MEs,
  WIDTH = WIDTH,
  HEIGHT = HEIGHT,
  traitData = traitData) {
  tryCatch({
  ########################
  #Transcriptomes Heatmap#
  ########################
  require(RColorBrewer)
  require(ComplexHeatmap)
  require(Cairo)
  require(circlize)
  require(digest)
  require(cluster)
  require(ComplexHeatmap)
  require(grid)
  require(DESeq2)
  require(tidyverse)
  require(ggplot2)
  require(cowplot)
  #print("Transcriptomes Heatmap")
  columnclusternum <- 1
  rowclusternum    <- 1
  heat       <- t(as.matrix(scale(SSU_MEs, center = TRUE, scale = TRUE)))
  metadata   <- SAM_MEs[rownames(SAM_MEs) %in% colnames(heat),]
  metadata   <- metadata[order(match(rownames(metadata), colnames(heat))), , drop = FALSE]
  #create top-annotation

  annLOC        <- data.frame(Location = metadata$fLOC) #,stringsAsFactors = FALSE)
  annSeason     <- data.frame(Season   = metadata$fSeason)
  anno_df = data.frame(Location = annLOC, Season = annSeason)
  
  COL.LOC <- col.Palette$col.Palette.LOC[names(col.Palette$col.Palette.LOC) %in% metadata$fLOC]
  COL.Season <- col.Palette$col.Palette.Season[names(col.Palette$col.Palette.Season) %in% metadata$fSeason]
  
  
  colAnn <-HeatmapAnnotation(
    show_legend = c(FALSE, FALSE, FALSE),
    show_annotation_name = FALSE, 
    annotation_name_side = "left",
    df =   anno_df,
    title = NULL,
    which = 'col', # 'col' (samples) or 'row' (gene) annotation?
    na_col = 'white', # default colour for any NA values in the annotation data-frame, 'ann'
    col = list(Location = COL.LOC, Season = COL.Season), 
    annotation_height = 0.4,
    annotation_width = unit(0.5, 'cm'),
    gap = unit(1, 'mm'),
    annotation_legend_param = list(
      Location = list(
        nrow = 1, # number of rows across which the legend will be arranged
        title = "Location", #
        title_position = 'topcenter',
        legend_direction = 'vertical',
        title_gp = gpar(col = OutlineColor,fontsize = 7, fontface = 'bold'),
        labels_gp = gpar(col = OutlineColor,fontsize = 7, fontface = 'bold')),
      Season = list(
        nrow = 1, # number of rows across which the legend will be arranged
        title = "Season", #
        title_position = 'topcenter',
        legend_direction = 'vertical',
        title_gp = gpar(col = OutlineColor,fontsize = 7, fontface = 'bold'),
        labels_gp = gpar(col = OutlineColor,fontsize = 7, fontface = 'bold'))))
    
    #label every 40th gene
    labelseqs <-if (dim(heat)[1] <= 100) { 
    labelseqs <- 1
    } else if (dim(heat)[1] <= 1000) {
    labelseqs<- 2
    } else {
    labelseqs<- 300}
  genelabels <- ComplexHeatmap::rowAnnotation(
    Genes = anno_mark(
      at = seq(1, nrow(heat), labelseqs),                         #Adjust the amount of lables
      labels = rownames(heat)[seq(1, nrow(heat), labelseqs)],
      labels_gp = gpar(col = OutlineColor,fontsize = 6, fontface = 'bold'),
      padding = 0.75),
      width = unit(1.0, 'cm') +
      ComplexHeatmap::max_text_width(
        rownames(heat)[seq(1, nrow(heat), 30)],
        gp = gpar(col = OutlineColor,fontsize = 6,  fontface = 'bold')))
  #myCol <- colorRampPalette(c('blue', 'white', 'red'))(100)
  myCol <- colorRampPalette(c("#18b29f","#FFFFFF", "#ac6721"))(100)
  #myBreaks <- seq(-3, 3, length.out = 100)
  myBreaks <- seq(-2.5, 2.5, length.out = 100)
  #create heatmap
    Heatmap(heat, #raster_device ="png",
    # split the genes / rows according to the PAM clusters
      #split = pamClusters$clustering,
      column_km = columnclusternum,
      cluster_row_slices = FALSE,
      name = 'Z-\nscore',
    col = colorRamp2(myBreaks, myCol),
    # parameters for the colour-bar that represents gradient of expression
      heatmap_legend_param = list(
        color_bar = 'continuous',
        legend_direction = 'vertical',
        legend_width = unit(8, 'cm'),
        legend_height = unit(5.0, 'cm'),
        title_position = 'topcenter',
        title_gp=gpar(col = OutlineColor,fontsize = 8, fontface = 'bold'),
        labels_gp=gpar(col = OutlineColor,fontsize = 8, fontface = 'bold')),
    
    # row (gene) parameters
      cluster_rows = FALSE,
      show_row_dend = TRUE,

      row_title_side = 'left',
      row_title_gp = gpar(col = OutlineColor,fontsize = 8,  fontface = 'bold'),
      row_title_rot = 90,
      show_row_names = TRUE,
      row_names_gp = gpar(col = OutlineColor,fontsize = 8, fontface = 'bold'),
      row_names_side = 'right',
      row_dend_width = unit(25,'mm'),

      cluster_columns = FALSE, 
      show_column_dend = FALSE,
    
      column_title = NULL,
      column_title_side = 'bottom',
      column_title_gp = gpar(col = OutlineColor,fontsize = 1, fontface = 'bold'),
      column_title_rot = 0,
      show_column_names = TRUE,
      column_names_gp = gpar(col = OutlineColor,fontsize = 8, fontface = 'bold'),
      column_names_max_height = unit(8, 'cm'),
      column_dend_height = unit(25,'mm'),

      clustering_distance_columns = function(x) as.dist(1 - cor(t(x))),
      clustering_method_columns = 'ward.D2',
      clustering_distance_rows = function(x) as.dist(1 - cor(t(x))),
      clustering_method_rows = 'ward.D2',
  
      # specify top and bottom annotations
      top_annotation = colAnn, 
      show_heatmap_legend = TRUE) -> Normal_hmap
      #bottom_annotation = boxplotCol) 

  prow <- cowplot::plot_grid(grid.grabExpr(ComplexHeatmap::draw(Normal_hmap, auto_adjust = FALSE, background = "transparent",
                   heatmap_legend_side = "left", annotation_legend_side = "bottom")))
  title <- ggdraw() 
  subtitle <- ggdraw() + draw_label_themeRKwhite(paste("Heatmap MEs", sep = " "), 
              element = "plot.subtitle",x = 0.05, hjust = 0, vjust = 1)
  b <- plot_grid(title, subtitle, prow, ncol = 1, rel_heights = c(0.04, 0.05, 0.98)) 
  #Safe the plots in a specified folder <- may have to change the width and height
  ggsave(prow, filename = FILENAME, path = pathPlots , device='png', dpi=300, width = WIDTH,
  height = HEIGHT)
  Normal_hmap <<- Normal_hmap
  }, error=function(e){cat("ERROR :",conditionMessage(e), "\n")})
}
```

## 5.5 ggpicrust2

```{r}

```



